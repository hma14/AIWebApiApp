{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;\nconst brace_expansion_1 = __importDefault(require(\"brace-expansion\"));\nconst assert_valid_pattern_js_1 = require(\"./assert-valid-pattern.js\");\nconst ast_js_1 = require(\"./ast.js\");\nconst escape_js_1 = require(\"./escape.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst minimatch = (p, pattern, options = {}) => {\n  (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false;\n  }\n  return new Minimatch(pattern, options).match(p);\n};\nexports.minimatch = minimatch;\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/;\nconst starDotExtTest = ext => f => !f.startsWith('.') && f.endsWith(ext);\nconst starDotExtTestDot = ext => f => f.endsWith(ext);\nconst starDotExtTestNocase = ext => {\n  ext = ext.toLowerCase();\n  return f => !f.startsWith('.') && f.toLowerCase().endsWith(ext);\n};\nconst starDotExtTestNocaseDot = ext => {\n  ext = ext.toLowerCase();\n  return f => f.toLowerCase().endsWith(ext);\n};\nconst starDotStarRE = /^\\*+\\.\\*+$/;\nconst starDotStarTest = f => !f.startsWith('.') && f.includes('.');\nconst starDotStarTestDot = f => f !== '.' && f !== '..' && f.includes('.');\nconst dotStarRE = /^\\.\\*+$/;\nconst dotStarTest = f => f !== '.' && f !== '..' && f.startsWith('.');\nconst starRE = /^\\*+$/;\nconst starTest = f => f.length !== 0 && !f.startsWith('.');\nconst starTestDot = f => f.length !== 0 && f !== '.' && f !== '..';\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/;\nconst qmarksTestNocase = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExt([$0]);\n  if (!ext) return noext;\n  ext = ext.toLowerCase();\n  return f => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestNocaseDot = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExtDot([$0]);\n  if (!ext) return noext;\n  ext = ext.toLowerCase();\n  return f => noext(f) && f.toLowerCase().endsWith(ext);\n};\nconst qmarksTestDot = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExtDot([$0]);\n  return !ext ? noext : f => noext(f) && f.endsWith(ext);\n};\nconst qmarksTest = ([$0, ext = '']) => {\n  const noext = qmarksTestNoExt([$0]);\n  return !ext ? noext : f => noext(f) && f.endsWith(ext);\n};\nconst qmarksTestNoExt = ([$0]) => {\n  const len = $0.length;\n  return f => f.length === len && !f.startsWith('.');\n};\nconst qmarksTestNoExtDot = ([$0]) => {\n  const len = $0.length;\n  return f => f.length === len && f !== '.' && f !== '..';\n};\n/* c8 ignore start */\nconst defaultPlatform = typeof process === 'object' && process ? typeof process.env === 'object' && process.env && process.env.__MINIMATCH_TESTING_PLATFORM__ || process.platform : 'posix';\nconst path = {\n  win32: {\n    sep: '\\\\'\n  },\n  posix: {\n    sep: '/'\n  }\n};\n/* c8 ignore stop */\nexports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;\nexports.minimatch.sep = exports.sep;\nexports.GLOBSTAR = Symbol('globstar **');\nexports.minimatch.GLOBSTAR = exports.GLOBSTAR;\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?';\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?';\nconst filter = (pattern, options = {}) => p => (0, exports.minimatch)(p, pattern, options);\nexports.filter = filter;\nexports.minimatch.filter = exports.filter;\nconst ext = (a, b = {}) => Object.assign({}, a, b);\nconst defaults = def => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return exports.minimatch;\n  }\n  const orig = exports.minimatch;\n  const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern, options = {}) {\n        super(pattern, ext(def, options));\n      }\n      static defaults(options) {\n        return orig.defaults(ext(def, options)).Minimatch;\n      }\n    },\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(type, parent, options = {}) {\n        super(type, parent, ext(def, options));\n      }\n      /* c8 ignore stop */\n      static fromGlob(pattern, options = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options));\n      }\n    },\n    unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),\n    escape: (s, options = {}) => orig.escape(s, ext(def, options)),\n    filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),\n    defaults: options => orig.defaults(ext(def, options)),\n    makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),\n    braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),\n    match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),\n    sep: orig.sep,\n    GLOBSTAR: exports.GLOBSTAR\n  });\n};\nexports.defaults = defaults;\nexports.minimatch.defaults = exports.defaults;\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nconst braceExpand = (pattern, options = {}) => {\n  (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern];\n  }\n  return (0, brace_expansion_1.default)(pattern);\n};\nexports.braceExpand = braceExpand;\nexports.minimatch.braceExpand = exports.braceExpand;\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();\nexports.makeRe = makeRe;\nexports.minimatch.makeRe = exports.makeRe;\nconst match = (list, pattern, options = {}) => {\n  const mm = new Minimatch(pattern, options);\n  list = list.filter(f => mm.match(f));\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n  return list;\n};\nexports.match = match;\nexports.minimatch.match = exports.match;\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/;\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nclass Minimatch {\n  options;\n  set;\n  pattern;\n  windowsPathsNoEscape;\n  nonegate;\n  negate;\n  comment;\n  empty;\n  preserveMultipleSlashes;\n  partial;\n  globSet;\n  globParts;\n  nocase;\n  isWindows;\n  platform;\n  windowsNoMagicRoot;\n  regexp;\n  constructor(pattern, options = {}) {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    options = options || {};\n    this.options = options;\n    this.pattern = pattern;\n    this.platform = options.platform || defaultPlatform;\n    this.isWindows = this.platform === 'win32';\n    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/');\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;\n    this.regexp = null;\n    this.negate = false;\n    this.nonegate = !!options.nonegate;\n    this.comment = false;\n    this.empty = false;\n    this.partial = !!options.partial;\n    this.nocase = !!this.options.nocase;\n    this.windowsNoMagicRoot = options.windowsNoMagicRoot !== undefined ? options.windowsNoMagicRoot : !!(this.isWindows && this.nocase);\n    this.globSet = [];\n    this.globParts = [];\n    this.set = [];\n    // make the set of regexps etc.\n    this.make();\n  }\n  hasMagic() {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true;\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true;\n      }\n    }\n    return false;\n  }\n  debug(..._) {}\n  make() {\n    const pattern = this.pattern;\n    const options = this.options;\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true;\n      return;\n    }\n    if (!pattern) {\n      this.empty = true;\n      return;\n    }\n    // step 1: figure out negation, etc.\n    this.parseNegate();\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())];\n    if (options.debug) {\n      this.debug = (...args) => console.error(...args);\n    }\n    this.debug(this.pattern, this.globSet);\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s));\n    this.globParts = this.preprocess(rawGlobParts);\n    this.debug(this.pattern, this.globParts);\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC = s[0] === '' && s[1] === '' && (s[2] === '?' || !globMagic.test(s[2])) && !globMagic.test(s[3]);\n        const isDrive = /^[a-z]:/i.test(s[0]);\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))];\n        }\n      }\n      return s.map(ss => this.parse(ss));\n    });\n    this.debug(this.pattern, set);\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(s => s.indexOf(false) === -1);\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i];\n        if (p[0] === '' && p[1] === '' && this.globParts[i][2] === '?' && typeof p[3] === 'string' && /^[a-z]:$/i.test(p[3])) {\n          p[2] = '?';\n        }\n      }\n    }\n    this.debug(this.pattern, this.set);\n  }\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*';\n          }\n        }\n      }\n    }\n    const {\n      optimizationLevel = 1\n    } = this.options;\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts);\n      globParts = this.secondPhasePreProcess(globParts);\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts);\n    } else {\n      // just collapse multiple ** portions into one\n      globParts = this.adjascentGlobstarOptimize(globParts);\n    }\n    return globParts;\n  }\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts) {\n    return globParts.map(parts => {\n      let gs = -1;\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs;\n        while (parts[i + 1] === '**') {\n          i++;\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs);\n        }\n      }\n      return parts;\n    });\n  }\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set, part) => {\n        const prev = set[set.length - 1];\n        if (part === '**' && prev === '**') {\n          return set;\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop();\n            return set;\n          }\n        }\n        set.push(part);\n        return set;\n      }, []);\n      return parts.length === 0 ? [''] : parts;\n    });\n  }\n  levelTwoFileOptimize(parts) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts);\n    }\n    let didSomething = false;\n    do {\n      didSomething = false;\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i];\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue;\n          if (p === '.' || p === '') {\n            didSomething = true;\n            parts.splice(i, 1);\n            i--;\n          }\n        }\n        if (parts[0] === '.' && parts.length === 2 && (parts[1] === '.' || parts[1] === '')) {\n          didSomething = true;\n          parts.pop();\n        }\n      }\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd = 0;\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1];\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true;\n          parts.splice(dd - 1, 2);\n          dd -= 2;\n        }\n      }\n    } while (didSomething);\n    return parts.length === 0 ? [''] : parts;\n  }\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts) {\n    let didSomething = false;\n    do {\n      didSomething = false;\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs = -1;\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss = gs;\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++;\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs);\n          }\n          let next = parts[gs + 1];\n          const p = parts[gs + 2];\n          const p2 = parts[gs + 3];\n          if (next !== '..') continue;\n          if (!p || p === '.' || p === '..' || !p2 || p2 === '.' || p2 === '..') {\n            continue;\n          }\n          didSomething = true;\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1);\n          const other = parts.slice(0);\n          other[gs] = '**';\n          globParts.push(other);\n          gs--;\n        }\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i];\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue;\n            if (p === '.' || p === '') {\n              didSomething = true;\n              parts.splice(i, 1);\n              i--;\n            }\n          }\n          if (parts[0] === '.' && parts.length === 2 && (parts[1] === '.' || parts[1] === '')) {\n            didSomething = true;\n            parts.pop();\n          }\n        }\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd = 0;\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1];\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true;\n            const needDot = dd === 1 && parts[dd + 1] === '**';\n            const splin = needDot ? ['.'] : [];\n            parts.splice(dd - 1, 2, ...splin);\n            if (parts.length === 0) parts.push('');\n            dd -= 2;\n          }\n        }\n      }\n    } while (didSomething);\n    return globParts;\n  }\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts) {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);\n        if (matched) {\n          globParts[i] = [];\n          globParts[j] = matched;\n          break;\n        }\n      }\n    }\n    return globParts.filter(gs => gs.length);\n  }\n  partsMatch(a, b, emptyGSMatch = false) {\n    let ai = 0;\n    let bi = 0;\n    let result = [];\n    let which = '';\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai]);\n        ai++;\n        bi++;\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai]);\n        ai++;\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi]);\n        bi++;\n      } else if (a[ai] === '*' && b[bi] && (this.options.dot || !b[bi].startsWith('.')) && b[bi] !== '**') {\n        if (which === 'b') return false;\n        which = 'a';\n        result.push(a[ai]);\n        ai++;\n        bi++;\n      } else if (b[bi] === '*' && a[ai] && (this.options.dot || !a[ai].startsWith('.')) && a[ai] !== '**') {\n        if (which === 'a') return false;\n        which = 'b';\n        result.push(b[bi]);\n        ai++;\n        bi++;\n      } else {\n        return false;\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result;\n  }\n  parseNegate() {\n    if (this.nonegate) return;\n    const pattern = this.pattern;\n    let negate = false;\n    let negateOffset = 0;\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate;\n      negateOffset++;\n    }\n    if (negateOffset) this.pattern = pattern.slice(negateOffset);\n    this.negate = negate;\n  }\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file, pattern, partial = false) {\n    const options = this.options;\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);\n      const fileUNC = !fileDrive && file[0] === '' && file[1] === '' && file[2] === '?' && /^[a-z]:$/i.test(file[3]);\n      const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);\n      const patternUNC = !patternDrive && pattern[0] === '' && pattern[1] === '' && pattern[2] === '?' && typeof pattern[3] === 'string' && /^[a-z]:$/i.test(pattern[3]);\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd] = [file[fdi], pattern[pdi]];\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd;\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi);\n          } else if (fdi > pdi) {\n            file = file.slice(fdi);\n          }\n        }\n      }\n    }\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const {\n      optimizationLevel = 1\n    } = this.options;\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file);\n    }\n    this.debug('matchOne', this, {\n      file,\n      pattern\n    });\n    this.debug('matchOne', file.length, pattern.length);\n    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n      this.debug('matchOne loop');\n      var p = pattern[pi];\n      var f = file[fi];\n      this.debug(pattern, p, f);\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false;\n      }\n      /* c8 ignore stop */\n      if (p === exports.GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f]);\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi;\n        var pr = pi + 1;\n        if (pr === pl) {\n          this.debug('** at the end');\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n          }\n          return true;\n        }\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr];\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee);\n            // found a match.\n            return true;\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n              this.debug('dot detected!', file, fr, pattern, pr);\n              break;\n            }\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue');\n            fr++;\n          }\n        }\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n          if (fr === fl) {\n            return true;\n          }\n        }\n        /* c8 ignore stop */\n        return false;\n      }\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit;\n      if (typeof p === 'string') {\n        hit = f === p;\n        this.debug('string match', p, f, hit);\n      } else {\n        hit = p.test(f);\n        this.debug('pattern match', p, f, hit);\n      }\n      if (!hit) return false;\n    }\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true;\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial;\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === '';\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?');\n    }\n    /* c8 ignore stop */\n  }\n  braceExpand() {\n    return (0, exports.braceExpand)(this.pattern, this.options);\n  }\n  parse(pattern) {\n    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);\n    const options = this.options;\n    // shortcuts\n    if (pattern === '**') return exports.GLOBSTAR;\n    if (pattern === '') return '';\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m;\n    let fastTest = null;\n    if (m = pattern.match(starRE)) {\n      fastTest = options.dot ? starTestDot : starTest;\n    } else if (m = pattern.match(starDotExtRE)) {\n      fastTest = (options.nocase ? options.dot ? starDotExtTestNocaseDot : starDotExtTestNocase : options.dot ? starDotExtTestDot : starDotExtTest)(m[1]);\n    } else if (m = pattern.match(qmarksRE)) {\n      fastTest = (options.nocase ? options.dot ? qmarksTestNocaseDot : qmarksTestNocase : options.dot ? qmarksTestDot : qmarksTest)(m);\n    } else if (m = pattern.match(starDotStarRE)) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest;\n    } else if (m = pattern.match(dotStarRE)) {\n      fastTest = dotStarTest;\n    }\n    const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();\n    if (fastTest && typeof re === 'object') {\n      // Avoids overriding in frozen environments\n      Reflect.defineProperty(re, 'test', {\n        value: fastTest\n      });\n    }\n    return re;\n  }\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp;\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set;\n    if (!set.length) {\n      this.regexp = false;\n      return this.regexp;\n    }\n    const options = this.options;\n    const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n    const flags = new Set(options.nocase ? ['i'] : []);\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set.map(pattern => {\n      const pp = pattern.map(p => {\n        if (p instanceof RegExp) {\n          for (const f of p.flags.split('')) flags.add(f);\n        }\n        return typeof p === 'string' ? regExpEscape(p) : p === exports.GLOBSTAR ? exports.GLOBSTAR : p._src;\n      });\n      pp.forEach((p, i) => {\n        const next = pp[i + 1];\n        const prev = pp[i - 1];\n        if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {\n          return;\n        }\n        if (prev === undefined) {\n          if (next !== undefined && next !== exports.GLOBSTAR) {\n            pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next;\n          } else {\n            pp[i] = twoStar;\n          }\n        } else if (next === undefined) {\n          pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?';\n        } else if (next !== exports.GLOBSTAR) {\n          pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next;\n          pp[i + 1] = exports.GLOBSTAR;\n        }\n      });\n      return pp.filter(p => p !== exports.GLOBSTAR).join('/');\n    }).join('|');\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$';\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$';\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''));\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false;\n    }\n    /* c8 ignore stop */\n    return this.regexp;\n  }\n  slashSplit(p) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/');\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)];\n    } else {\n      return p.split(/\\/+/);\n    }\n  }\n  match(f, partial = this.partial) {\n    this.debug('match', f, this.pattern);\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false;\n    }\n    if (this.empty) {\n      return f === '';\n    }\n    if (f === '/' && partial) {\n      return true;\n    }\n    const options = this.options;\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/');\n    }\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f);\n    this.debug(this.pattern, 'split', ff);\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n    const set = this.set;\n    this.debug(this.pattern, 'set', set);\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename = ff[ff.length - 1];\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i];\n      }\n    }\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i];\n      let file = ff;\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename];\n      }\n      const hit = this.matchOne(file, pattern, partial);\n      if (hit) {\n        if (options.flipNegate) {\n          return true;\n        }\n        return !this.negate;\n      }\n    }\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false;\n    }\n    return this.negate;\n  }\n  static defaults(def) {\n    return exports.minimatch.defaults(def).Minimatch;\n  }\n}\nexports.Minimatch = Minimatch;\n/* c8 ignore start */\nvar ast_js_2 = require(\"./ast.js\");\nObject.defineProperty(exports, \"AST\", {\n  enumerable: true,\n  get: function () {\n    return ast_js_2.AST;\n  }\n});\nvar escape_js_2 = require(\"./escape.js\");\nObject.defineProperty(exports, \"escape\", {\n  enumerable: true,\n  get: function () {\n    return escape_js_2.escape;\n  }\n});\nvar unescape_js_2 = require(\"./unescape.js\");\nObject.defineProperty(exports, \"unescape\", {\n  enumerable: true,\n  get: function () {\n    return unescape_js_2.unescape;\n  }\n});\n/* c8 ignore stop */\nexports.minimatch.AST = ast_js_1.AST;\nexports.minimatch.Minimatch = Minimatch;\nexports.minimatch.escape = escape_js_1.escape;\nexports.minimatch.unescape = unescape_js_1.unescape;","map":{"version":3,"names":["brace_expansion_1","__importDefault","require","assert_valid_pattern_js_1","ast_js_1","escape_js_1","unescape_js_1","minimatch","p","pattern","options","assertValidPattern","nocomment","charAt","Minimatch","match","exports","starDotExtRE","starDotExtTest","ext","f","startsWith","endsWith","starDotExtTestDot","starDotExtTestNocase","toLowerCase","starDotExtTestNocaseDot","starDotStarRE","starDotStarTest","includes","starDotStarTestDot","dotStarRE","dotStarTest","starRE","starTest","length","starTestDot","qmarksRE","qmarksTestNocase","$0","noext","qmarksTestNoExt","qmarksTestNocaseDot","qmarksTestNoExtDot","qmarksTestDot","qmarksTest","len","defaultPlatform","process","env","__MINIMATCH_TESTING_PLATFORM__","platform","path","win32","sep","posix","GLOBSTAR","Symbol","qmark","star","twoStarDot","twoStarNoDot","filter","a","b","Object","assign","defaults","def","keys","orig","m","constructor","AST","type","parent","fromGlob","unescape","s","escape","makeRe","braceExpand","list","nobrace","test","default","mm","nonull","push","globMagic","regExpEscape","replace","set","windowsPathsNoEscape","nonegate","negate","comment","empty","preserveMultipleSlashes","partial","globSet","globParts","nocase","isWindows","windowsNoMagicRoot","regexp","allowWindowsEscape","undefined","make","hasMagic","magicalBraces","part","debug","_","parseNegate","Set","args","console","error","rawGlobParts","map","slashSplit","preprocess","__","isUNC","isDrive","slice","ss","parse","indexOf","i","noglobstar","j","optimizationLevel","firstPhasePreProcess","secondPhasePreProcess","levelOneOptimize","adjascentGlobstarOptimize","parts","gs","splice","reduce","prev","pop","levelTwoFileOptimize","Array","isArray","didSomething","dd","gss","next","p2","other","needDot","splin","matched","partsMatch","emptyGSMatch","ai","bi","result","which","dot","negateOffset","matchOne","file","fileDrive","fileUNC","patternDrive","patternUNC","fdi","pdi","fd","pd","fi","pi","fl","pl","fr","pr","swallowee","hit","Error","fastTest","re","toMMPattern","Reflect","defineProperty","value","twoStar","flags","pp","RegExp","split","add","_src","forEach","join","open","close","ex","ff","filename","matchBase","flipNegate","ast_js_2","enumerable","get","escape_js_2","unescape_js_2"],"sources":["E:\\programs\\AI programs\\AIMessageApp\\frontend\\node_modules\\pkghub\\node_modules\\minimatch\\src\\index.ts"],"sourcesContent":["import expand from 'brace-expansion'\nimport { assertValidPattern } from './assert-valid-pattern.js'\nimport { AST, ExtglobType } from './ast.js'\nimport { escape } from './escape.js'\nimport { unescape } from './unescape.js'\n\ntype Platform =\n  | 'aix'\n  | 'android'\n  | 'darwin'\n  | 'freebsd'\n  | 'haiku'\n  | 'linux'\n  | 'openbsd'\n  | 'sunos'\n  | 'win32'\n  | 'cygwin'\n  | 'netbsd'\n\nexport interface MinimatchOptions {\n  nobrace?: boolean\n  nocomment?: boolean\n  nonegate?: boolean\n  debug?: boolean\n  noglobstar?: boolean\n  noext?: boolean\n  nonull?: boolean\n  windowsPathsNoEscape?: boolean\n  allowWindowsEscape?: boolean\n  partial?: boolean\n  dot?: boolean\n  nocase?: boolean\n  nocaseMagicOnly?: boolean\n  magicalBraces?: boolean\n  matchBase?: boolean\n  flipNegate?: boolean\n  preserveMultipleSlashes?: boolean\n  optimizationLevel?: number\n  platform?: Platform\n  windowsNoMagicRoot?: boolean\n}\n\nexport const minimatch = (\n  p: string,\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\n// Optimized checking for the most common glob patterns.\nconst starDotExtRE = /^\\*+([^+@!?\\*\\[\\(]*)$/\nconst starDotExtTest = (ext: string) => (f: string) =>\n  !f.startsWith('.') && f.endsWith(ext)\nconst starDotExtTestDot = (ext: string) => (f: string) => f.endsWith(ext)\nconst starDotExtTestNocase = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => !f.startsWith('.') && f.toLowerCase().endsWith(ext)\n}\nconst starDotExtTestNocaseDot = (ext: string) => {\n  ext = ext.toLowerCase()\n  return (f: string) => f.toLowerCase().endsWith(ext)\n}\nconst starDotStarRE = /^\\*+\\.\\*+$/\nconst starDotStarTest = (f: string) => !f.startsWith('.') && f.includes('.')\nconst starDotStarTestDot = (f: string) =>\n  f !== '.' && f !== '..' && f.includes('.')\nconst dotStarRE = /^\\.\\*+$/\nconst dotStarTest = (f: string) => f !== '.' && f !== '..' && f.startsWith('.')\nconst starRE = /^\\*+$/\nconst starTest = (f: string) => f.length !== 0 && !f.startsWith('.')\nconst starTestDot = (f: string) => f.length !== 0 && f !== '.' && f !== '..'\nconst qmarksRE = /^\\?+([^+@!?\\*\\[\\(]*)?$/\nconst qmarksTestNocase = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestNocaseDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  if (!ext) return noext\n  ext = ext.toLowerCase()\n  return (f: string) => noext(f) && f.toLowerCase().endsWith(ext)\n}\nconst qmarksTestDot = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExtDot([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTest = ([$0, ext = '']: RegExpMatchArray) => {\n  const noext = qmarksTestNoExt([$0])\n  return !ext ? noext : (f: string) => noext(f) && f.endsWith(ext)\n}\nconst qmarksTestNoExt = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && !f.startsWith('.')\n}\nconst qmarksTestNoExtDot = ([$0]: RegExpMatchArray) => {\n  const len = $0.length\n  return (f: string) => f.length === len && f !== '.' && f !== '..'\n}\n\n/* c8 ignore start */\nconst defaultPlatform: Platform = (\n  typeof process === 'object' && process\n    ? (typeof process.env === 'object' &&\n        process.env &&\n        process.env.__MINIMATCH_TESTING_PLATFORM__) ||\n      process.platform\n    : 'posix'\n) as Platform\ntype Sep = '\\\\' | '/'\nconst path: { [k: string]: { sep: Sep } } = {\n  win32: { sep: '\\\\' },\n  posix: { sep: '/' },\n}\n/* c8 ignore stop */\n\nexport const sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep\nminimatch.sep = sep\n\nexport const GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\/|^)\\\\.).)*?'\n\nexport const filter =\n  (pattern: string, options: MinimatchOptions = {}) =>\n  (p: string) =>\n    minimatch(p, pattern, options)\nminimatch.filter = filter\n\nconst ext = (a: MinimatchOptions, b: MinimatchOptions = {}) =>\n  Object.assign({}, a, b)\n\nexport const defaults = (def: MinimatchOptions): typeof minimatch => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p: string, pattern: string, options: MinimatchOptions = {}) =>\n    orig(p, pattern, ext(def, options))\n\n  return Object.assign(m, {\n    Minimatch: class Minimatch extends orig.Minimatch {\n      constructor(pattern: string, options: MinimatchOptions = {}) {\n        super(pattern, ext(def, options))\n      }\n      static defaults(options: MinimatchOptions) {\n        return orig.defaults(ext(def, options)).Minimatch\n      }\n    },\n\n    AST: class AST extends orig.AST {\n      /* c8 ignore start */\n      constructor(\n        type: ExtglobType | null,\n        parent?: AST,\n        options: MinimatchOptions = {}\n      ) {\n        super(type, parent, ext(def, options))\n      }\n      /* c8 ignore stop */\n\n      static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n        return orig.AST.fromGlob(pattern, ext(def, options))\n      }\n    },\n\n    unescape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.unescape(s, ext(def, options)),\n\n    escape: (\n      s: string,\n      options: Pick<MinimatchOptions, 'windowsPathsNoEscape'> = {}\n    ) => orig.escape(s, ext(def, options)),\n\n    filter: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.filter(pattern, ext(def, options)),\n\n    defaults: (options: MinimatchOptions) => orig.defaults(ext(def, options)),\n\n    makeRe: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.makeRe(pattern, ext(def, options)),\n\n    braceExpand: (pattern: string, options: MinimatchOptions = {}) =>\n      orig.braceExpand(pattern, ext(def, options)),\n\n    match: (list: string[], pattern: string, options: MinimatchOptions = {}) =>\n      orig.match(list, pattern, ext(def, options)),\n\n    sep: orig.sep,\n    GLOBSTAR: GLOBSTAR as typeof GLOBSTAR,\n  })\n}\nminimatch.defaults = defaults\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nexport const braceExpand = (\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\nminimatch.braceExpand = braceExpand\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\n\nexport const makeRe = (pattern: string, options: MinimatchOptions = {}) =>\n  new Minimatch(pattern, options).makeRe()\nminimatch.makeRe = makeRe\n\nexport const match = (\n  list: string[],\n  pattern: string,\n  options: MinimatchOptions = {}\n) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\nminimatch.match = match\n\n// replace stuff like \\* with *\nconst globMagic = /[?*]|[+@!]\\(.*?\\)|\\[|\\]/\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\nexport type MMRegExp = RegExp & {\n  _src?: string\n  _glob?: string\n}\n\nexport type ParseReturnFiltered = string | MMRegExp | typeof GLOBSTAR\nexport type ParseReturn = ParseReturnFiltered | false\n\nexport class Minimatch {\n  options: MinimatchOptions\n  set: ParseReturnFiltered[][]\n  pattern: string\n\n  windowsPathsNoEscape: boolean\n  nonegate: boolean\n  negate: boolean\n  comment: boolean\n  empty: boolean\n  preserveMultipleSlashes: boolean\n  partial: boolean\n  globSet: string[]\n  globParts: string[][]\n  nocase: boolean\n\n  isWindows: boolean\n  platform: Platform\n  windowsNoMagicRoot: boolean\n\n  regexp: false | null | MMRegExp\n  constructor(pattern: string, options: MinimatchOptions = {}) {\n    assertValidPattern(pattern)\n\n    options = options || {}\n    this.options = options\n    this.pattern = pattern\n    this.platform = options.platform || defaultPlatform\n    this.isWindows = this.platform === 'win32'\n    this.windowsPathsNoEscape =\n      !!options.windowsPathsNoEscape || options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.preserveMultipleSlashes = !!options.preserveMultipleSlashes\n    this.regexp = null\n    this.negate = false\n    this.nonegate = !!options.nonegate\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n    this.nocase = !!this.options.nocase\n    this.windowsNoMagicRoot =\n      options.windowsNoMagicRoot !== undefined\n        ? options.windowsNoMagicRoot\n        : !!(this.isWindows && this.nocase)\n\n    this.globSet = []\n    this.globParts = []\n    this.set = []\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  hasMagic(): boolean {\n    if (this.options.magicalBraces && this.set.length > 1) {\n      return true\n    }\n    for (const pattern of this.set) {\n      for (const part of pattern) {\n        if (typeof part !== 'string') return true\n      }\n    }\n    return false\n  }\n\n  debug(..._: any[]) {}\n\n  make() {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    this.globSet = [...new Set(this.braceExpand())]\n\n    if (options.debug) {\n      this.debug = (...args: any[]) => console.error(...args)\n    }\n\n    this.debug(this.pattern, this.globSet)\n\n    // step 3: now we have a set, so turn each one into a series of\n    // path-portion matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    //\n    // First, we preprocess to make the glob pattern sets a bit simpler\n    // and deduped.  There are some perf-killing patterns that can cause\n    // problems with a glob walk, but we can simplify them down a bit.\n    const rawGlobParts = this.globSet.map(s => this.slashSplit(s))\n    this.globParts = this.preprocess(rawGlobParts)\n    this.debug(this.pattern, this.globParts)\n\n    // glob --> regexps\n    let set = this.globParts.map((s, _, __) => {\n      if (this.isWindows && this.windowsNoMagicRoot) {\n        // check if it's a drive or unc path.\n        const isUNC =\n          s[0] === '' &&\n          s[1] === '' &&\n          (s[2] === '?' || !globMagic.test(s[2])) &&\n          !globMagic.test(s[3])\n        const isDrive = /^[a-z]:/i.test(s[0])\n        if (isUNC) {\n          return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))]\n        } else if (isDrive) {\n          return [s[0], ...s.slice(1).map(ss => this.parse(ss))]\n        }\n      }\n      return s.map(ss => this.parse(ss))\n    })\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    this.set = set.filter(\n      s => s.indexOf(false) === -1\n    ) as ParseReturnFiltered[][]\n\n    // do not treat the ? in UNC paths as magic\n    if (this.isWindows) {\n      for (let i = 0; i < this.set.length; i++) {\n        const p = this.set[i]\n        if (\n          p[0] === '' &&\n          p[1] === '' &&\n          this.globParts[i][2] === '?' &&\n          typeof p[3] === 'string' &&\n          /^[a-z]:$/i.test(p[3])\n        ) {\n          p[2] = '?'\n        }\n      }\n    }\n\n    this.debug(this.pattern, this.set)\n  }\n\n  // various transforms to equivalent pattern sets that are\n  // faster to process in a filesystem walk.  The goal is to\n  // eliminate what we can, and push all ** patterns as far\n  // to the right as possible, even if it increases the number\n  // of patterns that we have to process.\n  preprocess(globParts: string[][]) {\n    // if we're not in globstar mode, then turn all ** into *\n    if (this.options.noglobstar) {\n      for (let i = 0; i < globParts.length; i++) {\n        for (let j = 0; j < globParts[i].length; j++) {\n          if (globParts[i][j] === '**') {\n            globParts[i][j] = '*'\n          }\n        }\n      }\n    }\n\n    const { optimizationLevel = 1 } = this.options\n\n    if (optimizationLevel >= 2) {\n      // aggressive optimization for the purpose of fs walking\n      globParts = this.firstPhasePreProcess(globParts)\n      globParts = this.secondPhasePreProcess(globParts)\n    } else if (optimizationLevel >= 1) {\n      // just basic optimizations to remove some .. parts\n      globParts = this.levelOneOptimize(globParts)\n    } else {\n      // just collapse multiple ** portions into one\n      globParts = this.adjascentGlobstarOptimize(globParts)\n    }\n\n    return globParts\n  }\n\n  // just get rid of adjascent ** portions\n  adjascentGlobstarOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      let gs: number = -1\n      while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n        let i = gs\n        while (parts[i + 1] === '**') {\n          i++\n        }\n        if (i !== gs) {\n          parts.splice(gs, i - gs)\n        }\n      }\n      return parts\n    })\n  }\n\n  // get rid of adjascent ** and resolve .. portions\n  levelOneOptimize(globParts: string[][]) {\n    return globParts.map(parts => {\n      parts = parts.reduce((set: string[], part) => {\n        const prev = set[set.length - 1]\n        if (part === '**' && prev === '**') {\n          return set\n        }\n        if (part === '..') {\n          if (prev && prev !== '..' && prev !== '.' && prev !== '**') {\n            set.pop()\n            return set\n          }\n        }\n        set.push(part)\n        return set\n      }, [])\n      return parts.length === 0 ? [''] : parts\n    })\n  }\n\n  levelTwoFileOptimize(parts: string | string[]) {\n    if (!Array.isArray(parts)) {\n      parts = this.slashSplit(parts)\n    }\n    let didSomething: boolean = false\n    do {\n      didSomething = false\n      // <pre>/<e>/<rest> -> <pre>/<rest>\n      if (!this.preserveMultipleSlashes) {\n        for (let i = 1; i < parts.length - 1; i++) {\n          const p = parts[i]\n          // don't squeeze out UNC patterns\n          if (i === 1 && p === '' && parts[0] === '') continue\n          if (p === '.' || p === '') {\n            didSomething = true\n            parts.splice(i, 1)\n            i--\n          }\n        }\n        if (\n          parts[0] === '.' &&\n          parts.length === 2 &&\n          (parts[1] === '.' || parts[1] === '')\n        ) {\n          didSomething = true\n          parts.pop()\n        }\n      }\n\n      // <pre>/<p>/../<rest> -> <pre>/<rest>\n      let dd: number = 0\n      while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n        const p = parts[dd - 1]\n        if (p && p !== '.' && p !== '..' && p !== '**') {\n          didSomething = true\n          parts.splice(dd - 1, 2)\n          dd -= 2\n        }\n      }\n    } while (didSomething)\n    return parts.length === 0 ? [''] : parts\n  }\n\n  // First phase: single-pattern processing\n  // <pre> is 1 or more portions\n  // <rest> is 1 or more portions\n  // <p> is any portion other than ., .., '', or **\n  // <e> is . or ''\n  //\n  // **/.. is *brutal* for filesystem walking performance, because\n  // it effectively resets the recursive walk each time it occurs,\n  // and ** cannot be reduced out by a .. pattern part like a regexp\n  // or most strings (other than .., ., and '') can be.\n  //\n  // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n  // <pre>/<e>/<rest> -> <pre>/<rest>\n  // <pre>/<p>/../<rest> -> <pre>/<rest>\n  // **/**/<rest> -> **/<rest>\n  //\n  // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow\n  // this WOULD be allowed if ** did follow symlinks, or * didn't\n  firstPhasePreProcess(globParts: string[][]) {\n    let didSomething = false\n    do {\n      didSomething = false\n      // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}\n      for (let parts of globParts) {\n        let gs: number = -1\n        while (-1 !== (gs = parts.indexOf('**', gs + 1))) {\n          let gss: number = gs\n          while (parts[gss + 1] === '**') {\n            // <pre>/**/**/<rest> -> <pre>/**/<rest>\n            gss++\n          }\n          // eg, if gs is 2 and gss is 4, that means we have 3 **\n          // parts, and can remove 2 of them.\n          if (gss > gs) {\n            parts.splice(gs + 1, gss - gs)\n          }\n\n          let next = parts[gs + 1]\n          const p = parts[gs + 2]\n          const p2 = parts[gs + 3]\n          if (next !== '..') continue\n          if (\n            !p ||\n            p === '.' ||\n            p === '..' ||\n            !p2 ||\n            p2 === '.' ||\n            p2 === '..'\n          ) {\n            continue\n          }\n          didSomething = true\n          // edit parts in place, and push the new one\n          parts.splice(gs, 1)\n          const other = parts.slice(0)\n          other[gs] = '**'\n          globParts.push(other)\n          gs--\n        }\n\n        // <pre>/<e>/<rest> -> <pre>/<rest>\n        if (!this.preserveMultipleSlashes) {\n          for (let i = 1; i < parts.length - 1; i++) {\n            const p = parts[i]\n            // don't squeeze out UNC patterns\n            if (i === 1 && p === '' && parts[0] === '') continue\n            if (p === '.' || p === '') {\n              didSomething = true\n              parts.splice(i, 1)\n              i--\n            }\n          }\n          if (\n            parts[0] === '.' &&\n            parts.length === 2 &&\n            (parts[1] === '.' || parts[1] === '')\n          ) {\n            didSomething = true\n            parts.pop()\n          }\n        }\n\n        // <pre>/<p>/../<rest> -> <pre>/<rest>\n        let dd: number = 0\n        while (-1 !== (dd = parts.indexOf('..', dd + 1))) {\n          const p = parts[dd - 1]\n          if (p && p !== '.' && p !== '..' && p !== '**') {\n            didSomething = true\n            const needDot = dd === 1 && parts[dd + 1] === '**'\n            const splin = needDot ? ['.'] : []\n            parts.splice(dd - 1, 2, ...splin)\n            if (parts.length === 0) parts.push('')\n            dd -= 2\n          }\n        }\n      }\n    } while (didSomething)\n\n    return globParts\n  }\n\n  // second phase: multi-pattern dedupes\n  // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>\n  // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>\n  // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>\n  //\n  // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>\n  // ^-- not valid because ** doens't follow symlinks\n  secondPhasePreProcess(globParts: string[][]): string[][] {\n    for (let i = 0; i < globParts.length - 1; i++) {\n      for (let j = i + 1; j < globParts.length; j++) {\n        const matched = this.partsMatch(\n          globParts[i],\n          globParts[j],\n          !this.preserveMultipleSlashes\n        )\n        if (matched) {\n          globParts[i] = []\n          globParts[j] = matched\n          break\n        }\n      }\n    }\n    return globParts.filter(gs => gs.length)\n  }\n\n  partsMatch(\n    a: string[],\n    b: string[],\n    emptyGSMatch: boolean = false\n  ): false | string[] {\n    let ai = 0\n    let bi = 0\n    let result: string[] = []\n    let which: string = ''\n    while (ai < a.length && bi < b.length) {\n      if (a[ai] === b[bi]) {\n        result.push(which === 'b' ? b[bi] : a[ai])\n        ai++\n        bi++\n      } else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {\n        result.push(a[ai])\n        ai++\n      } else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {\n        result.push(b[bi])\n        bi++\n      } else if (\n        a[ai] === '*' &&\n        b[bi] &&\n        (this.options.dot || !b[bi].startsWith('.')) &&\n        b[bi] !== '**'\n      ) {\n        if (which === 'b') return false\n        which = 'a'\n        result.push(a[ai])\n        ai++\n        bi++\n      } else if (\n        b[bi] === '*' &&\n        a[ai] &&\n        (this.options.dot || !a[ai].startsWith('.')) &&\n        a[ai] !== '**'\n      ) {\n        if (which === 'a') return false\n        which = 'b'\n        result.push(b[bi])\n        ai++\n        bi++\n      } else {\n        return false\n      }\n    }\n    // if we fall out of the loop, it means they two are identical\n    // as long as their lengths match\n    return a.length === b.length && result\n  }\n\n  parseNegate() {\n    if (this.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file: string[], pattern: ParseReturn[], partial: boolean = false) {\n    const options = this.options\n\n    // UNC paths like //?/X:/... can match X:/... and vice versa\n    // Drive letters in absolute drive or unc paths are always compared\n    // case-insensitively.\n    if (this.isWindows) {\n      const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0])\n      const fileUNC =\n        !fileDrive &&\n        file[0] === '' &&\n        file[1] === '' &&\n        file[2] === '?' &&\n        /^[a-z]:$/i.test(file[3])\n\n      const patternDrive =\n        typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0])\n      const patternUNC =\n        !patternDrive &&\n        pattern[0] === '' &&\n        pattern[1] === '' &&\n        pattern[2] === '?' &&\n        typeof pattern[3] === 'string' &&\n        /^[a-z]:$/i.test(pattern[3])\n\n      const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined\n      const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined\n      if (typeof fdi === 'number' && typeof pdi === 'number') {\n        const [fd, pd]: [string, string] = [file[fdi], pattern[pdi] as string]\n        if (fd.toLowerCase() === pd.toLowerCase()) {\n          pattern[pdi] = fd\n          if (pdi > fdi) {\n            pattern = pattern.slice(pdi)\n          } else if (fdi > pdi) {\n            file = file.slice(fdi)\n          }\n        }\n      }\n    }\n\n    // resolve and reduce . and .. portions in the file as well.\n    // dont' need to do the second phase, because it's only one string[]\n    const { optimizationLevel = 1 } = this.options\n    if (optimizationLevel >= 2) {\n      file = this.levelTwoFileOptimize(file)\n    }\n\n    this.debug('matchOne', this, { file, pattern })\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (\n      var fi = 0, pi = 0, fl = file.length, pl = pattern.length;\n      fi < fl && pi < pl;\n      fi++, pi++\n    ) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* c8 ignore start */\n      if (p === false) {\n        return false\n      }\n      /* c8 ignore stop */\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (\n              file[fi] === '.' ||\n              file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')\n            )\n              return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (\n              swallowee === '.' ||\n              swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')\n            ) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        /* c8 ignore start */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) {\n            return true\n          }\n        }\n        /* c8 ignore stop */\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      let hit: boolean\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = p.test(f)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return fi === fl - 1 && file[fi] === ''\n\n      /* c8 ignore start */\n    } else {\n      // should be unreachable.\n      throw new Error('wtf?')\n    }\n    /* c8 ignore stop */\n  }\n\n  braceExpand() {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse(pattern: string): ParseReturn {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') return GLOBSTAR\n    if (pattern === '') return ''\n\n    // far and away, the most common glob pattern parts are\n    // *, *.*, and *.<ext>  Add a fast check method for those.\n    let m: RegExpMatchArray | null\n    let fastTest: null | ((f: string) => boolean) = null\n    if ((m = pattern.match(starRE))) {\n      fastTest = options.dot ? starTestDot : starTest\n    } else if ((m = pattern.match(starDotExtRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? starDotExtTestNocaseDot\n            : starDotExtTestNocase\n          : options.dot\n          ? starDotExtTestDot\n          : starDotExtTest\n      )(m[1])\n    } else if ((m = pattern.match(qmarksRE))) {\n      fastTest = (\n        options.nocase\n          ? options.dot\n            ? qmarksTestNocaseDot\n            : qmarksTestNocase\n          : options.dot\n          ? qmarksTestDot\n          : qmarksTest\n      )(m)\n    } else if ((m = pattern.match(starDotStarRE))) {\n      fastTest = options.dot ? starDotStarTestDot : starDotStarTest\n    } else if ((m = pattern.match(dotStarRE))) {\n      fastTest = dotStarTest\n    }\n\n    const re = AST.fromGlob(pattern, this.options).toMMPattern()\n    if (fastTest && typeof re === 'object') {\n      // Avoids overriding in frozen environments\n      Reflect.defineProperty(re, 'test', { value: fastTest })\n    }\n    return re\n  }\n\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar\n      ? star\n      : options.dot\n      ? twoStarDot\n      : twoStarNoDot\n    const flags = new Set(options.nocase ? ['i'] : [])\n\n    // regexpify non-globstar patterns\n    // if ** is only item, then we just do one twoStar\n    // if ** is first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if ** is last, append (\\/twoStar|) to previous\n    // if ** is in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set\n      .map(pattern => {\n        const pp: (string | typeof GLOBSTAR)[] = pattern.map(p => {\n          if (p instanceof RegExp) {\n            for (const f of p.flags.split('')) flags.add(f)\n          }\n          return typeof p === 'string'\n            ? regExpEscape(p)\n            : p === GLOBSTAR\n            ? GLOBSTAR\n            : p._src\n        }) as (string | typeof GLOBSTAR)[]\n        pp.forEach((p, i) => {\n          const next = pp[i + 1]\n          const prev = pp[i - 1]\n          if (p !== GLOBSTAR || prev === GLOBSTAR) {\n            return\n          }\n          if (prev === undefined) {\n            if (next !== undefined && next !== GLOBSTAR) {\n              pp[i + 1] = '(?:\\\\/|' + twoStar + '\\\\/)?' + next\n            } else {\n              pp[i] = twoStar\n            }\n          } else if (next === undefined) {\n            pp[i - 1] = prev + '(?:\\\\/|' + twoStar + ')?'\n          } else if (next !== GLOBSTAR) {\n            pp[i - 1] = prev + '(?:\\\\/|\\\\/' + twoStar + '\\\\/)' + next\n            pp[i + 1] = GLOBSTAR\n          }\n        })\n        return pp.filter(p => p !== GLOBSTAR).join('/')\n      })\n      .join('|')\n\n    // need to wrap in parens if we had more than one thing with |,\n    // otherwise only the first will be anchored to ^ and the last to $\n    const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', '']\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^' + open + re + close + '$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').+$'\n\n    try {\n      this.regexp = new RegExp(re, [...flags].join(''))\n      /* c8 ignore start */\n    } catch (ex) {\n      // should be impossible\n      this.regexp = false\n    }\n    /* c8 ignore stop */\n    return this.regexp\n  }\n\n  slashSplit(p: string) {\n    // if p starts with // on windows, we preserve that\n    // so that UNC paths aren't broken.  Otherwise, any number of\n    // / characters are coalesced into one, unless\n    // preserveMultipleSlashes is set to true.\n    if (this.preserveMultipleSlashes) {\n      return p.split('/')\n    } else if (this.isWindows && /^\\/\\/[^\\/]+/.test(p)) {\n      // add an extra '' for the one we lose\n      return ['', ...p.split(/\\/+/)]\n    } else {\n      return p.split(/\\/+/)\n    }\n  }\n\n  match(f: string, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) {\n      return false\n    }\n    if (this.empty) {\n      return f === ''\n    }\n\n    if (f === '/' && partial) {\n      return true\n    }\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (this.isWindows) {\n      f = f.split('\\\\').join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    const ff = this.slashSplit(f)\n    this.debug(this.pattern, 'split', ff)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename: string = ff[ff.length - 1]\n    if (!filename) {\n      for (let i = ff.length - 2; !filename && i >= 0; i--) {\n        filename = ff[i]\n      }\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = ff\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) {\n          return true\n        }\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) {\n      return false\n    }\n    return this.negate\n  }\n\n  static defaults(def: MinimatchOptions) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n/* c8 ignore start */\nexport { AST } from './ast.js'\nexport { escape } from './escape.js'\nexport { unescape } from './unescape.js'\n/* c8 ignore stop */\nminimatch.AST = AST\nminimatch.Minimatch = Minimatch\nminimatch.escape = escape\nminimatch.unescape = unescape\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}