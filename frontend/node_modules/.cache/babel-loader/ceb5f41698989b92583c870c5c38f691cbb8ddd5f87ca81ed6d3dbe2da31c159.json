{"ast":null,"code":"\"use strict\";\n\n// parse a single path portion\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AST = void 0;\nconst brace_expressions_js_1 = require(\"./brace-expressions.js\");\nconst unescape_js_1 = require(\"./unescape.js\");\nconst types = new Set(['!', '?', '+', '*', '@']);\nconst isExtglobType = c => types.has(c);\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))';\nconst startNoDot = '(?!\\\\.)';\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.']);\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.']);\nconst reSpecials = new Set('().*{}+?[]^$\\\\!');\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// any single thing other than /\nconst qmark = '[^/]';\n// * => any number of characters\nconst star = qmark + '*?';\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?';\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\nclass AST {\n  type;\n  #root;\n  #hasMagic;\n  #uflag = false;\n  #parts = [];\n  #parent;\n  #parentIndex;\n  #negs;\n  #filledNegs = false;\n  #options;\n  #toString;\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt = false;\n  constructor(type, parent, options = {}) {\n    this.type = type;\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true;\n    this.#parent = parent;\n    this.#root = this.#parent ? this.#parent.#root : this;\n    this.#options = this.#root === this ? options : this.#root.#options;\n    this.#negs = this.#root === this ? [] : this.#root.#negs;\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this);\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;\n  }\n  get hasMagic() {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic;\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue;\n      if (p.type || p.hasMagic) return this.#hasMagic = true;\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic;\n  }\n  // reconstructs the pattern\n  toString() {\n    if (this.#toString !== undefined) return this.#toString;\n    if (!this.type) {\n      return this.#toString = this.#parts.map(p => String(p)).join('');\n    } else {\n      return this.#toString = this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')';\n    }\n  }\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root');\n    if (this.#filledNegs) return this;\n    /* c8 ignore stop */\n    // call toString() once to fill this out\n    this.toString();\n    this.#filledNegs = true;\n    let n;\n    while (n = this.#negs.pop()) {\n      if (n.type !== '!') continue;\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p = n;\n      let pp = p.#parent;\n      while (pp) {\n        for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??');\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i]);\n          }\n        }\n        p = pp;\n        pp = p.#parent;\n      }\n    }\n    return this;\n  }\n  push(...parts) {\n    for (const p of parts) {\n      if (p === '') continue;\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p);\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p);\n    }\n  }\n  toJSON() {\n    const ret = this.type === null ? this.#parts.slice().map(p => typeof p === 'string' ? p : p.toJSON()) : [this.type, ...this.#parts.map(p => p.toJSON())];\n    if (this.isStart() && !this.type) ret.unshift([]);\n    if (this.isEnd() && (this === this.#root || this.#root.#filledNegs && this.#parent?.type === '!')) {\n      ret.push({});\n    }\n    return ret;\n  }\n  isStart() {\n    if (this.#root === this) return true;\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false;\n    if (this.#parentIndex === 0) return true;\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent;\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i];\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false;\n      }\n    }\n    return true;\n  }\n  isEnd() {\n    if (this.#root === this) return true;\n    if (this.#parent?.type === '!') return true;\n    if (!this.#parent?.isEnd()) return false;\n    if (!this.type) return this.#parent?.isEnd();\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0;\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1;\n  }\n  copyIn(part) {\n    if (typeof part === 'string') this.push(part);else this.push(part.clone(this));\n  }\n  clone(parent) {\n    const c = new AST(this.type, parent);\n    for (const p of this.#parts) {\n      c.copyIn(p);\n    }\n    return c;\n  }\n  static #parseAST(str, ast, pos, opt) {\n    let escaping = false;\n    let inBrace = false;\n    let braceStart = -1;\n    let braceNeg = false;\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos;\n      let acc = '';\n      while (i < str.length) {\n        const c = str.charAt(i++);\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping;\n          acc += c;\n          continue;\n        }\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true;\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false;\n          }\n          acc += c;\n          continue;\n        } else if (c === '[') {\n          inBrace = true;\n          braceStart = i;\n          braceNeg = false;\n          acc += c;\n          continue;\n        }\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc);\n          acc = '';\n          const ext = new AST(c, ast);\n          i = AST.#parseAST(str, ext, i, opt);\n          ast.push(ext);\n          continue;\n        }\n        acc += c;\n      }\n      ast.push(acc);\n      return i;\n    }\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1;\n    let part = new AST(null, ast);\n    const parts = [];\n    let acc = '';\n    while (i < str.length) {\n      const c = str.charAt(i++);\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping;\n        acc += c;\n        continue;\n      }\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true;\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false;\n        }\n        acc += c;\n        continue;\n      } else if (c === '[') {\n        inBrace = true;\n        braceStart = i;\n        braceNeg = false;\n        acc += c;\n        continue;\n      }\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc);\n        acc = '';\n        const ext = new AST(c, part);\n        part.push(ext);\n        i = AST.#parseAST(str, ext, i, opt);\n        continue;\n      }\n      if (c === '|') {\n        part.push(acc);\n        acc = '';\n        parts.push(part);\n        part = new AST(null, ast);\n        continue;\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true;\n        }\n        part.push(acc);\n        acc = '';\n        ast.push(...parts, part);\n        return i;\n      }\n      acc += c;\n    }\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null;\n    ast.#hasMagic = undefined;\n    ast.#parts = [str.substring(pos - 1)];\n    return i;\n  }\n  static fromGlob(pattern, options = {}) {\n    const ast = new AST(null, undefined, options);\n    AST.#parseAST(pattern, ast, 0, options);\n    return ast;\n  }\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern() {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern();\n    /* c8 ignore stop */\n    const glob = this.toString();\n    const [re, body, hasMagic, uflag] = this.toRegExpSource();\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic = hasMagic || this.#hasMagic || this.#options.nocase && !this.#options.nocaseMagicOnly && glob.toUpperCase() !== glob.toLowerCase();\n    if (!anyMagic) {\n      return body;\n    }\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob\n    });\n  }\n  get options() {\n    return this.#options;\n  }\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(allowDot) {\n    const dot = allowDot ?? !!this.#options.dot;\n    if (this.#root === this) this.#fillNegs();\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd();\n      const src = this.#parts.map(p => {\n        const [re, _, hasMagic, uflag] = typeof p === 'string' ? AST.#parseGlob(p, this.#hasMagic, noEmpty) : p.toRegExpSource(allowDot);\n        this.#hasMagic = this.#hasMagic || hasMagic;\n        this.#uflag = this.#uflag || uflag;\n        return re;\n      }).join('');\n      let start = '';\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);\n          if (!dotTravAllowed) {\n            const aps = addPatternStart;\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n            // dots are allowed, and the pattern starts with [ or .\n            dot && aps.has(src.charAt(0)) ||\n            // the pattern starts with \\., and then [ or .\n            src.startsWith('\\\\.') && aps.has(src.charAt(2)) ||\n            // the pattern starts with \\.\\., and then [ or .\n            src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4));\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';\n          }\n        }\n      }\n      // append the \"end of path portion\" pattern to negation tails\n      let end = '';\n      if (this.isEnd() && this.#root.#filledNegs && this.#parent?.type === '!') {\n        end = '(?:$|\\\\/)';\n      }\n      const final = start + src + end;\n      return [final, (0, unescape_js_1.unescape)(src), this.#hasMagic = !!this.#hasMagic, this.#uflag];\n    }\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n    const repeated = this.type === '*' || this.type === '+';\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:';\n    let body = this.#partsToRegExp(dot);\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString();\n      this.#parts = [s];\n      this.type = null;\n      this.#hasMagic = undefined;\n      return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];\n    }\n    // XXX abstract out this map method\n    let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot ? '' : this.#partsToRegExp(true);\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = '';\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`;\n    }\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = '';\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;\n    } else {\n      const close = this.type === '!' ?\n      // !() must match something,but !(x) can match ''\n      '))' + (this.isStart() && !dot && !allowDot ? startNoDot : '') + star + ')' : this.type === '@' ? ')' : this.type === '?' ? ')?' : this.type === '+' && bodyDotAllowed ? ')' : this.type === '*' && bodyDotAllowed ? `)?` : `)${this.type}`;\n      final = start + body + close;\n    }\n    return [final, (0, unescape_js_1.unescape)(body), this.#hasMagic = !!this.#hasMagic, this.#uflag];\n  }\n  #partsToRegExp(dot) {\n    return this.#parts.map(p => {\n      // extglob ASTs should only contain parent ASTs\n      /* c8 ignore start */\n      if (typeof p === 'string') {\n        throw new Error('string type in extglob ast??');\n      }\n      /* c8 ignore stop */\n      // can ignore hasMagic, because extglobs are already always magic\n      const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);\n      this.#uflag = this.#uflag || uflag;\n      return re;\n    }).filter(p => !(this.isStart() && this.isEnd()) || !!p).join('|');\n  }\n  static #parseGlob(glob, hasMagic, noEmpty = false) {\n    let escaping = false;\n    let re = '';\n    let uflag = false;\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i);\n      if (escaping) {\n        escaping = false;\n        re += (reSpecials.has(c) ? '\\\\' : '') + c;\n        continue;\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\';\n        } else {\n          escaping = true;\n        }\n        continue;\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);\n        if (consumed) {\n          re += src;\n          uflag = uflag || needUflag;\n          i += consumed - 1;\n          hasMagic = hasMagic || magic;\n          continue;\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty;else re += star;\n        hasMagic = true;\n        continue;\n      }\n      if (c === '?') {\n        re += qmark;\n        hasMagic = true;\n        continue;\n      }\n      re += regExpEscape(c);\n    }\n    return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];\n  }\n}\nexports.AST = AST;","map":{"version":3,"names":["brace_expressions_js_1","require","unescape_js_1","types","Set","isExtglobType","c","has","startNoTraversal","startNoDot","addPatternStart","justDots","reSpecials","regExpEscape","s","replace","qmark","star","starNoEmpty","AST","type","root","hasMagic","uflag","parts","parent","parentIndex","negs","filledNegs","options","toString","emptyExt","constructor","push","length","undefined","p","map","String","join","fillNegs","#fillNegs","Error","n","pop","pp","i","part","copyIn","toJSON","ret","slice","isStart","unshift","isEnd","pl","clone","parseAST","#parseAST","str","ast","pos","opt","escaping","inBrace","braceStart","braceNeg","acc","charAt","noext","ext","substring","fromGlob","pattern","toMMPattern","glob","re","body","toRegExpSource","anyMagic","nocase","nocaseMagicOnly","toUpperCase","toLowerCase","flags","Object","assign","RegExp","_src","_glob","allowDot","dot","noEmpty","src","_","parseGlob","start","dotTravAllowed","aps","needNoTrav","startsWith","needNoDot","end","final","unescape","repeated","partsToRegExp","bodyDotAllowed","close","#partsToRegExp","_hasMagic","filter","#parseGlob","needUflag","consumed","magic","parseClass","exports"],"sources":["E:\\programs\\AI programs\\AIMessageApp\\frontend\\node_modules\\pkghub\\node_modules\\minimatch\\src\\ast.ts"],"sourcesContent":["// parse a single path portion\n\nimport { parseClass } from './brace-expressions.js'\nimport { MinimatchOptions, MMRegExp } from './index.js'\nimport { unescape } from './unescape.js'\n\n// classes [] are handled by the parseClass method\n// for positive extglobs, we sub-parse the contents, and combine,\n// with the appropriate regexp close.\n// for negative extglobs, we sub-parse the contents, but then\n// have to include the rest of the pattern, then the parent, etc.,\n// as the thing that cannot be because RegExp negative lookaheads\n// are different from globs.\n//\n// So for example:\n// a@(i|w!(x|y)z|j)b => ^a(i|w((!?(x|y)zb).*)z|j)b$\n//   1   2 3   4 5 6      1   2    3   46      5 6\n//\n// Assembling the extglob requires not just the negated patterns themselves,\n// but also anything following the negative patterns up to the boundary\n// of the current pattern, plus anything following in the parent pattern.\n//\n//\n// So, first, we parse the string into an AST of extglobs, without turning\n// anything into regexps yet.\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y']}, 'z'], ['j']]}, 'b']\n//\n// Then, for all the negative extglobs, we append whatever comes after in\n// each parent as their tail\n//\n// ['a', {@ [['i'], ['w', {!['x', 'y'], 'z', 'b'}, 'z'], ['j']]}, 'b']\n//\n// Lastly, we turn each of these pieces into a regexp, and join\n//\n//                                 v----- .* because there's more following,\n//                                 v    v  otherwise, .+ because it must be\n//                                 v    v  *something* there.\n// ['^a', {@ ['i', 'w(?:(!?(?:x|y).*zb$).*)z', 'j' ]}, 'b$']\n//   copy what follows into here--^^^^^\n// ['^a', '(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)', 'b$']\n// ['^a(?:i|w(?:(?!(?:x|y).*zb$).*)z|j)b$']\n\nexport type ExtglobType = '!' | '?' | '+' | '*' | '@'\nconst types = new Set<ExtglobType>(['!', '?', '+', '*', '@'])\nconst isExtglobType = (c: string): c is ExtglobType =>\n  types.has(c as ExtglobType)\n\n// Patterns that get prepended to bind to the start of either the\n// entire string, or just a single path portion, to prevent dots\n// and/or traversal patterns, when needed.\n// Exts don't need the ^ or / bit, because the root binds that already.\nconst startNoTraversal = '(?!(?:^|/)\\\\.\\\\.?(?:$|/))'\nconst startNoDot = '(?!\\\\.)'\n\n// characters that indicate a start of pattern needs the \"no dots\" bit,\n// because a dot *might* be matched. ( is not in the list, because in\n// the case of a child extglob, it will handle the prevention itself.\nconst addPatternStart = new Set(['[', '.'])\n// cases where traversal is A-OK, no dot prevention needed\nconst justDots = new Set(['..', '.'])\nconst reSpecials = new Set('().*{}+?[]^$\\\\!')\nconst regExpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// any single thing other than /\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n// use + when we need to ensure that *something* matches, because the * is\n// the only thing in the path portion.\nconst starNoEmpty = qmark + '+?'\n\n// remove the \\ chars that we added if we end up doing a nonmagic compare\n// const deslash = (s: string) => s.replace(/\\\\(.)/g, '$1')\n\nexport class AST {\n  type: ExtglobType | null\n  readonly #root: AST\n\n  #hasMagic?: boolean\n  #uflag: boolean = false\n  #parts: (string | AST)[] = []\n  readonly #parent?: AST\n  readonly #parentIndex: number\n  #negs: AST[]\n  #filledNegs: boolean = false\n  #options: MinimatchOptions\n  #toString?: string\n  // set to true if it's an extglob with no children\n  // (which really means one child of '')\n  #emptyExt: boolean = false\n\n  constructor(\n    type: ExtglobType | null,\n    parent?: AST,\n    options: MinimatchOptions = {}\n  ) {\n    this.type = type\n    // extglobs are inherently magical\n    if (type) this.#hasMagic = true\n    this.#parent = parent\n    this.#root = this.#parent ? this.#parent.#root : this\n    this.#options = this.#root === this ? options : this.#root.#options\n    this.#negs = this.#root === this ? [] : this.#root.#negs\n    if (type === '!' && !this.#root.#filledNegs) this.#negs.push(this)\n    this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0\n  }\n\n  get hasMagic(): boolean | undefined {\n    /* c8 ignore start */\n    if (this.#hasMagic !== undefined) return this.#hasMagic\n    /* c8 ignore stop */\n    for (const p of this.#parts) {\n      if (typeof p === 'string') continue\n      if (p.type || p.hasMagic) return (this.#hasMagic = true)\n    }\n    // note: will be undefined until we generate the regexp src and find out\n    return this.#hasMagic\n  }\n\n  // reconstructs the pattern\n  toString(): string {\n    if (this.#toString !== undefined) return this.#toString\n    if (!this.type) {\n      return (this.#toString = this.#parts.map(p => String(p)).join(''))\n    } else {\n      return (this.#toString =\n        this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')')\n    }\n  }\n\n  #fillNegs() {\n    /* c8 ignore start */\n    if (this !== this.#root) throw new Error('should only call on root')\n    if (this.#filledNegs) return this\n    /* c8 ignore stop */\n\n    // call toString() once to fill this out\n    this.toString()\n    this.#filledNegs = true\n    let n: AST | undefined\n    while ((n = this.#negs.pop())) {\n      if (n.type !== '!') continue\n      // walk up the tree, appending everthing that comes AFTER parentIndex\n      let p: AST | undefined = n\n      let pp = p.#parent\n      while (pp) {\n        for (\n          let i = p.#parentIndex + 1;\n          !pp.type && i < pp.#parts.length;\n          i++\n        ) {\n          for (const part of n.#parts) {\n            /* c8 ignore start */\n            if (typeof part === 'string') {\n              throw new Error('string part in extglob AST??')\n            }\n            /* c8 ignore stop */\n            part.copyIn(pp.#parts[i])\n          }\n        }\n        p = pp\n        pp = p.#parent\n      }\n    }\n    return this\n  }\n\n  push(...parts: (string | AST)[]) {\n    for (const p of parts) {\n      if (p === '') continue\n      /* c8 ignore start */\n      if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {\n        throw new Error('invalid part: ' + p)\n      }\n      /* c8 ignore stop */\n      this.#parts.push(p)\n    }\n  }\n\n  toJSON() {\n    const ret: any[] =\n      this.type === null\n        ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))\n        : [this.type, ...this.#parts.map(p => (p as AST).toJSON())]\n    if (this.isStart() && !this.type) ret.unshift([])\n    if (\n      this.isEnd() &&\n      (this === this.#root ||\n        (this.#root.#filledNegs && this.#parent?.type === '!'))\n    ) {\n      ret.push({})\n    }\n    return ret\n  }\n\n  isStart(): boolean {\n    if (this.#root === this) return true\n    // if (this.type) return !!this.#parent?.isStart()\n    if (!this.#parent?.isStart()) return false\n    if (this.#parentIndex === 0) return true\n    // if everything AHEAD of this is a negation, then it's still the \"start\"\n    const p = this.#parent\n    for (let i = 0; i < this.#parentIndex; i++) {\n      const pp = p.#parts[i]\n      if (!(pp instanceof AST && pp.type === '!')) {\n        return false\n      }\n    }\n    return true\n  }\n\n  isEnd(): boolean {\n    if (this.#root === this) return true\n    if (this.#parent?.type === '!') return true\n    if (!this.#parent?.isEnd()) return false\n    if (!this.type) return this.#parent?.isEnd()\n    // if not root, it'll always have a parent\n    /* c8 ignore start */\n    const pl = this.#parent ? this.#parent.#parts.length : 0\n    /* c8 ignore stop */\n    return this.#parentIndex === pl - 1\n  }\n\n  copyIn(part: AST | string) {\n    if (typeof part === 'string') this.push(part)\n    else this.push(part.clone(this))\n  }\n\n  clone(parent: AST) {\n    const c = new AST(this.type, parent)\n    for (const p of this.#parts) {\n      c.copyIn(p)\n    }\n    return c\n  }\n\n  static #parseAST(\n    str: string,\n    ast: AST,\n    pos: number,\n    opt: MinimatchOptions\n  ): number {\n    let escaping = false\n    let inBrace = false\n    let braceStart = -1\n    let braceNeg = false\n    if (ast.type === null) {\n      // outside of a extglob, append until we find a start\n      let i = pos\n      let acc = ''\n      while (i < str.length) {\n        const c = str.charAt(i++)\n        // still accumulate escapes at this point, but we do ignore\n        // starts that are escaped\n        if (escaping || c === '\\\\') {\n          escaping = !escaping\n          acc += c\n          continue\n        }\n\n        if (inBrace) {\n          if (i === braceStart + 1) {\n            if (c === '^' || c === '!') {\n              braceNeg = true\n            }\n          } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n            inBrace = false\n          }\n          acc += c\n          continue\n        } else if (c === '[') {\n          inBrace = true\n          braceStart = i\n          braceNeg = false\n          acc += c\n          continue\n        }\n\n        if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {\n          ast.push(acc)\n          acc = ''\n          const ext = new AST(c, ast)\n          i = AST.#parseAST(str, ext, i, opt)\n          ast.push(ext)\n          continue\n        }\n        acc += c\n      }\n      ast.push(acc)\n      return i\n    }\n\n    // some kind of extglob, pos is at the (\n    // find the next | or )\n    let i = pos + 1\n    let part = new AST(null, ast)\n    const parts: AST[] = []\n    let acc = ''\n    while (i < str.length) {\n      const c = str.charAt(i++)\n      // still accumulate escapes at this point, but we do ignore\n      // starts that are escaped\n      if (escaping || c === '\\\\') {\n        escaping = !escaping\n        acc += c\n        continue\n      }\n\n      if (inBrace) {\n        if (i === braceStart + 1) {\n          if (c === '^' || c === '!') {\n            braceNeg = true\n          }\n        } else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {\n          inBrace = false\n        }\n        acc += c\n        continue\n      } else if (c === '[') {\n        inBrace = true\n        braceStart = i\n        braceNeg = false\n        acc += c\n        continue\n      }\n\n      if (isExtglobType(c) && str.charAt(i) === '(') {\n        part.push(acc)\n        acc = ''\n        const ext = new AST(c, part)\n        part.push(ext)\n        i = AST.#parseAST(str, ext, i, opt)\n        continue\n      }\n      if (c === '|') {\n        part.push(acc)\n        acc = ''\n        parts.push(part)\n        part = new AST(null, ast)\n        continue\n      }\n      if (c === ')') {\n        if (acc === '' && ast.#parts.length === 0) {\n          ast.#emptyExt = true\n        }\n        part.push(acc)\n        acc = ''\n        ast.push(...parts, part)\n        return i\n      }\n      acc += c\n    }\n\n    // unfinished extglob\n    // if we got here, it was a malformed extglob! not an extglob, but\n    // maybe something else in there.\n    ast.type = null\n    ast.#hasMagic = undefined\n    ast.#parts = [str.substring(pos - 1)]\n    return i\n  }\n\n  static fromGlob(pattern: string, options: MinimatchOptions = {}) {\n    const ast = new AST(null, undefined, options)\n    AST.#parseAST(pattern, ast, 0, options)\n    return ast\n  }\n\n  // returns the regular expression if there's magic, or the unescaped\n  // string if not.\n  toMMPattern(): MMRegExp | string {\n    // should only be called on root\n    /* c8 ignore start */\n    if (this !== this.#root) return this.#root.toMMPattern()\n    /* c8 ignore stop */\n    const glob = this.toString()\n    const [re, body, hasMagic, uflag] = this.toRegExpSource()\n    // if we're in nocase mode, and not nocaseMagicOnly, then we do\n    // still need a regular expression if we have to case-insensitively\n    // match capital/lowercase characters.\n    const anyMagic =\n      hasMagic ||\n      this.#hasMagic ||\n      (this.#options.nocase &&\n        !this.#options.nocaseMagicOnly &&\n        glob.toUpperCase() !== glob.toLowerCase())\n    if (!anyMagic) {\n      return body\n    }\n\n    const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '')\n    return Object.assign(new RegExp(`^${re}$`, flags), {\n      _src: re,\n      _glob: glob,\n    })\n  }\n\n  get options() {\n    return this.#options\n  }\n\n  // returns the string match, the regexp source, whether there's magic\n  // in the regexp (so a regular expression is required) and whether or\n  // not the uflag is needed for the regular expression (for posix classes)\n  // TODO: instead of injecting the start/end at this point, just return\n  // the BODY of the regexp, along with the start/end portions suitable\n  // for binding the start/end in either a joined full-path makeRe context\n  // (where we bind to (^|/), or a standalone matchPart context (where\n  // we bind to ^, and not /).  Otherwise slashes get duped!\n  //\n  // In part-matching mode, the start is:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: ^(?!\\.\\.?$)\n  // - if dots allowed or not possible: ^\n  // - if dots possible and not allowed: ^(?!\\.)\n  // end is:\n  // - if not isEnd(): nothing\n  // - else: $\n  //\n  // In full-path matching mode, we put the slash at the START of the\n  // pattern, so start is:\n  // - if first pattern: same as part-matching mode\n  // - if not isStart(): nothing\n  // - if traversal possible, but not allowed: /(?!\\.\\.?(?:$|/))\n  // - if dots allowed or not possible: /\n  // - if dots possible and not allowed: /(?!\\.)\n  // end is:\n  // - if last pattern, same as part-matching mode\n  // - else nothing\n  //\n  // Always put the (?:$|/) on negated tails, though, because that has to be\n  // there to bind the end of the negated pattern portion, and it's easier to\n  // just stick it in now rather than try to inject it later in the middle of\n  // the pattern.\n  //\n  // We can just always return the same end, and leave it up to the caller\n  // to know whether it's going to be used joined or in parts.\n  // And, if the start is adjusted slightly, can do the same there:\n  // - if not isStart: nothing\n  // - if traversal possible, but not allowed: (?:/|^)(?!\\.\\.?$)\n  // - if dots allowed or not possible: (?:/|^)\n  // - if dots possible and not allowed: (?:/|^)(?!\\.)\n  //\n  // But it's better to have a simpler binding without a conditional, for\n  // performance, so probably better to return both start options.\n  //\n  // Then the caller just ignores the end if it's not the first pattern,\n  // and the start always gets applied.\n  //\n  // But that's always going to be $ if it's the ending pattern, or nothing,\n  // so the caller can just attach $ at the end of the pattern when building.\n  //\n  // So the todo is:\n  // - better detect what kind of start is needed\n  // - return both flavors of starting pattern\n  // - attach $ at the end of the pattern when creating the actual RegExp\n  //\n  // Ah, but wait, no, that all only applies to the root when the first pattern\n  // is not an extglob. If the first pattern IS an extglob, then we need all\n  // that dot prevention biz to live in the extglob portions, because eg\n  // +(*|.x*) can match .xy but not .yx.\n  //\n  // So, return the two flavors if it's #root and the first child is not an\n  // AST, otherwise leave it to the child AST to handle it, and there,\n  // use the (?:^|/) style of start binding.\n  //\n  // Even simplified further:\n  // - Since the start for a join is eg /(?!\\.) and the start for a part\n  // is ^(?!\\.), we can just prepend (?!\\.) to the pattern (either root\n  // or start or whatever) and prepend ^ or / at the Regexp construction.\n  toRegExpSource(\n    allowDot?: boolean\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    const dot = allowDot ?? !!this.#options.dot\n    if (this.#root === this) this.#fillNegs()\n    if (!this.type) {\n      const noEmpty = this.isStart() && this.isEnd()\n      const src = this.#parts\n        .map(p => {\n          const [re, _, hasMagic, uflag] =\n            typeof p === 'string'\n              ? AST.#parseGlob(p, this.#hasMagic, noEmpty)\n              : p.toRegExpSource(allowDot)\n          this.#hasMagic = this.#hasMagic || hasMagic\n          this.#uflag = this.#uflag || uflag\n          return re\n        })\n        .join('')\n\n      let start = ''\n      if (this.isStart()) {\n        if (typeof this.#parts[0] === 'string') {\n          // this is the string that will match the start of the pattern,\n          // so we need to protect against dots and such.\n\n          // '.' and '..' cannot match unless the pattern is that exactly,\n          // even if it starts with . or dot:true is set.\n          const dotTravAllowed =\n            this.#parts.length === 1 && justDots.has(this.#parts[0])\n          if (!dotTravAllowed) {\n            const aps = addPatternStart\n            // check if we have a possibility of matching . or ..,\n            // and prevent that.\n            const needNoTrav =\n              // dots are allowed, and the pattern starts with [ or .\n              (dot && aps.has(src.charAt(0))) ||\n              // the pattern starts with \\., and then [ or .\n              (src.startsWith('\\\\.') && aps.has(src.charAt(2))) ||\n              // the pattern starts with \\.\\., and then [ or .\n              (src.startsWith('\\\\.\\\\.') && aps.has(src.charAt(4)))\n            // no need to prevent dots if it can't match a dot, or if a\n            // sub-pattern will be preventing it anyway.\n            const needNoDot = !dot && !allowDot && aps.has(src.charAt(0))\n\n            start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : ''\n          }\n        }\n      }\n\n      // append the \"end of path portion\" pattern to negation tails\n      let end = ''\n      if (\n        this.isEnd() &&\n        this.#root.#filledNegs &&\n        this.#parent?.type === '!'\n      ) {\n        end = '(?:$|\\\\/)'\n      }\n      const final = start + src + end\n      return [\n        final,\n        unescape(src),\n        (this.#hasMagic = !!this.#hasMagic),\n        this.#uflag,\n      ]\n    }\n\n    // We need to calculate the body *twice* if it's a repeat pattern\n    // at the start, once in nodot mode, then again in dot mode, so a\n    // pattern like *(?) can match 'x.y'\n\n    const repeated = this.type === '*' || this.type === '+'\n    // some kind of extglob\n    const start = this.type === '!' ? '(?:(?!(?:' : '(?:'\n    let body = this.#partsToRegExp(dot)\n\n    if (this.isStart() && this.isEnd() && !body && this.type !== '!') {\n      // invalid extglob, has to at least be *something* present, if it's\n      // the entire path portion.\n      const s = this.toString()\n      this.#parts = [s]\n      this.type = null\n      this.#hasMagic = undefined\n      return [s, unescape(this.toString()), false, false]\n    }\n\n    // XXX abstract out this map method\n    let bodyDotAllowed =\n      !repeated || allowDot || dot || !startNoDot\n        ? ''\n        : this.#partsToRegExp(true)\n    if (bodyDotAllowed === body) {\n      bodyDotAllowed = ''\n    }\n    if (bodyDotAllowed) {\n      body = `(?:${body})(?:${bodyDotAllowed})*?`\n    }\n\n    // an empty !() is exactly equivalent to a starNoEmpty\n    let final = ''\n    if (this.type === '!' && this.#emptyExt) {\n      final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty\n    } else {\n      const close =\n        this.type === '!'\n          ? // !() must match something,but !(x) can match ''\n            '))' +\n            (this.isStart() && !dot && !allowDot ? startNoDot : '') +\n            star +\n            ')'\n          : this.type === '@'\n          ? ')'\n          : this.type === '?'\n          ? ')?'\n          : this.type === '+' && bodyDotAllowed\n          ? ')'\n          : this.type === '*' && bodyDotAllowed\n          ? `)?`\n          : `)${this.type}`\n      final = start + body + close\n    }\n    return [\n      final,\n      unescape(body),\n      (this.#hasMagic = !!this.#hasMagic),\n      this.#uflag,\n    ]\n  }\n\n  #partsToRegExp(dot: boolean) {\n    return this.#parts\n      .map(p => {\n        // extglob ASTs should only contain parent ASTs\n        /* c8 ignore start */\n        if (typeof p === 'string') {\n          throw new Error('string type in extglob ast??')\n        }\n        /* c8 ignore stop */\n        // can ignore hasMagic, because extglobs are already always magic\n        const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot)\n        this.#uflag = this.#uflag || uflag\n        return re\n      })\n      .filter(p => !(this.isStart() && this.isEnd()) || !!p)\n      .join('|')\n  }\n\n  static #parseGlob(\n    glob: string,\n    hasMagic: boolean | undefined,\n    noEmpty: boolean = false\n  ): [re: string, body: string, hasMagic: boolean, uflag: boolean] {\n    let escaping = false\n    let re = ''\n    let uflag = false\n    for (let i = 0; i < glob.length; i++) {\n      const c = glob.charAt(i)\n      if (escaping) {\n        escaping = false\n        re += (reSpecials.has(c) ? '\\\\' : '') + c\n        continue\n      }\n      if (c === '\\\\') {\n        if (i === glob.length - 1) {\n          re += '\\\\\\\\'\n        } else {\n          escaping = true\n        }\n        continue\n      }\n      if (c === '[') {\n        const [src, needUflag, consumed, magic] = parseClass(glob, i)\n        if (consumed) {\n          re += src\n          uflag = uflag || needUflag\n          i += consumed - 1\n          hasMagic = hasMagic || magic\n          continue\n        }\n      }\n      if (c === '*') {\n        if (noEmpty && glob === '*') re += starNoEmpty\n        else re += star\n        hasMagic = true\n        continue\n      }\n      if (c === '?') {\n        re += qmark\n        hasMagic = true\n        continue\n      }\n      re += regExpEscape(c)\n    }\n    return [re, unescape(glob), !!hasMagic, uflag]\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}