{"ast":null,"code":"\"use strict\";\n\n// synchronous utility for filtering entries and calculating subwalks\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Processor = exports.SubWalks = exports.MatchRecord = exports.HasWalkedCache = void 0;\nconst minimatch_1 = require(\"minimatch\");\n/**\n * A cache of which patterns have been processed for a given Path\n */\nclass HasWalkedCache {\n  store;\n  constructor(store = new Map()) {\n    this.store = store;\n  }\n  copy() {\n    return new HasWalkedCache(new Map(this.store));\n  }\n  hasWalked(target, pattern) {\n    return this.store.get(target.fullpath())?.has(pattern.globString());\n  }\n  storeWalked(target, pattern) {\n    const fullpath = target.fullpath();\n    const cached = this.store.get(fullpath);\n    if (cached) cached.add(pattern.globString());else this.store.set(fullpath, new Set([pattern.globString()]));\n  }\n}\nexports.HasWalkedCache = HasWalkedCache;\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nclass MatchRecord {\n  store = new Map();\n  add(target, absolute, ifDir) {\n    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0);\n    const current = this.store.get(target);\n    this.store.set(target, current === undefined ? n : n & current);\n  }\n  // match, absolute, ifdir\n  entries() {\n    return [...this.store.entries()].map(([path, n]) => [path, !!(n & 2), !!(n & 1)]);\n  }\n}\nexports.MatchRecord = MatchRecord;\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nclass SubWalks {\n  store = new Map();\n  add(target, pattern) {\n    if (!target.canReaddir()) {\n      return;\n    }\n    const subs = this.store.get(target);\n    if (subs) {\n      if (!subs.find(p => p.globString() === pattern.globString())) {\n        subs.push(pattern);\n      }\n    } else this.store.set(target, [pattern]);\n  }\n  get(target) {\n    const subs = this.store.get(target);\n    /* c8 ignore start */\n    if (!subs) {\n      throw new Error('attempting to walk unknown path');\n    }\n    /* c8 ignore stop */\n    return subs;\n  }\n  entries() {\n    return this.keys().map(k => [k, this.store.get(k)]);\n  }\n  keys() {\n    return [...this.store.keys()].filter(t => t.canReaddir());\n  }\n}\nexports.SubWalks = SubWalks;\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nclass Processor {\n  hasWalkedCache;\n  matches = new MatchRecord();\n  subwalks = new SubWalks();\n  patterns;\n  follow;\n  dot;\n  opts;\n  constructor(opts, hasWalkedCache) {\n    this.opts = opts;\n    this.follow = !!opts.follow;\n    this.dot = !!opts.dot;\n    this.hasWalkedCache = hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache();\n  }\n  processPatterns(target, patterns) {\n    this.patterns = patterns;\n    const processingSet = patterns.map(p => [target, p]);\n    // map of paths to the magic-starting subwalks they need to walk\n    // first item in patterns is the filter\n    for (let [t, pattern] of processingSet) {\n      this.hasWalkedCache.storeWalked(t, pattern);\n      const root = pattern.root();\n      const absolute = pattern.isAbsolute() && this.opts.absolute !== false;\n      // start absolute patterns at root\n      if (root) {\n        t = t.resolve(root === '/' && this.opts.root !== undefined ? this.opts.root : root);\n        const rest = pattern.rest();\n        if (!rest) {\n          this.matches.add(t, true, false);\n          continue;\n        } else {\n          pattern = rest;\n        }\n      }\n      if (t.isENOENT()) continue;\n      let p;\n      let rest;\n      let changed = false;\n      while (typeof (p = pattern.pattern()) === 'string' && (rest = pattern.rest())) {\n        const c = t.resolve(p);\n        t = c;\n        pattern = rest;\n        changed = true;\n      }\n      p = pattern.pattern();\n      rest = pattern.rest();\n      if (changed) {\n        if (this.hasWalkedCache.hasWalked(t, pattern)) continue;\n        this.hasWalkedCache.storeWalked(t, pattern);\n      }\n      // now we have either a final string for a known entry,\n      // more strings for an unknown entry,\n      // or a pattern starting with magic, mounted on t.\n      if (typeof p === 'string') {\n        // must not be final entry, otherwise we would have\n        // concatenated it earlier.\n        const ifDir = p === '..' || p === '' || p === '.';\n        this.matches.add(t.resolve(p), absolute, ifDir);\n        continue;\n      } else if (p === minimatch_1.GLOBSTAR) {\n        // if no rest, match and subwalk pattern\n        // if rest, process rest and subwalk pattern\n        // if it's a symlink, but we didn't get here by way of a\n        // globstar match (meaning it's the first time THIS globstar\n        // has traversed a symlink), then we follow it. Otherwise, stop.\n        if (!t.isSymbolicLink() || this.follow || pattern.checkFollowGlobstar()) {\n          this.subwalks.add(t, pattern);\n        }\n        const rp = rest?.pattern();\n        const rrest = rest?.rest();\n        if (!rest || (rp === '' || rp === '.') && !rrest) {\n          // only HAS to be a dir if it ends in **/ or **/.\n          // but ending in ** will match files as well.\n          this.matches.add(t, absolute, rp === '' || rp === '.');\n        } else {\n          if (rp === '..') {\n            // this would mean you're matching **/.. at the fs root,\n            // and no thanks, I'm not gonna test that specific case.\n            /* c8 ignore start */\n            const tp = t.parent || t;\n            /* c8 ignore stop */\n            if (!rrest) this.matches.add(tp, absolute, true);else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n              this.subwalks.add(tp, rrest);\n            }\n          }\n        }\n      } else if (p instanceof RegExp) {\n        this.subwalks.add(t, pattern);\n      }\n    }\n    return this;\n  }\n  subwalkTargets() {\n    return this.subwalks.keys();\n  }\n  child() {\n    return new Processor(this.opts, this.hasWalkedCache);\n  }\n  // return a new Processor containing the subwalks for each\n  // child entry, and a set of matches, and\n  // a hasWalkedCache that's a copy of this one\n  // then we're going to call\n  filterEntries(parent, entries) {\n    const patterns = this.subwalks.get(parent);\n    // put matches and entry walks into the results processor\n    const results = this.child();\n    for (const e of entries) {\n      for (const pattern of patterns) {\n        const absolute = pattern.isAbsolute();\n        const p = pattern.pattern();\n        const rest = pattern.rest();\n        if (p === minimatch_1.GLOBSTAR) {\n          results.testGlobstar(e, pattern, rest, absolute);\n        } else if (p instanceof RegExp) {\n          results.testRegExp(e, p, rest, absolute);\n        } else {\n          results.testString(e, p, rest, absolute);\n        }\n      }\n    }\n    return results;\n  }\n  testGlobstar(e, pattern, rest, absolute) {\n    if (this.dot || !e.name.startsWith('.')) {\n      if (!pattern.hasMore()) {\n        this.matches.add(e, absolute, false);\n      }\n      if (e.canReaddir()) {\n        // if we're in follow mode or it's not a symlink, just keep\n        // testing the same pattern. If there's more after the globstar,\n        // then this symlink consumes the globstar. If not, then we can\n        // follow at most ONE symlink along the way, so we mark it, which\n        // also checks to ensure that it wasn't already marked.\n        if (this.follow || !e.isSymbolicLink()) {\n          this.subwalks.add(e, pattern);\n        } else if (e.isSymbolicLink()) {\n          if (rest && pattern.checkFollowGlobstar()) {\n            this.subwalks.add(e, rest);\n          } else if (pattern.markFollowGlobstar()) {\n            this.subwalks.add(e, pattern);\n          }\n        }\n      }\n    }\n    // if the NEXT thing matches this entry, then also add\n    // the rest.\n    if (rest) {\n      const rp = rest.pattern();\n      if (typeof rp === 'string' &&\n      // dots and empty were handled already\n      rp !== '..' && rp !== '' && rp !== '.') {\n        this.testString(e, rp, rest.rest(), absolute);\n      } else if (rp === '..') {\n        /* c8 ignore start */\n        const ep = e.parent || e;\n        /* c8 ignore stop */\n        this.subwalks.add(ep, rest);\n      } else if (rp instanceof RegExp) {\n        this.testRegExp(e, rp, rest.rest(), absolute);\n      }\n    }\n  }\n  testRegExp(e, p, rest, absolute) {\n    if (!p.test(e.name)) return;\n    if (!rest) {\n      this.matches.add(e, absolute, false);\n    } else {\n      this.subwalks.add(e, rest);\n    }\n  }\n  testString(e, p, rest, absolute) {\n    // should never happen?\n    if (!e.isNamed(p)) return;\n    if (!rest) {\n      this.matches.add(e, absolute, false);\n    } else {\n      this.subwalks.add(e, rest);\n    }\n  }\n}\nexports.Processor = Processor;","map":{"version":3,"names":["minimatch_1","require","HasWalkedCache","store","constructor","Map","copy","hasWalked","target","pattern","get","fullpath","has","globString","storeWalked","cached","add","set","Set","exports","MatchRecord","absolute","ifDir","n","current","undefined","entries","map","path","SubWalks","canReaddir","subs","find","p","push","Error","keys","k","filter","t","Processor","hasWalkedCache","matches","subwalks","patterns","follow","dot","opts","processPatterns","processingSet","root","isAbsolute","resolve","rest","isENOENT","changed","c","GLOBSTAR","isSymbolicLink","checkFollowGlobstar","rp","rrest","tp","parent","RegExp","subwalkTargets","child","filterEntries","results","e","testGlobstar","testRegExp","testString","name","startsWith","hasMore","markFollowGlobstar","ep","test","isNamed"],"sources":["E:\\programs\\AI programs\\AIMessageApp\\frontend\\node_modules\\pkghub\\node_modules\\glob\\src\\processor.ts"],"sourcesContent":["// synchronous utility for filtering entries and calculating subwalks\n\nimport { GLOBSTAR, MMRegExp } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { MMPattern, Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\n/**\n * A cache of which patterns have been processed for a given Path\n */\nexport class HasWalkedCache {\n  store: Map<string, Set<string>>\n  constructor(store: Map<string, Set<string>> = new Map()) {\n    this.store = store\n  }\n  copy() {\n    return new HasWalkedCache(new Map(this.store))\n  }\n  hasWalked(target: Path, pattern: Pattern) {\n    return this.store.get(target.fullpath())?.has(pattern.globString())\n  }\n  storeWalked(target: Path, pattern: Pattern) {\n    const fullpath = target.fullpath()\n    const cached = this.store.get(fullpath)\n    if (cached) cached.add(pattern.globString())\n    else this.store.set(fullpath, new Set([pattern.globString()]))\n  }\n}\n\n/**\n * A record of which paths have been matched in a given walk step,\n * and whether they only are considered a match if they are a directory,\n * and whether their absolute or relative path should be returned.\n */\nexport class MatchRecord {\n  store: Map<Path, number> = new Map()\n  add(target: Path, absolute: boolean, ifDir: boolean) {\n    const n = (absolute ? 2 : 0) | (ifDir ? 1 : 0)\n    const current = this.store.get(target)\n    this.store.set(target, current === undefined ? n : n & current)\n  }\n  // match, absolute, ifdir\n  entries(): [Path, boolean, boolean][] {\n    return [...this.store.entries()].map(([path, n]) => [\n      path,\n      !!(n & 2),\n      !!(n & 1),\n    ])\n  }\n}\n\n/**\n * A collection of patterns that must be processed in a subsequent step\n * for a given path.\n */\nexport class SubWalks {\n  store: Map<Path, Pattern[]> = new Map()\n  add(target: Path, pattern: Pattern) {\n    if (!target.canReaddir()) {\n      return\n    }\n    const subs = this.store.get(target)\n    if (subs) {\n      if (!subs.find(p => p.globString() === pattern.globString())) {\n        subs.push(pattern)\n      }\n    } else this.store.set(target, [pattern])\n  }\n  get(target: Path): Pattern[] {\n    const subs = this.store.get(target)\n    /* c8 ignore start */\n    if (!subs) {\n      throw new Error('attempting to walk unknown path')\n    }\n    /* c8 ignore stop */\n    return subs\n  }\n  entries(): [Path, Pattern[]][] {\n    return this.keys().map(k => [k, this.store.get(k) as Pattern[]])\n  }\n  keys(): Path[] {\n    return [...this.store.keys()].filter(t => t.canReaddir())\n  }\n}\n\n/**\n * The class that processes patterns for a given path.\n *\n * Handles child entry filtering, and determining whether a path's\n * directory contents must be read.\n */\nexport class Processor {\n  hasWalkedCache: HasWalkedCache\n  matches = new MatchRecord()\n  subwalks = new SubWalks()\n  patterns?: Pattern[]\n  follow: boolean\n  dot: boolean\n  opts: GlobWalkerOpts\n\n  constructor(opts: GlobWalkerOpts, hasWalkedCache?: HasWalkedCache) {\n    this.opts = opts\n    this.follow = !!opts.follow\n    this.dot = !!opts.dot\n    this.hasWalkedCache =\n      hasWalkedCache ? hasWalkedCache.copy() : new HasWalkedCache()\n  }\n\n  processPatterns(target: Path, patterns: Pattern[]) {\n    this.patterns = patterns\n    const processingSet: [Path, Pattern][] = patterns.map(p => [target, p])\n\n    // map of paths to the magic-starting subwalks they need to walk\n    // first item in patterns is the filter\n\n    for (let [t, pattern] of processingSet) {\n      this.hasWalkedCache.storeWalked(t, pattern)\n\n      const root = pattern.root()\n      const absolute = pattern.isAbsolute() && this.opts.absolute !== false\n\n      // start absolute patterns at root\n      if (root) {\n        t = t.resolve(\n          root === '/' && this.opts.root !== undefined ?\n            this.opts.root\n          : root,\n        )\n        const rest = pattern.rest()\n        if (!rest) {\n          this.matches.add(t, true, false)\n          continue\n        } else {\n          pattern = rest\n        }\n      }\n\n      if (t.isENOENT()) continue\n\n      let p: MMPattern\n      let rest: Pattern | null\n      let changed = false\n      while (\n        typeof (p = pattern.pattern()) === 'string' &&\n        (rest = pattern.rest())\n      ) {\n        const c = t.resolve(p)\n        t = c\n        pattern = rest\n        changed = true\n      }\n      p = pattern.pattern()\n      rest = pattern.rest()\n      if (changed) {\n        if (this.hasWalkedCache.hasWalked(t, pattern)) continue\n        this.hasWalkedCache.storeWalked(t, pattern)\n      }\n\n      // now we have either a final string for a known entry,\n      // more strings for an unknown entry,\n      // or a pattern starting with magic, mounted on t.\n      if (typeof p === 'string') {\n        // must not be final entry, otherwise we would have\n        // concatenated it earlier.\n        const ifDir = p === '..' || p === '' || p === '.'\n        this.matches.add(t.resolve(p), absolute, ifDir)\n        continue\n      } else if (p === GLOBSTAR) {\n        // if no rest, match and subwalk pattern\n        // if rest, process rest and subwalk pattern\n        // if it's a symlink, but we didn't get here by way of a\n        // globstar match (meaning it's the first time THIS globstar\n        // has traversed a symlink), then we follow it. Otherwise, stop.\n        if (\n          !t.isSymbolicLink() ||\n          this.follow ||\n          pattern.checkFollowGlobstar()\n        ) {\n          this.subwalks.add(t, pattern)\n        }\n        const rp = rest?.pattern()\n        const rrest = rest?.rest()\n        if (!rest || ((rp === '' || rp === '.') && !rrest)) {\n          // only HAS to be a dir if it ends in **/ or **/.\n          // but ending in ** will match files as well.\n          this.matches.add(t, absolute, rp === '' || rp === '.')\n        } else {\n          if (rp === '..') {\n            // this would mean you're matching **/.. at the fs root,\n            // and no thanks, I'm not gonna test that specific case.\n            /* c8 ignore start */\n            const tp = t.parent || t\n            /* c8 ignore stop */\n            if (!rrest) this.matches.add(tp, absolute, true)\n            else if (!this.hasWalkedCache.hasWalked(tp, rrest)) {\n              this.subwalks.add(tp, rrest)\n            }\n          }\n        }\n      } else if (p instanceof RegExp) {\n        this.subwalks.add(t, pattern)\n      }\n    }\n\n    return this\n  }\n\n  subwalkTargets(): Path[] {\n    return this.subwalks.keys()\n  }\n\n  child() {\n    return new Processor(this.opts, this.hasWalkedCache)\n  }\n\n  // return a new Processor containing the subwalks for each\n  // child entry, and a set of matches, and\n  // a hasWalkedCache that's a copy of this one\n  // then we're going to call\n  filterEntries(parent: Path, entries: Path[]): Processor {\n    const patterns = this.subwalks.get(parent)\n    // put matches and entry walks into the results processor\n    const results = this.child()\n    for (const e of entries) {\n      for (const pattern of patterns) {\n        const absolute = pattern.isAbsolute()\n        const p = pattern.pattern()\n        const rest = pattern.rest()\n        if (p === GLOBSTAR) {\n          results.testGlobstar(e, pattern, rest, absolute)\n        } else if (p instanceof RegExp) {\n          results.testRegExp(e, p, rest, absolute)\n        } else {\n          results.testString(e, p, rest, absolute)\n        }\n      }\n    }\n    return results\n  }\n\n  testGlobstar(\n    e: Path,\n    pattern: Pattern,\n    rest: Pattern | null,\n    absolute: boolean,\n  ) {\n    if (this.dot || !e.name.startsWith('.')) {\n      if (!pattern.hasMore()) {\n        this.matches.add(e, absolute, false)\n      }\n      if (e.canReaddir()) {\n        // if we're in follow mode or it's not a symlink, just keep\n        // testing the same pattern. If there's more after the globstar,\n        // then this symlink consumes the globstar. If not, then we can\n        // follow at most ONE symlink along the way, so we mark it, which\n        // also checks to ensure that it wasn't already marked.\n        if (this.follow || !e.isSymbolicLink()) {\n          this.subwalks.add(e, pattern)\n        } else if (e.isSymbolicLink()) {\n          if (rest && pattern.checkFollowGlobstar()) {\n            this.subwalks.add(e, rest)\n          } else if (pattern.markFollowGlobstar()) {\n            this.subwalks.add(e, pattern)\n          }\n        }\n      }\n    }\n    // if the NEXT thing matches this entry, then also add\n    // the rest.\n    if (rest) {\n      const rp = rest.pattern()\n      if (\n        typeof rp === 'string' &&\n        // dots and empty were handled already\n        rp !== '..' &&\n        rp !== '' &&\n        rp !== '.'\n      ) {\n        this.testString(e, rp, rest.rest(), absolute)\n      } else if (rp === '..') {\n        /* c8 ignore start */\n        const ep = e.parent || e\n        /* c8 ignore stop */\n        this.subwalks.add(ep, rest)\n      } else if (rp instanceof RegExp) {\n        this.testRegExp(e, rp, rest.rest(), absolute)\n      }\n    }\n  }\n\n  testRegExp(\n    e: Path,\n    p: MMRegExp,\n    rest: Pattern | null,\n    absolute: boolean,\n  ) {\n    if (!p.test(e.name)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n\n  testString(e: Path, p: string, rest: Pattern | null, absolute: boolean) {\n    // should never happen?\n    if (!e.isNamed(p)) return\n    if (!rest) {\n      this.matches.add(e, absolute, false)\n    } else {\n      this.subwalks.add(e, rest)\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}