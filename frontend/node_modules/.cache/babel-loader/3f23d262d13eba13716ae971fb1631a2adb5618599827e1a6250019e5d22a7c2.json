{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null\n};\nconst node_events_1 = require(\"node:events\");\nconst node_stream_1 = __importDefault(require(\"node:stream\"));\nconst node_string_decoder_1 = require(\"node:string_decoder\");\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nconst isStream = s => !!s && typeof s === 'object' && (s instanceof Minipass || s instanceof node_stream_1.default || (0, exports.isReadable)(s) || (0, exports.isWritable)(s));\nexports.isStream = isStream;\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nconst isReadable = s => !!s && typeof s === 'object' && s instanceof node_events_1.EventEmitter && typeof s.pipe === 'function' &&\n// node core Writable streams have a pipe() method, but it throws\ns.pipe !== node_stream_1.default.Writable.prototype.pipe;\nexports.isReadable = isReadable;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nconst isWritable = s => !!s && typeof s === 'object' && s instanceof node_events_1.EventEmitter && typeof s.write === 'function' && typeof s.end === 'function';\nexports.isWritable = isWritable;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst DATALISTENERS = Symbol('dataListeners');\nconst DISCARDED = Symbol('discarded');\nconst defer = fn => Promise.resolve().then(fn);\nconst nodefer = fn => fn();\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBufferLike = b => b instanceof ArrayBuffer || !!b && typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe {\n  src;\n  dest;\n  opts;\n  ondrain;\n  constructor(src, dest, opts) {\n    this.src = src;\n    this.dest = dest;\n    this.opts = opts;\n    this.ondrain = () => src[RESUME]();\n    this.dest.on('drain', this.ondrain);\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain);\n  }\n  // only here for the prototype\n  /* c8 ignore start */\n  proxyErrors(_er) {}\n  /* c8 ignore stop */\n  end() {\n    this.unpipe();\n    if (this.opts.end) this.dest.end();\n  }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors);\n    super.unpipe();\n  }\n  constructor(src, dest, opts) {\n    super(src, dest, opts);\n    this.proxyErrors = er => dest.emit('error', er);\n    src.on('error', this.proxyErrors);\n  }\n}\nconst isObjectModeOptions = o => !!o.objectMode;\nconst isEncodingOptions = o => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nclass Minipass extends node_events_1.EventEmitter {\n  [FLOWING] = false;\n  [PAUSED] = false;\n  [PIPES] = [];\n  [BUFFER] = [];\n  [OBJECTMODE];\n  [ENCODING];\n  [ASYNC];\n  [DECODER];\n  [EOF] = false;\n  [EMITTED_END] = false;\n  [EMITTING_END] = false;\n  [CLOSED] = false;\n  [EMITTED_ERROR] = null;\n  [BUFFERLENGTH] = 0;\n  [DESTROYED] = false;\n  [SIGNAL];\n  [ABORTED] = false;\n  [DATALISTENERS] = 0;\n  [DISCARDED] = false;\n  /**\n   * true if the stream can be written\n   */\n  writable = true;\n  /**\n   * true if the stream can be read\n   */\n  readable = true;\n  /**\n   * If `RType` is Buffer, then options do not need to be provided.\n   * Otherwise, an options object must be provided to specify either\n   * {@link Minipass.SharedOptions.objectMode} or\n   * {@link Minipass.SharedOptions.encoding}, as appropriate.\n   */\n  constructor(...args) {\n    const options = args[0] || {};\n    super();\n    if (options.objectMode && typeof options.encoding === 'string') {\n      throw new TypeError('Encoding and objectMode may not be used together');\n    }\n    if (isObjectModeOptions(options)) {\n      this[OBJECTMODE] = true;\n      this[ENCODING] = null;\n    } else if (isEncodingOptions(options)) {\n      this[ENCODING] = options.encoding;\n      this[OBJECTMODE] = false;\n    } else {\n      this[OBJECTMODE] = false;\n      this[ENCODING] = null;\n    }\n    this[ASYNC] = !!options.async;\n    this[DECODER] = this[ENCODING] ? new node_string_decoder_1.StringDecoder(this[ENCODING]) : null;\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', {\n        get: () => this[BUFFER]\n      });\n    }\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', {\n        get: () => this[PIPES]\n      });\n    }\n    const {\n      signal\n    } = options;\n    if (signal) {\n      this[SIGNAL] = signal;\n      if (signal.aborted) {\n        this[ABORT]();\n      } else {\n        signal.addEventListener('abort', () => this[ABORT]());\n      }\n    }\n  }\n  /**\n   * The amount of data stored in the buffer waiting to be read.\n   *\n   * For Buffer strings, this will be the total byte length.\n   * For string encoding streams, this will be the string character length,\n   * according to JavaScript's `string.length` logic.\n   * For objectMode streams, this is a count of the items waiting to be\n   * emitted.\n   */\n  get bufferLength() {\n    return this[BUFFERLENGTH];\n  }\n  /**\n   * The `BufferEncoding` currently in use, or `null`\n   */\n  get encoding() {\n    return this[ENCODING];\n  }\n  /**\n   * @deprecated - This is a read only property\n   */\n  set encoding(_enc) {\n    throw new Error('Encoding must be set at instantiation time');\n  }\n  /**\n   * @deprecated - Encoding may only be set at instantiation time\n   */\n  setEncoding(_enc) {\n    throw new Error('Encoding must be set at instantiation time');\n  }\n  /**\n   * True if this is an objectMode stream\n   */\n  get objectMode() {\n    return this[OBJECTMODE];\n  }\n  /**\n   * @deprecated - This is a read-only property\n   */\n  set objectMode(_om) {\n    throw new Error('objectMode must be set at instantiation time');\n  }\n  /**\n   * true if this is an async stream\n   */\n  get ['async']() {\n    return this[ASYNC];\n  }\n  /**\n   * Set to true to make this stream async.\n   *\n   * Once set, it cannot be unset, as this would potentially cause incorrect\n   * behavior.  Ie, a sync stream can be made async, but an async stream\n   * cannot be safely made sync.\n   */\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a;\n  }\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true;\n    this.emit('abort', this[SIGNAL]?.reason);\n    this.destroy(this[SIGNAL]?.reason);\n  }\n  /**\n   * True if the stream has been aborted.\n   */\n  get aborted() {\n    return this[ABORTED];\n  }\n  /**\n   * No-op setter. Stream aborted status is set via the AbortSignal provided\n   * in the constructor options.\n   */\n  set aborted(_) {}\n  write(chunk, encoding, cb) {\n    if (this[ABORTED]) return false;\n    if (this[EOF]) throw new Error('write after end');\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n        code: 'ERR_STREAM_DESTROYED'\n      }));\n      return true;\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding;\n      encoding = 'utf8';\n    }\n    if (!encoding) encoding = 'utf8';\n    const fn = this[ASYNC] ? defer : nodefer;\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything is only allowed if in object mode, so throw\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n      } else if (isArrayBufferLike(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(chunk);\n      } else if (typeof chunk !== 'string') {\n        throw new Error('Non-contiguous data written to non-objectMode stream');\n      }\n    }\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      // maybe impossible?\n      /* c8 ignore start */\n      if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n      /* c8 ignore stop */\n      if (this[FLOWING]) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this[FLOWING];\n    }\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this[FLOWING];\n    }\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' &&\n    // unless it is a string already ready for us to use\n    !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = Buffer.from(chunk, encoding);\n    }\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = this[DECODER].write(chunk);\n    }\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n    if (this[FLOWING]) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n    if (cb) fn(cb);\n    return this[FLOWING];\n  }\n  /**\n   * Low-level explicit read method.\n   *\n   * In objectMode, the argument is ignored, and one item is returned if\n   * available.\n   *\n   * `n` is the number of bytes (or in the case of encoding streams,\n   * characters) to consume. If `n` is not provided, then the entire buffer\n   * is returned, or `null` is returned if no data is available.\n   *\n   * If `n` is greater that the amount of data in the internal buffer,\n   * then `null` is returned.\n   */\n  read(n) {\n    if (this[DESTROYED]) return null;\n    this[DISCARDED] = false;\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n && n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]();\n      return null;\n    }\n    if (this[OBJECTMODE]) n = null;\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      // not object mode, so if we have an encoding, then RType is string\n      // otherwise, must be Buffer\n      this[BUFFER] = [this[ENCODING] ? this[BUFFER].join('') : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];\n    }\n    const ret = this[READ](n || null, this[BUFFER][0]);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n  [READ](n, chunk) {\n    if (this[OBJECTMODE]) this[BUFFERSHIFT]();else {\n      const c = chunk;\n      if (n === c.length || n === null) this[BUFFERSHIFT]();else if (typeof c === 'string') {\n        this[BUFFER][0] = c.slice(n);\n        chunk = c.slice(0, n);\n        this[BUFFERLENGTH] -= n;\n      } else {\n        this[BUFFER][0] = c.subarray(n);\n        chunk = c.subarray(0, n);\n        this[BUFFERLENGTH] -= n;\n      }\n    }\n    this.emit('data', chunk);\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain');\n    return chunk;\n  }\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') {\n      cb = chunk;\n      chunk = undefined;\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding;\n      encoding = 'utf8';\n    }\n    if (chunk !== undefined) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    this[EOF] = true;\n    this.writable = false;\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]();\n    return this;\n  }\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return;\n    if (!this[DATALISTENERS] && !this[PIPES].length) {\n      this[DISCARDED] = true;\n    }\n    this[PAUSED] = false;\n    this[FLOWING] = true;\n    this.emit('resume');\n    if (this[BUFFER].length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n  }\n  /**\n   * Resume the stream if it is currently in a paused state\n   *\n   * If called when there are no pipe destinations or `data` event listeners,\n   * this will place the stream in a \"discarded\" state, where all data will\n   * be thrown away. The discarded state is removed if a pipe destination or\n   * data handler is added, if pause() is called, or if any synchronous or\n   * asynchronous iteration is started.\n   */\n  resume() {\n    return this[RESUME]();\n  }\n  /**\n   * Pause the stream\n   */\n  pause() {\n    this[FLOWING] = false;\n    this[PAUSED] = true;\n    this[DISCARDED] = false;\n  }\n  /**\n   * true if the stream has been forcibly destroyed\n   */\n  get destroyed() {\n    return this[DESTROYED];\n  }\n  /**\n   * true if the stream is currently in a flowing state, meaning that\n   * any writes will be immediately emitted.\n   */\n  get flowing() {\n    return this[FLOWING];\n  }\n  /**\n   * true if the stream is currently in a paused state\n   */\n  get paused() {\n    return this[PAUSED];\n  }\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n    this[BUFFER].push(chunk);\n  }\n  [BUFFERSHIFT]() {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this[BUFFER][0].length;\n    return this[BUFFER].shift();\n  }\n  [FLUSH](noDrain = false) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length);\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain');\n  }\n  [FLUSHCHUNK](chunk) {\n    this.emit('data', chunk);\n    return this[FLOWING];\n  }\n  /**\n   * Pipe all data emitted by this stream into the destination provided.\n   *\n   * Triggers the flow of data.\n   */\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return dest;\n    this[DISCARDED] = false;\n    const ended = this[EMITTED_END];\n    opts = opts || {};\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false;else opts.end = opts.end !== false;\n    opts.proxyErrors = !!opts.proxyErrors;\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end();\n    } else {\n      // \"as\" here just ignores the WType, which pipes don't care about,\n      // since they're only consuming from us, and writing to the dest\n      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));\n      if (this[ASYNC]) defer(() => this[RESUME]());else this[RESUME]();\n    }\n    return dest;\n  }\n  /**\n   * Fully unhook a piped destination stream.\n   *\n   * If the destination stream was the only consumer of this stream (ie,\n   * there are no other piped destinations or `'data'` event listeners)\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest);\n    if (p) {\n      if (this[PIPES].length === 1) {\n        if (this[FLOWING] && this[DATALISTENERS] === 0) {\n          this[FLOWING] = false;\n        }\n        this[PIPES] = [];\n      } else this[PIPES].splice(this[PIPES].indexOf(p), 1);\n      p.unpipe();\n    }\n  }\n  /**\n   * Alias for {@link Minipass#on}\n   */\n  addListener(ev, handler) {\n    return this.on(ev, handler);\n  }\n  /**\n   * Mostly identical to `EventEmitter.on`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * - Adding a 'data' event handler will trigger the flow of data\n   *\n   * - Adding a 'readable' event handler when there is data waiting to be read\n   *   will cause 'readable' to be emitted immediately.\n   *\n   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n   *   already passed will cause the event to be emitted immediately and all\n   *   handlers removed.\n   *\n   * - Adding an 'error' event handler after an error has been emitted will\n   *   cause the event to be re-emitted immediately with the error previously\n   *   raised.\n   */\n  on(ev, handler) {\n    const ret = super.on(ev, handler);\n    if (ev === 'data') {\n      this[DISCARDED] = false;\n      this[DATALISTENERS]++;\n      if (!this[PIPES].length && !this[FLOWING]) {\n        this[RESUME]();\n      }\n    } else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n      super.emit('readable');\n    } else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev);\n      this.removeAllListeners(ev);\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      const h = handler;\n      if (this[ASYNC]) defer(() => h.call(this, this[EMITTED_ERROR]));else h.call(this, this[EMITTED_ERROR]);\n    }\n    return ret;\n  }\n  /**\n   * Alias for {@link Minipass#off}\n   */\n  removeListener(ev, handler) {\n    return this.off(ev, handler);\n  }\n  /**\n   * Mostly identical to `EventEmitter.off`\n   *\n   * If a 'data' event handler is removed, and it was the last consumer\n   * (ie, there are no pipe destinations or other 'data' event listeners),\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  off(ev, handler) {\n    const ret = super.off(ev, handler);\n    // if we previously had listeners, and now we don't, and we don't\n    // have any pipes, then stop the flow, unless it's been explicitly\n    // put in a discarded flowing state via stream.resume().\n    if (ev === 'data') {\n      this[DATALISTENERS] = this.listeners('data').length;\n      if (this[DATALISTENERS] === 0 && !this[DISCARDED] && !this[PIPES].length) {\n        this[FLOWING] = false;\n      }\n    }\n    return ret;\n  }\n  /**\n   * Mostly identical to `EventEmitter.removeAllListeners`\n   *\n   * If all 'data' event handlers are removed, and they were the last consumer\n   * (ie, there are no pipe destinations), then the flow of data will stop\n   * until there is another consumer or {@link Minipass#resume} is explicitly\n   * called.\n   */\n  removeAllListeners(ev) {\n    const ret = super.removeAllListeners(ev);\n    if (ev === 'data' || ev === undefined) {\n      this[DATALISTENERS] = 0;\n      if (!this[DISCARDED] && !this[PIPES].length) {\n        this[FLOWING] = false;\n      }\n    }\n    return ret;\n  }\n  /**\n   * true if the 'end' event has been emitted\n   */\n  get emittedEnd() {\n    return this[EMITTED_END];\n  }\n  [MAYBE_EMIT_END]() {\n    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {\n      this[EMITTING_END] = true;\n      this.emit('end');\n      this.emit('prefinish');\n      this.emit('finish');\n      if (this[CLOSED]) this.emit('close');\n      this[EMITTING_END] = false;\n    }\n  }\n  /**\n   * Mostly identical to `EventEmitter.emit`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * If the stream has been destroyed, and the event is something other\n   * than 'close' or 'error', then `false` is returned and no handlers\n   * are called.\n   *\n   * If the event is 'end', and has already been emitted, then the event\n   * is ignored. If the stream is in a paused or non-flowing state, then\n   * the event will be deferred until data flow resumes. If the stream is\n   * async, then handlers will be called on the next tick rather than\n   * immediately.\n   *\n   * If the event is 'close', and 'end' has not yet been emitted, then\n   * the event will be deferred until after 'end' is emitted.\n   *\n   * If the event is 'error', and an AbortSignal was provided for the stream,\n   * and there are no listeners, then the event is ignored, matching the\n   * behavior of node core streams in the presense of an AbortSignal.\n   *\n   * If the event is 'finish' or 'prefinish', then all listeners will be\n   * removed after emitting the event, to prevent double-firing.\n   */\n  emit(ev, ...args) {\n    const data = args[0];\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) {\n      return false;\n    } else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data ? false : this[ASYNC] ? (defer(() => this[EMITDATA](data)), true) : this[EMITDATA](data);\n    } else if (ev === 'end') {\n      return this[EMITEND]();\n    } else if (ev === 'close') {\n      this[CLOSED] = true;\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return false;\n      const ret = super.emit('close');\n      this.removeAllListeners('close');\n      return ret;\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data;\n      super.emit(ERROR, data);\n      const ret = !this[SIGNAL] || this.listeners('error').length ? super.emit('error', data) : false;\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume');\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev);\n      this.removeAllListeners(ev);\n      return ret;\n    }\n    // Some other unknown event\n    const ret = super.emit(ev, ...args);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause();\n    }\n    const ret = this[DISCARDED] ? false : super.emit('data', data);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n  [EMITEND]() {\n    if (this[EMITTED_END]) return false;\n    this[EMITTED_END] = true;\n    this.readable = false;\n    return this[ASYNC] ? (defer(() => this[EMITEND2]()), true) : this[EMITEND2]();\n  }\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end();\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data);\n        }\n        if (!this[DISCARDED]) super.emit('data', data);\n      }\n    }\n    for (const p of this[PIPES]) {\n      p.end();\n    }\n    const ret = super.emit('end');\n    this.removeAllListeners('end');\n    return ret;\n  }\n  /**\n   * Return a Promise that resolves to an array of all emitted data once\n   * the stream ends.\n   */\n  async collect() {\n    const buf = Object.assign([], {\n      dataLength: 0\n    });\n    if (!this[OBJECTMODE]) buf.dataLength = 0;\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise();\n    this.on('data', c => {\n      buf.push(c);\n      if (!this[OBJECTMODE]) buf.dataLength += c.length;\n    });\n    await p;\n    return buf;\n  }\n  /**\n   * Return a Promise that resolves to the concatenation of all emitted data\n   * once the stream ends.\n   *\n   * Not allowed on objectMode streams.\n   */\n  async concat() {\n    if (this[OBJECTMODE]) {\n      throw new Error('cannot concat in objectMode');\n    }\n    const buf = await this.collect();\n    return this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength);\n  }\n  /**\n   * Return a void Promise that resolves once the stream ends.\n   */\n  async promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n      this.on('error', er => reject(er));\n      this.on('end', () => resolve());\n    });\n  }\n  /**\n   * Asynchronous `for await of` iteration.\n   *\n   * This will continue emitting all chunks until the stream terminates.\n   */\n  [Symbol.asyncIterator]() {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false;\n    let stopped = false;\n    const stop = async () => {\n      this.pause();\n      stopped = true;\n      return {\n        value: undefined,\n        done: true\n      };\n    };\n    const next = () => {\n      if (stopped) return stop();\n      const res = this.read();\n      if (res !== null) return Promise.resolve({\n        done: false,\n        value: res\n      });\n      if (this[EOF]) return stop();\n      let resolve;\n      let reject;\n      const onerr = er => {\n        this.off('data', ondata);\n        this.off('end', onend);\n        this.off(DESTROYED, ondestroy);\n        stop();\n        reject(er);\n      };\n      const ondata = value => {\n        this.off('error', onerr);\n        this.off('end', onend);\n        this.off(DESTROYED, ondestroy);\n        this.pause();\n        resolve({\n          value,\n          done: !!this[EOF]\n        });\n      };\n      const onend = () => {\n        this.off('error', onerr);\n        this.off('data', ondata);\n        this.off(DESTROYED, ondestroy);\n        stop();\n        resolve({\n          done: true,\n          value: undefined\n        });\n      };\n      const ondestroy = () => onerr(new Error('stream destroyed'));\n      return new Promise((res, rej) => {\n        reject = rej;\n        resolve = res;\n        this.once(DESTROYED, ondestroy);\n        this.once('error', onerr);\n        this.once('end', onend);\n        this.once('data', ondata);\n      });\n    };\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.asyncIterator]() {\n        return this;\n      }\n    };\n  }\n  /**\n   * Synchronous `for of` iteration.\n   *\n   * The iteration will terminate when the internal buffer runs out, even\n   * if the stream has not yet terminated.\n   */\n  [Symbol.iterator]() {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false;\n    let stopped = false;\n    const stop = () => {\n      this.pause();\n      this.off(ERROR, stop);\n      this.off(DESTROYED, stop);\n      this.off('end', stop);\n      stopped = true;\n      return {\n        done: true,\n        value: undefined\n      };\n    };\n    const next = () => {\n      if (stopped) return stop();\n      const value = this.read();\n      return value === null ? stop() : {\n        done: false,\n        value\n      };\n    };\n    this.once('end', stop);\n    this.once(ERROR, stop);\n    this.once(DESTROYED, stop);\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.iterator]() {\n        return this;\n      }\n    };\n  }\n  /**\n   * Destroy a stream, preventing it from being used for any further purpose.\n   *\n   * If the stream has a `close()` method, then it will be called on\n   * destruction.\n   *\n   * After destruction, any attempt to write data, read data, or emit most\n   * events will be ignored.\n   *\n   * If an error argument is provided, then it will be emitted in an\n   * 'error' event.\n   */\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er);else this.emit(DESTROYED);\n      return this;\n    }\n    this[DESTROYED] = true;\n    this[DISCARDED] = true;\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0;\n    this[BUFFERLENGTH] = 0;\n    const wc = this;\n    if (typeof wc.close === 'function' && !this[CLOSED]) wc.close();\n    if (er) this.emit('error', er);\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED);\n    return this;\n  }\n  /**\n   * Alias for {@link isStream}\n   *\n   * Former export location, maintained for backwards compatibility.\n   *\n   * @deprecated\n   */\n  static get isStream() {\n    return exports.isStream;\n  }\n}\nexports.Minipass = Minipass;","map":{"version":3,"names":["proc","process","stdout","stderr","node_events_1","require","node_stream_1","__importDefault","node_string_decoder_1","isStream","s","Minipass","default","exports","isReadable","isWritable","EventEmitter","pipe","Writable","prototype","write","end","EOF","Symbol","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","EMITTED_ERROR","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFER","PIPES","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","ERROR","EMITDATA","EMITEND","EMITEND2","ASYNC","ABORT","ABORTED","SIGNAL","DATALISTENERS","DISCARDED","defer","fn","Promise","resolve","then","nodefer","isEndish","ev","isArrayBufferLike","b","ArrayBuffer","constructor","name","byteLength","isArrayBufferView","Buffer","isBuffer","isView","Pipe","src","dest","opts","ondrain","on","unpipe","removeListener","proxyErrors","_er","PipeProxyErrors","er","emit","isObjectModeOptions","o","objectMode","isEncodingOptions","encoding","writable","readable","args","options","TypeError","async","StringDecoder","debugExposeBuffer","Object","defineProperty","get","debugExposePipes","signal","aborted","addEventListener","bufferLength","_enc","Error","setEncoding","_om","a","reason","destroy","_","chunk","cb","assign","code","from","buffer","byteOffset","length","lastNeed","read","n","join","concat","ret","c","slice","subarray","undefined","once","resume","pause","destroyed","flowing","paused","push","shift","noDrain","ended","p","find","splice","indexOf","addListener","handler","removeAllListeners","h","call","off","listeners","emittedEnd","data","collect","buf","dataLength","promise","reject","asyncIterator","stopped","stop","value","done","next","res","onerr","ondata","onend","ondestroy","rej","throw","return","iterator","wc","close"],"sources":["E:\\programs\\AI programs\\AIMessageApp\\frontend\\node_modules\\minipass\\src\\index.ts"],"sourcesContent":["const proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nimport { EventEmitter } from 'node:events'\nimport Stream from 'node:stream'\nimport { StringDecoder } from 'node:string_decoder'\n\n/**\n * Same as StringDecoder, but exposing the `lastNeed` flag on the type\n */\ntype SD = StringDecoder & { lastNeed: boolean }\n\nexport type { SD, Pipe, PipeProxyErrors }\n\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nexport const isStream = (\n  s: any\n): s is Minipass.Readable | Minipass.Writable =>\n  !!s &&\n  typeof s === 'object' &&\n  (s instanceof Minipass ||\n    s instanceof Stream ||\n    isReadable(s) ||\n    isWritable(s))\n\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nexport const isReadable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Readable).pipe === 'function' &&\n  // node core Writable streams have a pipe() method, but it throws\n  (s as Minipass.Readable).pipe !== Stream.Writable.prototype.pipe\n\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nexport const isWritable = (s: any): s is Minipass.Readable =>\n  !!s &&\n  typeof s === 'object' &&\n  s instanceof EventEmitter &&\n  typeof (s as Minipass.Writable).write === 'function' &&\n  typeof (s as Minipass.Writable).end === 'function'\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\nconst DATALISTENERS = Symbol('dataListeners')\nconst DISCARDED = Symbol('discarded')\n\nconst defer = (fn: (...a: any[]) => any) => Promise.resolve().then(fn)\nconst nodefer = (fn: (...a: any[]) => any) => fn()\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\ntype EndishEvent = 'end' | 'finish' | 'prefinish'\nconst isEndish = (ev: any): ev is EndishEvent =>\n  ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBufferLike = (b: any): b is ArrayBufferLike =>\n  b instanceof ArrayBuffer ||\n  (!!b &&\n    typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = (b: any): b is ArrayBufferView =>\n  !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\n/**\n * Options that may be passed to stream.pipe()\n */\nexport interface PipeOptions {\n  /**\n   * end the destination stream when the source stream ends\n   */\n  end?: boolean\n  /**\n   * proxy errors from the source stream to the destination stream\n   */\n  proxyErrors?: boolean\n}\n\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe<T extends unknown> {\n  src: Minipass<T>\n  dest: Minipass<any, T>\n  opts: PipeOptions\n  ondrain: () => any\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    this.src = src\n    this.dest = dest as Minipass<any, T>\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    this.dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // only here for the prototype\n  /* c8 ignore start */\n  proxyErrors(_er: any) {}\n  /* c8 ignore stop */\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors<T> extends Pipe<T> {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(\n    src: Minipass<T>,\n    dest: Minipass.Writable,\n    opts: PipeOptions\n  ) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nexport namespace Minipass {\n  /**\n   * Encoding used to create a stream that outputs strings rather than\n   * Buffer objects.\n   */\n  export type Encoding = BufferEncoding | 'buffer' | null\n\n  /**\n   * Any stream that Minipass can pipe into\n   */\n  export type Writable =\n    | Minipass<any, any, any>\n    | NodeJS.WriteStream\n    | (NodeJS.WriteStream & { fd: number })\n    | (EventEmitter & {\n        end(): any\n        write(chunk: any, ...args: any[]): any\n      })\n\n  /**\n   * Any stream that can be read from\n   */\n  export type Readable =\n    | Minipass<any, any, any>\n    | NodeJS.ReadStream\n    | (NodeJS.ReadStream & { fd: number })\n    | (EventEmitter & {\n        pause(): any\n        resume(): any\n        pipe(...destArgs: any[]): any\n      })\n\n  /**\n   * Utility type that can be iterated sync or async\n   */\n  export type DualIterable<T> = Iterable<T> & AsyncIterable<T>\n\n  type EventArguments = Record<string | symbol, unknown[]>\n\n  /**\n   * The listing of events that a Minipass class can emit.\n   * Extend this when extending the Minipass class, and pass as\n   * the third template argument.  The key is the name of the event,\n   * and the value is the argument list.\n   *\n   * Any undeclared events will still be allowed, but the handler will get\n   * arguments as `unknown[]`.\n   */\n  export interface Events<RType extends any = Buffer>\n    extends EventArguments {\n    readable: []\n    data: [chunk: RType]\n    error: [er: unknown]\n    abort: [reason: unknown]\n    drain: []\n    resume: []\n    end: []\n    finish: []\n    prefinish: []\n    close: []\n    [DESTROYED]: [er?: unknown]\n    [ERROR]: [er: unknown]\n  }\n\n  /**\n   * String or buffer-like data that can be joined and sliced\n   */\n  export type ContiguousData =\n    | Buffer\n    | ArrayBufferLike\n    | ArrayBufferView\n    | string\n  export type BufferOrString = Buffer | string\n\n  /**\n   * Options passed to the Minipass constructor.\n   */\n  export type SharedOptions = {\n    /**\n     * Defer all data emission and other events until the end of the\n     * current tick, similar to Node core streams\n     */\n    async?: boolean\n    /**\n     * A signal which will abort the stream\n     */\n    signal?: AbortSignal\n    /**\n     * Output string encoding. Set to `null` or `'buffer'` (or omit) to\n     * emit Buffer objects rather than strings.\n     *\n     * Conflicts with `objectMode`\n     */\n    encoding?: BufferEncoding | null | 'buffer'\n    /**\n     * Output data exactly as it was written, supporting non-buffer/string\n     * data (such as arbitrary objects, falsey values, etc.)\n     *\n     * Conflicts with `encoding`\n     */\n    objectMode?: boolean\n  }\n\n  /**\n   * Options for a string encoded output\n   */\n  export type EncodingOptions = SharedOptions & {\n    encoding: BufferEncoding\n    objectMode?: false\n  }\n\n  /**\n   * Options for contiguous data buffer output\n   */\n  export type BufferOptions = SharedOptions & {\n    encoding?: null | 'buffer'\n    objectMode?: false\n  }\n\n  /**\n   * Options for objectMode arbitrary output\n   */\n  export type ObjectModeOptions = SharedOptions & {\n    objectMode: true\n    encoding?: null\n  }\n\n  /**\n   * Utility type to determine allowed options based on read type\n   */\n  export type Options<T> =\n    | ObjectModeOptions\n    | (T extends string\n        ? EncodingOptions\n        : T extends Buffer\n        ? BufferOptions\n        : SharedOptions)\n}\n\nconst isObjectModeOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.ObjectModeOptions => !!o.objectMode\n\nconst isEncodingOptions = (\n  o: Minipass.SharedOptions\n): o is Minipass.EncodingOptions =>\n  !o.objectMode && !!o.encoding && o.encoding !== 'buffer'\n\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nexport class Minipass<\n    RType extends unknown = Buffer,\n    WType extends unknown = RType extends Minipass.BufferOrString\n      ? Minipass.ContiguousData\n      : RType,\n    Events extends Minipass.Events<RType> = Minipass.Events<RType>\n  >\n  extends EventEmitter\n  implements Minipass.DualIterable<RType>\n{\n  [FLOWING]: boolean = false;\n  [PAUSED]: boolean = false;\n  [PIPES]: Pipe<RType>[] = [];\n  [BUFFER]: RType[] = [];\n  [OBJECTMODE]: boolean;\n  [ENCODING]: BufferEncoding | null;\n  [ASYNC]: boolean;\n  [DECODER]: SD | null;\n  [EOF]: boolean = false;\n  [EMITTED_END]: boolean = false;\n  [EMITTING_END]: boolean = false;\n  [CLOSED]: boolean = false;\n  [EMITTED_ERROR]: unknown = null;\n  [BUFFERLENGTH]: number = 0;\n  [DESTROYED]: boolean = false;\n  [SIGNAL]?: AbortSignal;\n  [ABORTED]: boolean = false;\n  [DATALISTENERS]: number = 0;\n  [DISCARDED]: boolean = false\n\n  /**\n   * true if the stream can be written\n   */\n  writable: boolean = true\n  /**\n   * true if the stream can be read\n   */\n  readable: boolean = true\n\n  /**\n   * If `RType` is Buffer, then options do not need to be provided.\n   * Otherwise, an options object must be provided to specify either\n   * {@link Minipass.SharedOptions.objectMode} or\n   * {@link Minipass.SharedOptions.encoding}, as appropriate.\n   */\n  constructor(\n    ...args:\n      | [Minipass.ObjectModeOptions]\n      | (RType extends Buffer\n          ? [] | [Minipass.Options<RType>]\n          : [Minipass.Options<RType>])\n  ) {\n    const options: Minipass.Options<RType> = (args[0] ||\n      {}) as Minipass.Options<RType>\n    super()\n    if (options.objectMode && typeof options.encoding === 'string') {\n      throw new TypeError(\n        'Encoding and objectMode may not be used together'\n      )\n    }\n    if (isObjectModeOptions(options)) {\n      this[OBJECTMODE] = true\n      this[ENCODING] = null\n    } else if (isEncodingOptions(options)) {\n      this[ENCODING] = options.encoding\n      this[OBJECTMODE] = false\n    } else {\n      this[OBJECTMODE] = false\n      this[ENCODING] = null\n    }\n    this[ASYNC] = !!options.async\n    this[DECODER] = this[ENCODING]\n      ? (new StringDecoder(this[ENCODING]) as SD)\n      : null\n\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    //@ts-ignore - private option for debugging and testing\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n\n    const { signal } = options\n    if (signal) {\n      this[SIGNAL] = signal\n      if (signal.aborted) {\n        this[ABORT]()\n      } else {\n        signal.addEventListener('abort', () => this[ABORT]())\n      }\n    }\n  }\n\n  /**\n   * The amount of data stored in the buffer waiting to be read.\n   *\n   * For Buffer strings, this will be the total byte length.\n   * For string encoding streams, this will be the string character length,\n   * according to JavaScript's `string.length` logic.\n   * For objectMode streams, this is a count of the items waiting to be\n   * emitted.\n   */\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  /**\n   * The `BufferEncoding` currently in use, or `null`\n   */\n  get encoding() {\n    return this[ENCODING]\n  }\n\n  /**\n   * @deprecated - This is a read only property\n   */\n  set encoding(_enc) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * @deprecated - Encoding may only be set at instantiation time\n   */\n  setEncoding(_enc: Minipass.Encoding) {\n    throw new Error('Encoding must be set at instantiation time')\n  }\n\n  /**\n   * True if this is an objectMode stream\n   */\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n\n  /**\n   * @deprecated - This is a read-only property\n   */\n  set objectMode(_om) {\n    throw new Error('objectMode must be set at instantiation time')\n  }\n\n  /**\n   * true if this is an async stream\n   */\n  get ['async'](): boolean {\n    return this[ASYNC]\n  }\n  /**\n   * Set to true to make this stream async.\n   *\n   * Once set, it cannot be unset, as this would potentially cause incorrect\n   * behavior.  Ie, a sync stream can be made async, but an async stream\n   * cannot be safely made sync.\n   */\n  set ['async'](a: boolean) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL]?.reason)\n    this.destroy(this[SIGNAL]?.reason)\n  }\n\n  /**\n   * True if the stream has been aborted.\n   */\n  get aborted() {\n    return this[ABORTED]\n  }\n  /**\n   * No-op setter. Stream aborted status is set via the AbortSignal provided\n   * in the constructor options.\n   */\n  set aborted(_) {}\n\n  /**\n   * Write data into the stream\n   *\n   * If the chunk written is a string, and encoding is not specified, then\n   * `utf8` will be assumed. If the stream encoding matches the encoding of\n   * a written string, and the state of the string decoder allows it, then\n   * the string will be passed through to either the output or the internal\n   * buffer without any processing. Otherwise, it will be turned into a\n   * Buffer object for processing into the desired encoding.\n   *\n   * If provided, `cb` function is called immediately before return for\n   * sync streams, or on next tick for async streams, because for this\n   * base class, a chunk is considered \"processed\" once it is accepted\n   * and either emitted or buffered. That is, the callback does not indicate\n   * that the chunk has been eventually emitted, though of course child\n   * classes can override this function to do whatever processing is required\n   * and call `super.write(...)` only once processing is completed.\n   */\n  write(chunk: WType, cb?: () => void): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding,\n    cb?: () => void\n  ): boolean\n  write(\n    chunk: WType,\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ): boolean {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : nodefer\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything is only allowed if in object mode, so throw\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(\n          chunk.buffer,\n          chunk.byteOffset,\n          chunk.byteLength\n        )\n      } else if (isArrayBufferLike(chunk)) {\n        //@ts-ignore - sinful unsafe type changing\n        chunk = Buffer.from(chunk)\n      } else if (typeof chunk !== 'string') {\n        throw new Error(\n          'Non-contiguous data written to non-objectMode stream'\n        )\n      }\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      // maybe impossible?\n      /* c8 ignore start */\n      if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n      /* c8 ignore stop */\n\n      if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n      else this[BUFFERPUSH](chunk as unknown as RType)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this[FLOWING]\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!(chunk as Minipass.BufferOrString).length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this[FLOWING]\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)\n    ) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n      //@ts-ignore - sinful unsafe type change\n      chunk = this[DECODER].write(chunk)\n    }\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this[FLOWING]) this.emit('data', chunk as unknown as RType)\n    else this[BUFFERPUSH](chunk as unknown as RType)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this[FLOWING]\n  }\n\n  /**\n   * Low-level explicit read method.\n   *\n   * In objectMode, the argument is ignored, and one item is returned if\n   * available.\n   *\n   * `n` is the number of bytes (or in the case of encoding streams,\n   * characters) to consume. If `n` is not provided, then the entire buffer\n   * is returned, or `null` is returned if no data is available.\n   *\n   * If `n` is greater that the amount of data in the internal buffer,\n   * then `null` is returned.\n   */\n  read(n?: number | null): RType | null {\n    if (this[DESTROYED]) return null\n    this[DISCARDED] = false\n\n    if (\n      this[BUFFERLENGTH] === 0 ||\n      n === 0 ||\n      (n && n > this[BUFFERLENGTH])\n    ) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      // not object mode, so if we have an encoding, then RType is string\n      // otherwise, must be Buffer\n      this[BUFFER] = [\n        (this[ENCODING]\n          ? this[BUFFER].join('')\n          : Buffer.concat(\n              this[BUFFER] as Buffer[],\n              this[BUFFERLENGTH]\n            )) as RType,\n      ]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0] as RType)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n: number | null, chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERSHIFT]()\n    else {\n      const c = chunk as Minipass.BufferOrString\n      if (n === c.length || n === null) this[BUFFERSHIFT]()\n      else if (typeof c === 'string') {\n        this[BUFFER][0] = c.slice(n) as RType\n        chunk = c.slice(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      } else {\n        this[BUFFER][0] = c.subarray(n) as RType\n        chunk = c.subarray(0, n) as RType\n        this[BUFFERLENGTH] -= n\n      }\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  /**\n   * End the stream, optionally providing a final write.\n   *\n   * See {@link Minipass#write} for argument descriptions\n   */\n  end(cb?: () => void): this\n  end(chunk: WType, cb?: () => void): this\n  end(chunk: WType, encoding?: Minipass.Encoding, cb?: () => void): this\n  end(\n    chunk?: WType | (() => void),\n    encoding?: Minipass.Encoding | (() => void),\n    cb?: () => void\n  ): this {\n    if (typeof chunk === 'function') {\n      cb = chunk as () => void\n      chunk = undefined\n    }\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = 'utf8'\n    }\n    if (chunk !== undefined) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    if (!this[DATALISTENERS] && !this[PIPES].length) {\n      this[DISCARDED] = true\n    }\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  /**\n   * Resume the stream if it is currently in a paused state\n   *\n   * If called when there are no pipe destinations or `data` event listeners,\n   * this will place the stream in a \"discarded\" state, where all data will\n   * be thrown away. The discarded state is removed if a pipe destination or\n   * data handler is added, if pause() is called, or if any synchronous or\n   * asynchronous iteration is started.\n   */\n  resume() {\n    return this[RESUME]()\n  }\n\n  /**\n   * Pause the stream\n   */\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n    this[DISCARDED] = false\n  }\n\n  /**\n   * true if the stream has been forcibly destroyed\n   */\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  /**\n   * true if the stream is currently in a flowing state, meaning that\n   * any writes will be immediately emitted.\n   */\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  /**\n   * true if the stream is currently in a paused state\n   */\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk: RType) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += (chunk as Minipass.BufferOrString).length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT](): RType {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else\n      this[BUFFERLENGTH] -= (\n        this[BUFFER][0] as Minipass.BufferOrString\n      ).length\n    return this[BUFFER].shift() as RType\n  }\n\n  [FLUSH](noDrain: boolean = false) {\n    do {} while (\n      this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n      this[BUFFER].length\n    )\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk: RType) {\n    this.emit('data', chunk)\n    return this[FLOWING]\n  }\n\n  /**\n   * Pipe all data emitted by this stream into the destination provided.\n   *\n   * Triggers the flow of data.\n   */\n  pipe<W extends Minipass.Writable>(dest: W, opts?: PipeOptions): W {\n    if (this[DESTROYED]) return dest\n    this[DISCARDED] = false\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      // \"as\" here just ignores the WType, which pipes don't care about,\n      // since they're only consuming from us, and writing to the dest\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe<RType>(this as Minipass<RType>, dest, opts)\n          : new PipeProxyErrors<RType>(this as Minipass<RType>, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  /**\n   * Fully unhook a piped destination stream.\n   *\n   * If the destination stream was the only consumer of this stream (ie,\n   * there are no other piped destinations or `'data'` event listeners)\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  unpipe<W extends Minipass.Writable>(dest: W) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      if (this[PIPES].length === 1) {\n        if (this[FLOWING] && this[DATALISTENERS] === 0) {\n          this[FLOWING] = false\n        }\n        this[PIPES] = []\n      } else this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  /**\n   * Alias for {@link Minipass#on}\n   */\n  addListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    return this.on(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.on`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * - Adding a 'data' event handler will trigger the flow of data\n   *\n   * - Adding a 'readable' event handler when there is data waiting to be read\n   *   will cause 'readable' to be emitted immediately.\n   *\n   * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n   *   already passed will cause the event to be emitted immediately and all\n   *   handlers removed.\n   *\n   * - Adding an 'error' event handler after an error has been emitted will\n   *   cause the event to be re-emitted immediately with the error previously\n   *   raised.\n   */\n  on<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ): this {\n    const ret = super.on(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    if (ev === 'data') {\n      this[DISCARDED] = false\n      this[DATALISTENERS]++\n      if (!this[PIPES].length && !this[FLOWING]) {\n        this[RESUME]()\n      }\n    } else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n      super.emit('readable')\n    } else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      const h = handler as (...a: Events['error']) => any\n      if (this[ASYNC]) defer(() => h.call(this, this[EMITTED_ERROR]))\n      else h.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  /**\n   * Alias for {@link Minipass#off}\n   */\n  removeListener<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    return this.off(ev, handler)\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.off`\n   *\n   * If a 'data' event handler is removed, and it was the last consumer\n   * (ie, there are no pipe destinations or other 'data' event listeners),\n   * then the flow of data will stop until there is another consumer or\n   * {@link Minipass#resume} is explicitly called.\n   */\n  off<Event extends keyof Events>(\n    ev: Event,\n    handler: (...args: Events[Event]) => any\n  ) {\n    const ret = super.off(\n      ev as string | symbol,\n      handler as (...a: any[]) => any\n    )\n    // if we previously had listeners, and now we don't, and we don't\n    // have any pipes, then stop the flow, unless it's been explicitly\n    // put in a discarded flowing state via stream.resume().\n    if (ev === 'data') {\n      this[DATALISTENERS] = this.listeners('data').length\n      if (\n        this[DATALISTENERS] === 0 &&\n        !this[DISCARDED] &&\n        !this[PIPES].length\n      ) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.removeAllListeners`\n   *\n   * If all 'data' event handlers are removed, and they were the last consumer\n   * (ie, there are no pipe destinations), then the flow of data will stop\n   * until there is another consumer or {@link Minipass#resume} is explicitly\n   * called.\n   */\n  removeAllListeners<Event extends keyof Events>(ev?: Event) {\n    const ret = super.removeAllListeners(ev as string | symbol | undefined)\n    if (ev === 'data' || ev === undefined) {\n      this[DATALISTENERS] = 0\n      if (!this[DISCARDED] && !this[PIPES].length) {\n        this[FLOWING] = false\n      }\n    }\n    return ret\n  }\n\n  /**\n   * true if the 'end' event has been emitted\n   */\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  /**\n   * Mostly identical to `EventEmitter.emit`, with the following\n   * behavior differences to prevent data loss and unnecessary hangs:\n   *\n   * If the stream has been destroyed, and the event is something other\n   * than 'close' or 'error', then `false` is returned and no handlers\n   * are called.\n   *\n   * If the event is 'end', and has already been emitted, then the event\n   * is ignored. If the stream is in a paused or non-flowing state, then\n   * the event will be deferred until data flow resumes. If the stream is\n   * async, then handlers will be called on the next tick rather than\n   * immediately.\n   *\n   * If the event is 'close', and 'end' has not yet been emitted, then\n   * the event will be deferred until after 'end' is emitted.\n   *\n   * If the event is 'error', and an AbortSignal was provided for the stream,\n   * and there are no listeners, then the event is ignored, matching the\n   * behavior of node core streams in the presense of an AbortSignal.\n   *\n   * If the event is 'finish' or 'prefinish', then all listeners will be\n   * removed after emitting the event, to prevent double-firing.\n   */\n  emit<Event extends keyof Events>(\n    ev: Event,\n    ...args: Events[Event]\n  ): boolean {\n    const data = args[0]\n    // error and close are only events allowed after calling destroy()\n    if (\n      ev !== 'error' &&\n      ev !== 'close' &&\n      ev !== DESTROYED &&\n      this[DESTROYED]\n    ) {\n      return false\n    } else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? (defer(() => this[EMITDATA](data as RType)), true)\n        : this[EMITDATA](data as RType)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return false\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev as string, ...args)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data: RType) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data as RType) === false) this.pause()\n    }\n    const ret = this[DISCARDED] ? false : super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return false\n\n    this[EMITTED_END] = true\n    this.readable = false\n    return this[ASYNC]\n      ? (defer(() => this[EMITEND2]()), true)\n      : this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data as RType)\n        }\n        if (!this[DISCARDED]) super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  /**\n   * Return a Promise that resolves to an array of all emitted data once\n   * the stream ends.\n   */\n  async collect(): Promise<RType[] & { dataLength: number }> {\n    const buf: RType[] & { dataLength: number } = Object.assign([], {\n      dataLength: 0,\n    })\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += (c as Minipass.BufferOrString).length\n    })\n    await p\n    return buf\n  }\n\n  /**\n   * Return a Promise that resolves to the concatenation of all emitted data\n   * once the stream ends.\n   *\n   * Not allowed on objectMode streams.\n   */\n  async concat(): Promise<RType> {\n    if (this[OBJECTMODE]) {\n      throw new Error('cannot concat in objectMode')\n    }\n    const buf = await this.collect()\n    return (\n      this[ENCODING]\n        ? buf.join('')\n        : Buffer.concat(buf as Buffer[], buf.dataLength)\n    ) as RType\n  }\n\n  /**\n   * Return a void Promise that resolves once the stream ends.\n   */\n  async promise(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  /**\n   * Asynchronous `for await of` iteration.\n   *\n   * This will continue emitting all chunks until the stream terminates.\n   */\n  [Symbol.asyncIterator](): AsyncGenerator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = async (): Promise<IteratorReturnResult<void>> => {\n      this.pause()\n      stopped = true\n      return { value: undefined, done: true }\n    }\n    const next = (): Promise<IteratorResult<RType, void>> => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve!: (res: IteratorResult<RType>) => void\n      let reject!: (er: unknown) => void\n      const onerr = (er: unknown) => {\n        this.off('data', ondata)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = (value: RType) => {\n        this.off('error', onerr)\n        this.off('end', onend)\n        this.off(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.off('error', onerr)\n        this.off('data', ondata)\n        this.off(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true, value: undefined })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise<IteratorResult<RType>>((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.asyncIterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Synchronous `for of` iteration.\n   *\n   * The iteration will terminate when the internal buffer runs out, even\n   * if the stream has not yet terminated.\n   */\n  [Symbol.iterator](): Generator<RType, void, void> {\n    // set this up front, in case the consumer doesn't call next()\n    // right away.\n    this[DISCARDED] = false\n    let stopped = false\n    const stop = (): IteratorReturnResult<void> => {\n      this.pause()\n      this.off(ERROR, stop)\n      this.off(DESTROYED, stop)\n      this.off('end', stop)\n      stopped = true\n      return { done: true, value: undefined }\n    }\n\n    const next = (): IteratorResult<RType, void> => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { done: false, value }\n    }\n\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [Symbol.iterator]() {\n        return this\n      },\n    }\n  }\n\n  /**\n   * Destroy a stream, preventing it from being used for any further purpose.\n   *\n   * If the stream has a `close()` method, then it will be called on\n   * destruction.\n   *\n   * After destruction, any attempt to write data, read data, or emit most\n   * events will be ignored.\n   *\n   * If an error argument is provided, then it will be emitted in an\n   * 'error' event.\n   */\n  destroy(er?: unknown) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n    this[DISCARDED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    const wc = this as Minipass<RType, WType, Events> & {\n      close?: () => void\n    }\n    if (typeof wc.close === 'function' && !this[CLOSED]) wc.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  /**\n   * Alias for {@link isStream}\n   *\n   * Former export location, maintained for backwards compatibility.\n   *\n   * @deprecated\n   */\n  static get isStream() {\n    return isStream\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}