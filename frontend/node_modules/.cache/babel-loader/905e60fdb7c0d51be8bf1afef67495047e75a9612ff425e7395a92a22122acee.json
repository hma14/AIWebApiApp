{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;\nconst lru_cache_1 = require(\"lru-cache\");\nconst node_path_1 = require(\"node:path\");\nconst node_url_1 = require(\"node:url\");\nconst fs_1 = require(\"fs\");\nconst actualFS = __importStar(require(\"node:fs\"));\nconst realpathSync = fs_1.realpathSync.native;\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nconst promises_1 = require(\"node:fs/promises\");\nconst minipass_1 = require(\"minipass\");\nconst defaultFS = {\n  lstatSync: fs_1.lstatSync,\n  readdir: fs_1.readdir,\n  readdirSync: fs_1.readdirSync,\n  readlinkSync: fs_1.readlinkSync,\n  realpathSync,\n  promises: {\n    lstat: promises_1.lstat,\n    readdir: promises_1.readdir,\n    readlink: promises_1.readlink,\n    realpath: promises_1.realpath\n  }\n};\n// if they just gave us require('fs') then use our default\nconst fsFromOption = fsOption => !fsOption || fsOption === defaultFS || fsOption === actualFS ? defaultFS : {\n  ...defaultFS,\n  ...fsOption,\n  promises: {\n    ...defaultFS.promises,\n    ...(fsOption.promises || {})\n  }\n};\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i;\nconst uncToDrive = rootPath => rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/;\nconst UNKNOWN = 0; // may not even exist, for all we know\nconst IFIFO = 0b0001;\nconst IFCHR = 0b0010;\nconst IFDIR = 0b0100;\nconst IFBLK = 0b0110;\nconst IFREG = 0b1000;\nconst IFLNK = 0b1010;\nconst IFSOCK = 0b1100;\nconst IFMT = 0b1111;\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT;\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 0b0000_0001_0000;\n// set after a successful lstat()\nconst LSTAT_CALLED = 0b0000_0010_0000;\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 0b0000_0100_0000;\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 0b0000_1000_0000;\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 0b0001_0000_0000;\n// set if we know realpath() will fail\nconst ENOREALPATH = 0b0010_0000_0000;\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;\nconst TYPEMASK = 0b0011_1111_1111;\nconst entToType = s => s.isFile() ? IFREG : s.isDirectory() ? IFDIR : s.isSymbolicLink() ? IFLNK : s.isCharacterDevice() ? IFCHR : s.isBlockDevice() ? IFBLK : s.isSocket() ? IFSOCK : s.isFIFO() ? IFIFO : UNKNOWN;\n// normalize unicode path names\nconst normalizeCache = new Map();\nconst normalize = s => {\n  const c = normalizeCache.get(s);\n  if (c) return c;\n  const n = s.normalize('NFKD');\n  normalizeCache.set(s, n);\n  return n;\n};\nconst normalizeNocaseCache = new Map();\nconst normalizeNocase = s => {\n  const c = normalizeNocaseCache.get(s);\n  if (c) return c;\n  const n = normalize(s.toLowerCase());\n  normalizeNocaseCache.set(s, n);\n  return n;\n};\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nclass ResolveCache extends lru_cache_1.LRUCache {\n  constructor() {\n    super({\n      max: 256\n    });\n  }\n}\nexports.ResolveCache = ResolveCache;\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nclass ChildrenCache extends lru_cache_1.LRUCache {\n  constructor(maxSize = 16 * 1024) {\n    super({\n      maxSize,\n      // parent + children\n      sizeCalculation: a => a.length + 1\n    });\n  }\n}\nexports.ChildrenCache = ChildrenCache;\nconst setAsCwd = Symbol('PathScurry setAsCwd');\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nclass PathBase {\n  /**\n   * the basename of this path\n   *\n   * **Important**: *always* test the path name against any test string\n   * usingthe {@link isNamed} method, and not by directly comparing this\n   * string. Otherwise, unicode path strings that the system sees as identical\n   * will not be properly treated as the same path, leading to incorrect\n   * behavior and possible security issues.\n   */\n  name;\n  /**\n   * the Path entry corresponding to the path root.\n   *\n   * @internal\n   */\n  root;\n  /**\n   * All roots found within the current PathScurry family\n   *\n   * @internal\n   */\n  roots;\n  /**\n   * a reference to the parent path, or undefined in the case of root entries\n   *\n   * @internal\n   */\n  parent;\n  /**\n   * boolean indicating whether paths are compared case-insensitively\n   * @internal\n   */\n  nocase;\n  /**\n   * boolean indicating that this path is the current working directory\n   * of the PathScurry collection that contains it.\n   */\n  isCWD = false;\n  // potential default fs override\n  #fs;\n  // Stats fields\n  #dev;\n  get dev() {\n    return this.#dev;\n  }\n  #mode;\n  get mode() {\n    return this.#mode;\n  }\n  #nlink;\n  get nlink() {\n    return this.#nlink;\n  }\n  #uid;\n  get uid() {\n    return this.#uid;\n  }\n  #gid;\n  get gid() {\n    return this.#gid;\n  }\n  #rdev;\n  get rdev() {\n    return this.#rdev;\n  }\n  #blksize;\n  get blksize() {\n    return this.#blksize;\n  }\n  #ino;\n  get ino() {\n    return this.#ino;\n  }\n  #size;\n  get size() {\n    return this.#size;\n  }\n  #blocks;\n  get blocks() {\n    return this.#blocks;\n  }\n  #atimeMs;\n  get atimeMs() {\n    return this.#atimeMs;\n  }\n  #mtimeMs;\n  get mtimeMs() {\n    return this.#mtimeMs;\n  }\n  #ctimeMs;\n  get ctimeMs() {\n    return this.#ctimeMs;\n  }\n  #birthtimeMs;\n  get birthtimeMs() {\n    return this.#birthtimeMs;\n  }\n  #atime;\n  get atime() {\n    return this.#atime;\n  }\n  #mtime;\n  get mtime() {\n    return this.#mtime;\n  }\n  #ctime;\n  get ctime() {\n    return this.#ctime;\n  }\n  #birthtime;\n  get birthtime() {\n    return this.#birthtime;\n  }\n  #matchName;\n  #depth;\n  #fullpath;\n  #fullpathPosix;\n  #relative;\n  #relativePosix;\n  #type;\n  #children;\n  #linkTarget;\n  #realpath;\n  /**\n   * This property is for compatibility with the Dirent class as of\n   * Node v20, where Dirent['parentPath'] refers to the path of the\n   * directory that was passed to readdir. For root entries, it's the path\n   * to the entry itself.\n   */\n  get parentPath() {\n    return (this.parent || this).fullpath();\n  }\n  /**\n   * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,\n   * this property refers to the *parent* path, not the path object itself.\n   *\n   * @deprecated\n   */\n  get path() {\n    return this.parentPath;\n  }\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n    this.name = name;\n    this.#matchName = nocase ? normalizeNocase(name) : normalize(name);\n    this.#type = type & TYPEMASK;\n    this.nocase = nocase;\n    this.roots = roots;\n    this.root = root || this;\n    this.#children = children;\n    this.#fullpath = opts.fullpath;\n    this.#relative = opts.relative;\n    this.#relativePosix = opts.relativePosix;\n    this.parent = opts.parent;\n    if (this.parent) {\n      this.#fs = this.parent.#fs;\n    } else {\n      this.#fs = fsFromOption(opts.fs);\n    }\n  }\n  /**\n   * Returns the depth of the Path object from its root.\n   *\n   * For example, a path at `/foo/bar` would have a depth of 2.\n   */\n  depth() {\n    if (this.#depth !== undefined) return this.#depth;\n    if (!this.parent) return this.#depth = 0;\n    return this.#depth = this.parent.depth() + 1;\n  }\n  /**\n   * @internal\n   */\n  childrenCache() {\n    return this.#children;\n  }\n  /**\n   * Get the Path object referenced by the string path, resolved from this Path\n   */\n  resolve(path) {\n    if (!path) {\n      return this;\n    }\n    const rootPath = this.getRootString(path);\n    const dir = path.substring(rootPath.length);\n    const dirParts = dir.split(this.splitSep);\n    const result = rootPath ? this.getRoot(rootPath).#resolveParts(dirParts) : this.#resolveParts(dirParts);\n    return result;\n  }\n  #resolveParts(dirParts) {\n    let p = this;\n    for (const part of dirParts) {\n      p = p.child(part);\n    }\n    return p;\n  }\n  /**\n   * Returns the cached children Path objects, if still available.  If they\n   * have fallen out of the cache, then returns an empty array, and resets the\n   * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n   * lookup.\n   *\n   * @internal\n   */\n  children() {\n    const cached = this.#children.get(this);\n    if (cached) {\n      return cached;\n    }\n    const children = Object.assign([], {\n      provisional: 0\n    });\n    this.#children.set(this, children);\n    this.#type &= ~READDIR_CALLED;\n    return children;\n  }\n  /**\n   * Resolves a path portion and returns or creates the child Path.\n   *\n   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n   * `'..'`.\n   *\n   * This should not be called directly.  If `pathPart` contains any path\n   * separators, it will lead to unsafe undefined behavior.\n   *\n   * Use `Path.resolve()` instead.\n   *\n   * @internal\n   */\n  child(pathPart, opts) {\n    if (pathPart === '' || pathPart === '.') {\n      return this;\n    }\n    if (pathPart === '..') {\n      return this.parent || this;\n    }\n    // find the child\n    const children = this.children();\n    const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);\n    for (const p of children) {\n      if (p.#matchName === name) {\n        return p;\n      }\n    }\n    // didn't find it, create provisional child, since it might not\n    // actually exist.  If we know the parent isn't a dir, then\n    // in fact it CAN'T exist.\n    const s = this.parent ? this.sep : '';\n    const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;\n    const pchild = this.newChild(pathPart, UNKNOWN, {\n      ...opts,\n      parent: this,\n      fullpath\n    });\n    if (!this.canReaddir()) {\n      pchild.#type |= ENOENT;\n    }\n    // don't have to update provisional, because if we have real children,\n    // then provisional is set to children.length, otherwise a lower number\n    children.push(pchild);\n    return pchild;\n  }\n  /**\n   * The relative path from the cwd. If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpath()\n   */\n  relative() {\n    if (this.isCWD) return '';\n    if (this.#relative !== undefined) {\n      return this.#relative;\n    }\n    const name = this.name;\n    const p = this.parent;\n    if (!p) {\n      return this.#relative = this.name;\n    }\n    const pv = p.relative();\n    return pv + (!pv || !p.parent ? '' : this.sep) + name;\n  }\n  /**\n   * The relative path from the cwd, using / as the path separator.\n   * If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpathPosix()\n   * On posix systems, this is identical to relative().\n   */\n  relativePosix() {\n    if (this.sep === '/') return this.relative();\n    if (this.isCWD) return '';\n    if (this.#relativePosix !== undefined) return this.#relativePosix;\n    const name = this.name;\n    const p = this.parent;\n    if (!p) {\n      return this.#relativePosix = this.fullpathPosix();\n    }\n    const pv = p.relativePosix();\n    return pv + (!pv || !p.parent ? '' : '/') + name;\n  }\n  /**\n   * The fully resolved path string for this Path entry\n   */\n  fullpath() {\n    if (this.#fullpath !== undefined) {\n      return this.#fullpath;\n    }\n    const name = this.name;\n    const p = this.parent;\n    if (!p) {\n      return this.#fullpath = this.name;\n    }\n    const pv = p.fullpath();\n    const fp = pv + (!p.parent ? '' : this.sep) + name;\n    return this.#fullpath = fp;\n  }\n  /**\n   * On platforms other than windows, this is identical to fullpath.\n   *\n   * On windows, this is overridden to return the forward-slash form of the\n   * full UNC path.\n   */\n  fullpathPosix() {\n    if (this.#fullpathPosix !== undefined) return this.#fullpathPosix;\n    if (this.sep === '/') return this.#fullpathPosix = this.fullpath();\n    if (!this.parent) {\n      const p = this.fullpath().replace(/\\\\/g, '/');\n      if (/^[a-z]:\\//i.test(p)) {\n        return this.#fullpathPosix = `//?/${p}`;\n      } else {\n        return this.#fullpathPosix = p;\n      }\n    }\n    const p = this.parent;\n    const pfpp = p.fullpathPosix();\n    const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;\n    return this.#fullpathPosix = fpp;\n  }\n  /**\n   * Is the Path of an unknown type?\n   *\n   * Note that we might know *something* about it if there has been a previous\n   * filesystem operation, for example that it does not exist, or is not a\n   * link, or whether it has child entries.\n   */\n  isUnknown() {\n    return (this.#type & IFMT) === UNKNOWN;\n  }\n  isType(type) {\n    return this[`is${type}`]();\n  }\n  getType() {\n    return this.isUnknown() ? 'Unknown' : this.isDirectory() ? 'Directory' : this.isFile() ? 'File' : this.isSymbolicLink() ? 'SymbolicLink' : this.isFIFO() ? 'FIFO' : this.isCharacterDevice() ? 'CharacterDevice' : this.isBlockDevice() ? 'BlockDevice' : /* c8 ignore start */this.isSocket() ? 'Socket' : 'Unknown';\n    /* c8 ignore stop */\n  }\n  /**\n   * Is the Path a regular file?\n   */\n  isFile() {\n    return (this.#type & IFMT) === IFREG;\n  }\n  /**\n   * Is the Path a directory?\n   */\n  isDirectory() {\n    return (this.#type & IFMT) === IFDIR;\n  }\n  /**\n   * Is the path a character device?\n   */\n  isCharacterDevice() {\n    return (this.#type & IFMT) === IFCHR;\n  }\n  /**\n   * Is the path a block device?\n   */\n  isBlockDevice() {\n    return (this.#type & IFMT) === IFBLK;\n  }\n  /**\n   * Is the path a FIFO pipe?\n   */\n  isFIFO() {\n    return (this.#type & IFMT) === IFIFO;\n  }\n  /**\n   * Is the path a socket?\n   */\n  isSocket() {\n    return (this.#type & IFMT) === IFSOCK;\n  }\n  /**\n   * Is the path a symbolic link?\n   */\n  isSymbolicLink() {\n    return (this.#type & IFLNK) === IFLNK;\n  }\n  /**\n   * Return the entry if it has been subject of a successful lstat, or\n   * undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* simply\n   * mean that we haven't called lstat on it.\n   */\n  lstatCached() {\n    return this.#type & LSTAT_CALLED ? this : undefined;\n  }\n  /**\n   * Return the cached link target if the entry has been the subject of a\n   * successful readlink, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readlink() has been called at some point.\n   */\n  readlinkCached() {\n    return this.#linkTarget;\n  }\n  /**\n   * Returns the cached realpath target if the entry has been the subject\n   * of a successful realpath, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * realpath() has been called at some point.\n   */\n  realpathCached() {\n    return this.#realpath;\n  }\n  /**\n   * Returns the cached child Path entries array if the entry has been the\n   * subject of a successful readdir(), or [] otherwise.\n   *\n   * Does not read the filesystem, so an empty array *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readdir() has been called recently enough to still be valid.\n   */\n  readdirCached() {\n    const children = this.children();\n    return children.slice(0, children.provisional);\n  }\n  /**\n   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n   * any indication that readlink will definitely fail.\n   *\n   * Returns false if the path is known to not be a symlink, if a previous\n   * readlink failed, or if the entry does not exist.\n   */\n  canReadlink() {\n    if (this.#linkTarget) return true;\n    if (!this.parent) return false;\n    // cases where it cannot possibly succeed\n    const ifmt = this.#type & IFMT;\n    return !(ifmt !== UNKNOWN && ifmt !== IFLNK || this.#type & ENOREADLINK || this.#type & ENOENT);\n  }\n  /**\n   * Return true if readdir has previously been successfully called on this\n   * path, indicating that cachedReaddir() is likely valid.\n   */\n  calledReaddir() {\n    return !!(this.#type & READDIR_CALLED);\n  }\n  /**\n   * Returns true if the path is known to not exist. That is, a previous lstat\n   * or readdir failed to verify its existence when that would have been\n   * expected, or a parent entry was marked either enoent or enotdir.\n   */\n  isENOENT() {\n    return !!(this.#type & ENOENT);\n  }\n  /**\n   * Return true if the path is a match for the given path name.  This handles\n   * case sensitivity and unicode normalization.\n   *\n   * Note: even on case-sensitive systems, it is **not** safe to test the\n   * equality of the `.name` property to determine whether a given pathname\n   * matches, due to unicode normalization mismatches.\n   *\n   * Always use this method instead of testing the `path.name` property\n   * directly.\n   */\n  isNamed(n) {\n    return !this.nocase ? this.#matchName === normalize(n) : this.#matchName === normalizeNocase(n);\n  }\n  /**\n   * Return the Path object corresponding to the target of a symbolic link.\n   *\n   * If the Path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   */\n  async readlink() {\n    const target = this.#linkTarget;\n    if (target) {\n      return target;\n    }\n    if (!this.canReadlink()) {\n      return undefined;\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined;\n    }\n    /* c8 ignore stop */\n    try {\n      const read = await this.#fs.promises.readlink(this.fullpath());\n      const linkTarget = (await this.parent.realpath())?.resolve(read);\n      if (linkTarget) {\n        return this.#linkTarget = linkTarget;\n      }\n    } catch (er) {\n      this.#readlinkFail(er.code);\n      return undefined;\n    }\n  }\n  /**\n   * Synchronous {@link PathBase.readlink}\n   */\n  readlinkSync() {\n    const target = this.#linkTarget;\n    if (target) {\n      return target;\n    }\n    if (!this.canReadlink()) {\n      return undefined;\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined;\n    }\n    /* c8 ignore stop */\n    try {\n      const read = this.#fs.readlinkSync(this.fullpath());\n      const linkTarget = this.parent.realpathSync()?.resolve(read);\n      if (linkTarget) {\n        return this.#linkTarget = linkTarget;\n      }\n    } catch (er) {\n      this.#readlinkFail(er.code);\n      return undefined;\n    }\n  }\n  #readdirSuccess(children) {\n    // succeeded, mark readdir called bit\n    this.#type |= READDIR_CALLED;\n    // mark all remaining provisional children as ENOENT\n    for (let p = children.provisional; p < children.length; p++) {\n      const c = children[p];\n      if (c) c.#markENOENT();\n    }\n  }\n  #markENOENT() {\n    // mark as UNKNOWN and ENOENT\n    if (this.#type & ENOENT) return;\n    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;\n    this.#markChildrenENOENT();\n  }\n  #markChildrenENOENT() {\n    // all children are provisional and do not exist\n    const children = this.children();\n    children.provisional = 0;\n    for (const p of children) {\n      p.#markENOENT();\n    }\n  }\n  #markENOREALPATH() {\n    this.#type |= ENOREALPATH;\n    this.#markENOTDIR();\n  }\n  // save the information when we know the entry is not a dir\n  #markENOTDIR() {\n    // entry is not a directory, so any children can't exist.\n    // this *should* be impossible, since any children created\n    // after it's been marked ENOTDIR should be marked ENOENT,\n    // so it won't even get to this point.\n    /* c8 ignore start */\n    if (this.#type & ENOTDIR) return;\n    /* c8 ignore stop */\n    let t = this.#type;\n    // this could happen if we stat a dir, then delete it,\n    // then try to read it or one of its children.\n    if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN;\n    this.#type = t | ENOTDIR;\n    this.#markChildrenENOENT();\n  }\n  #readdirFail(code = '') {\n    // markENOTDIR and markENOENT also set provisional=0\n    if (code === 'ENOTDIR' || code === 'EPERM') {\n      this.#markENOTDIR();\n    } else if (code === 'ENOENT') {\n      this.#markENOENT();\n    } else {\n      this.children().provisional = 0;\n    }\n  }\n  #lstatFail(code = '') {\n    // Windows just raises ENOENT in this case, disable for win CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR') {\n      // already know it has a parent by this point\n      const p = this.parent;\n      p.#markENOTDIR();\n    } else if (code === 'ENOENT') {\n      /* c8 ignore stop */\n      this.#markENOENT();\n    }\n  }\n  #readlinkFail(code = '') {\n    let ter = this.#type;\n    ter |= ENOREADLINK;\n    if (code === 'ENOENT') ter |= ENOENT;\n    // windows gets a weird error when you try to readlink a file\n    if (code === 'EINVAL' || code === 'UNKNOWN') {\n      // exists, but not a symlink, we don't know WHAT it is, so remove\n      // all IFMT bits.\n      ter &= IFMT_UNKNOWN;\n    }\n    this.#type = ter;\n    // windows just gets ENOENT in this case.  We do cover the case,\n    // just disabled because it's impossible on Windows CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR' && this.parent) {\n      this.parent.#markENOTDIR();\n    }\n    /* c8 ignore stop */\n  }\n  #readdirAddChild(e, c) {\n    return this.#readdirMaybePromoteChild(e, c) || this.#readdirAddNewChild(e, c);\n  }\n  #readdirAddNewChild(e, c) {\n    // alloc new entry at head, so it's never provisional\n    const type = entToType(e);\n    const child = this.newChild(e.name, type, {\n      parent: this\n    });\n    const ifmt = child.#type & IFMT;\n    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n      child.#type |= ENOTDIR;\n    }\n    c.unshift(child);\n    c.provisional++;\n    return child;\n  }\n  #readdirMaybePromoteChild(e, c) {\n    for (let p = c.provisional; p < c.length; p++) {\n      const pchild = c[p];\n      const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);\n      if (name !== pchild.#matchName) {\n        continue;\n      }\n      return this.#readdirPromoteChild(e, pchild, p, c);\n    }\n  }\n  #readdirPromoteChild(e, p, index, c) {\n    const v = p.name;\n    // retain any other flags, but set ifmt from dirent\n    p.#type = p.#type & IFMT_UNKNOWN | entToType(e);\n    // case sensitivity fixing when we learn the true name.\n    if (v !== e.name) p.name = e.name;\n    // just advance provisional index (potentially off the list),\n    // otherwise we have to splice/pop it out and re-insert at head\n    if (index !== c.provisional) {\n      if (index === c.length - 1) c.pop();else c.splice(index, 1);\n      c.unshift(p);\n    }\n    c.provisional++;\n    return p;\n  }\n  /**\n   * Call lstat() on this Path, and update all known information that can be\n   * determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat() {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));\n        return this;\n      } catch (er) {\n        this.#lstatFail(er.code);\n      }\n    }\n  }\n  /**\n   * synchronous {@link PathBase.lstat}\n   */\n  lstatSync() {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(this.#fs.lstatSync(this.fullpath()));\n        return this;\n      } catch (er) {\n        this.#lstatFail(er.code);\n      }\n    }\n  }\n  #applyStat(st) {\n    const {\n      atime,\n      atimeMs,\n      birthtime,\n      birthtimeMs,\n      blksize,\n      blocks,\n      ctime,\n      ctimeMs,\n      dev,\n      gid,\n      ino,\n      mode,\n      mtime,\n      mtimeMs,\n      nlink,\n      rdev,\n      size,\n      uid\n    } = st;\n    this.#atime = atime;\n    this.#atimeMs = atimeMs;\n    this.#birthtime = birthtime;\n    this.#birthtimeMs = birthtimeMs;\n    this.#blksize = blksize;\n    this.#blocks = blocks;\n    this.#ctime = ctime;\n    this.#ctimeMs = ctimeMs;\n    this.#dev = dev;\n    this.#gid = gid;\n    this.#ino = ino;\n    this.#mode = mode;\n    this.#mtime = mtime;\n    this.#mtimeMs = mtimeMs;\n    this.#nlink = nlink;\n    this.#rdev = rdev;\n    this.#size = size;\n    this.#uid = uid;\n    const ifmt = entToType(st);\n    // retain any other flags, but set the ifmt\n    this.#type = this.#type & IFMT_UNKNOWN | ifmt | LSTAT_CALLED;\n    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n      this.#type |= ENOTDIR;\n    }\n  }\n  #onReaddirCB = [];\n  #readdirCBInFlight = false;\n  #callOnReaddirCB(children) {\n    this.#readdirCBInFlight = false;\n    const cbs = this.#onReaddirCB.slice();\n    this.#onReaddirCB.length = 0;\n    cbs.forEach(cb => cb(null, children));\n  }\n  /**\n   * Standard node-style callback interface to get list of directory entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * @param cb The callback called with (er, entries).  Note that the `er`\n   * param is somewhat extraneous, as all readdir() errors are handled and\n   * simply result in an empty set of entries being returned.\n   * @param allowZalgo Boolean indicating that immediately known results should\n   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n   * zalgo at your peril, the dark pony lord is devious and unforgiving.\n   */\n  readdirCB(cb, allowZalgo = false) {\n    if (!this.canReaddir()) {\n      if (allowZalgo) cb(null, []);else queueMicrotask(() => cb(null, []));\n      return;\n    }\n    const children = this.children();\n    if (this.calledReaddir()) {\n      const c = children.slice(0, children.provisional);\n      if (allowZalgo) cb(null, c);else queueMicrotask(() => cb(null, c));\n      return;\n    }\n    // don't have to worry about zalgo at this point.\n    this.#onReaddirCB.push(cb);\n    if (this.#readdirCBInFlight) {\n      return;\n    }\n    this.#readdirCBInFlight = true;\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath();\n    this.#fs.readdir(fullpath, {\n      withFileTypes: true\n    }, (er, entries) => {\n      if (er) {\n        this.#readdirFail(er.code);\n        children.provisional = 0;\n      } else {\n        // if we didn't get an error, we always get entries.\n        //@ts-ignore\n        for (const e of entries) {\n          this.#readdirAddChild(e, children);\n        }\n        this.#readdirSuccess(children);\n      }\n      this.#callOnReaddirCB(children.slice(0, children.provisional));\n      return;\n    });\n  }\n  #asyncReaddirInFlight;\n  /**\n   * Return an array of known child entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async readdir() {\n    if (!this.canReaddir()) {\n      return [];\n    }\n    const children = this.children();\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional);\n    }\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath();\n    if (this.#asyncReaddirInFlight) {\n      await this.#asyncReaddirInFlight;\n    } else {\n      /* c8 ignore start */\n      let resolve = () => {};\n      /* c8 ignore stop */\n      this.#asyncReaddirInFlight = new Promise(res => resolve = res);\n      try {\n        for (const e of await this.#fs.promises.readdir(fullpath, {\n          withFileTypes: true\n        })) {\n          this.#readdirAddChild(e, children);\n        }\n        this.#readdirSuccess(children);\n      } catch (er) {\n        this.#readdirFail(er.code);\n        children.provisional = 0;\n      }\n      this.#asyncReaddirInFlight = undefined;\n      resolve();\n    }\n    return children.slice(0, children.provisional);\n  }\n  /**\n   * synchronous {@link PathBase.readdir}\n   */\n  readdirSync() {\n    if (!this.canReaddir()) {\n      return [];\n    }\n    const children = this.children();\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional);\n    }\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath();\n    try {\n      for (const e of this.#fs.readdirSync(fullpath, {\n        withFileTypes: true\n      })) {\n        this.#readdirAddChild(e, children);\n      }\n      this.#readdirSuccess(children);\n    } catch (er) {\n      this.#readdirFail(er.code);\n      children.provisional = 0;\n    }\n    return children.slice(0, children.provisional);\n  }\n  canReaddir() {\n    if (this.#type & ENOCHILD) return false;\n    const ifmt = IFMT & this.#type;\n    // we always set ENOTDIR when setting IFMT, so should be impossible\n    /* c8 ignore start */\n    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n      return false;\n    }\n    /* c8 ignore stop */\n    return true;\n  }\n  shouldWalk(dirs, walkFilter) {\n    return (this.#type & IFDIR) === IFDIR && !(this.#type & ENOCHILD) && !dirs.has(this) && (!walkFilter || walkFilter(this));\n  }\n  /**\n   * Return the Path object corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   * On success, returns a Path object.\n   */\n  async realpath() {\n    if (this.#realpath) return this.#realpath;\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined;\n    try {\n      const rp = await this.#fs.promises.realpath(this.fullpath());\n      return this.#realpath = this.resolve(rp);\n    } catch (_) {\n      this.#markENOREALPATH();\n    }\n  }\n  /**\n   * Synchronous {@link realpath}\n   */\n  realpathSync() {\n    if (this.#realpath) return this.#realpath;\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined;\n    try {\n      const rp = this.#fs.realpathSync(this.fullpath());\n      return this.#realpath = this.resolve(rp);\n    } catch (_) {\n      this.#markENOREALPATH();\n    }\n  }\n  /**\n   * Internal method to mark this Path object as the scurry cwd,\n   * called by {@link PathScurry#chdir}\n   *\n   * @internal\n   */\n  [setAsCwd](oldCwd) {\n    if (oldCwd === this) return;\n    oldCwd.isCWD = false;\n    this.isCWD = true;\n    const changed = new Set([]);\n    let rp = [];\n    let p = this;\n    while (p && p.parent) {\n      changed.add(p);\n      p.#relative = rp.join(this.sep);\n      p.#relativePosix = rp.join('/');\n      p = p.parent;\n      rp.push('..');\n    }\n    // now un-memoize parents of old cwd\n    p = oldCwd;\n    while (p && p.parent && !changed.has(p)) {\n      p.#relative = undefined;\n      p.#relativePosix = undefined;\n      p = p.parent;\n    }\n  }\n}\nexports.PathBase = PathBase;\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nclass PathWin32 extends PathBase {\n  /**\n   * Separator for generating path strings.\n   */\n  sep = '\\\\';\n  /**\n   * Separator for parsing path strings.\n   */\n  splitSep = eitherSep;\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n    super(name, type, root, roots, nocase, children, opts);\n  }\n  /**\n   * @internal\n   */\n  newChild(name, type = UNKNOWN, opts = {}) {\n    return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n  }\n  /**\n   * @internal\n   */\n  getRootString(path) {\n    return node_path_1.win32.parse(path).root;\n  }\n  /**\n   * @internal\n   */\n  getRoot(rootPath) {\n    rootPath = uncToDrive(rootPath.toUpperCase());\n    if (rootPath === this.root.name) {\n      return this.root;\n    }\n    // ok, not that one, check if it matches another we know about\n    for (const [compare, root] of Object.entries(this.roots)) {\n      if (this.sameRoot(rootPath, compare)) {\n        return this.roots[rootPath] = root;\n      }\n    }\n    // otherwise, have to create a new one.\n    return this.roots[rootPath] = new PathScurryWin32(rootPath, this).root;\n  }\n  /**\n   * @internal\n   */\n  sameRoot(rootPath, compare = this.root.name) {\n    // windows can (rarely) have case-sensitive filesystem, but\n    // UNC and drive letters are always case-insensitive, and canonically\n    // represented uppercase.\n    rootPath = rootPath.toUpperCase().replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n    return rootPath === compare;\n  }\n}\nexports.PathWin32 = PathWin32;\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nclass PathPosix extends PathBase {\n  /**\n   * separator for parsing path strings\n   */\n  splitSep = '/';\n  /**\n   * separator for generating path strings\n   */\n  sep = '/';\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n    super(name, type, root, roots, nocase, children, opts);\n  }\n  /**\n   * @internal\n   */\n  getRootString(path) {\n    return path.startsWith('/') ? '/' : '';\n  }\n  /**\n   * @internal\n   */\n  getRoot(_rootPath) {\n    return this.root;\n  }\n  /**\n   * @internal\n   */\n  newChild(name, type = UNKNOWN, opts = {}) {\n    return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n  }\n}\nexports.PathPosix = PathPosix;\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nclass PathScurryBase {\n  /**\n   * The root Path entry for the current working directory of this Scurry\n   */\n  root;\n  /**\n   * The string path for the root of this Scurry's current working directory\n   */\n  rootPath;\n  /**\n   * A collection of all roots encountered, referenced by rootPath\n   */\n  roots;\n  /**\n   * The Path entry corresponding to this PathScurry's current working directory.\n   */\n  cwd;\n  #resolveCache;\n  #resolvePosixCache;\n  #children;\n  /**\n   * Perform path comparisons case-insensitively.\n   *\n   * Defaults true on Darwin and Windows systems, false elsewhere.\n   */\n  nocase;\n  #fs;\n  /**\n   * This class should not be instantiated directly.\n   *\n   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n   *\n   * @internal\n   */\n  constructor(cwd = process.cwd(), pathImpl, sep, {\n    nocase,\n    childrenCacheSize = 16 * 1024,\n    fs = defaultFS\n  } = {}) {\n    this.#fs = fsFromOption(fs);\n    if (cwd instanceof URL || cwd.startsWith('file://')) {\n      cwd = (0, node_url_1.fileURLToPath)(cwd);\n    }\n    // resolve and split root, and then add to the store.\n    // this is the only time we call path.resolve()\n    const cwdPath = pathImpl.resolve(cwd);\n    this.roots = Object.create(null);\n    this.rootPath = this.parseRootPath(cwdPath);\n    this.#resolveCache = new ResolveCache();\n    this.#resolvePosixCache = new ResolveCache();\n    this.#children = new ChildrenCache(childrenCacheSize);\n    const split = cwdPath.substring(this.rootPath.length).split(sep);\n    // resolve('/') leaves '', splits to [''], we don't want that.\n    if (split.length === 1 && !split[0]) {\n      split.pop();\n    }\n    /* c8 ignore start */\n    if (nocase === undefined) {\n      throw new TypeError('must provide nocase setting to PathScurryBase ctor');\n    }\n    /* c8 ignore stop */\n    this.nocase = nocase;\n    this.root = this.newRoot(this.#fs);\n    this.roots[this.rootPath] = this.root;\n    let prev = this.root;\n    let len = split.length - 1;\n    const joinSep = pathImpl.sep;\n    let abs = this.rootPath;\n    let sawFirst = false;\n    for (const part of split) {\n      const l = len--;\n      prev = prev.child(part, {\n        relative: new Array(l).fill('..').join(joinSep),\n        relativePosix: new Array(l).fill('..').join('/'),\n        fullpath: abs += (sawFirst ? '' : joinSep) + part\n      });\n      sawFirst = true;\n    }\n    this.cwd = prev;\n  }\n  /**\n   * Get the depth of a provided path, string, or the cwd\n   */\n  depth(path = this.cwd) {\n    if (typeof path === 'string') {\n      path = this.cwd.resolve(path);\n    }\n    return path.depth();\n  }\n  /**\n   * Return the cache of child entries.  Exposed so subclasses can create\n   * child Path objects in a platform-specific way.\n   *\n   * @internal\n   */\n  childrenCache() {\n    return this.#children;\n  }\n  /**\n   * Resolve one or more path strings to a resolved string\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolve(...paths) {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = '';\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i];\n      if (!p || p === '.') continue;\n      r = r ? `${p}/${r}` : p;\n      if (this.isAbsolute(p)) {\n        break;\n      }\n    }\n    const cached = this.#resolveCache.get(r);\n    if (cached !== undefined) {\n      return cached;\n    }\n    const result = this.cwd.resolve(r).fullpath();\n    this.#resolveCache.set(r, result);\n    return result;\n  }\n  /**\n   * Resolve one or more path strings to a resolved string, returning\n   * the posix path.  Identical to .resolve() on posix systems, but on\n   * windows will return a forward-slash separated UNC path.\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolvePosix(...paths) {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = '';\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i];\n      if (!p || p === '.') continue;\n      r = r ? `${p}/${r}` : p;\n      if (this.isAbsolute(p)) {\n        break;\n      }\n    }\n    const cached = this.#resolvePosixCache.get(r);\n    if (cached !== undefined) {\n      return cached;\n    }\n    const result = this.cwd.resolve(r).fullpathPosix();\n    this.#resolvePosixCache.set(r, result);\n    return result;\n  }\n  /**\n   * find the relative path from the cwd to the supplied path string or entry\n   */\n  relative(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.relative();\n  }\n  /**\n   * find the relative path from the cwd to the supplied path string or\n   * entry, using / as the path delimiter, even on Windows.\n   */\n  relativePosix(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.relativePosix();\n  }\n  /**\n   * Return the basename for the provided string or Path object\n   */\n  basename(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.name;\n  }\n  /**\n   * Return the dirname for the provided string or Path object\n   */\n  dirname(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return (entry.parent || entry).fullpath();\n  }\n  async readdir(entry = this.cwd, opts = {\n    withFileTypes: true\n  }) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes\n    } = opts;\n    if (!entry.canReaddir()) {\n      return [];\n    } else {\n      const p = await entry.readdir();\n      return withFileTypes ? p : p.map(e => e.name);\n    }\n  }\n  readdirSync(entry = this.cwd, opts = {\n    withFileTypes: true\n  }) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true\n    } = opts;\n    if (!entry.canReaddir()) {\n      return [];\n    } else if (withFileTypes) {\n      return entry.readdirSync();\n    } else {\n      return entry.readdirSync().map(e => e.name);\n    }\n  }\n  /**\n   * Call lstat() on the string or Path object, and update all known\n   * information that can be determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.lstat();\n  }\n  /**\n   * synchronous {@link PathScurryBase.lstat}\n   */\n  lstatSync(entry = this.cwd) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    }\n    return entry.lstatSync();\n  }\n  async readlink(entry = this.cwd, {\n    withFileTypes\n  } = {\n    withFileTypes: false\n  }) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes;\n      entry = this.cwd;\n    }\n    const e = await entry.readlink();\n    return withFileTypes ? e : e?.fullpath();\n  }\n  readlinkSync(entry = this.cwd, {\n    withFileTypes\n  } = {\n    withFileTypes: false\n  }) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes;\n      entry = this.cwd;\n    }\n    const e = entry.readlinkSync();\n    return withFileTypes ? e : e?.fullpath();\n  }\n  async realpath(entry = this.cwd, {\n    withFileTypes\n  } = {\n    withFileTypes: false\n  }) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes;\n      entry = this.cwd;\n    }\n    const e = await entry.realpath();\n    return withFileTypes ? e : e?.fullpath();\n  }\n  realpathSync(entry = this.cwd, {\n    withFileTypes\n  } = {\n    withFileTypes: false\n  }) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes;\n      entry = this.cwd;\n    }\n    const e = entry.realpathSync();\n    return withFileTypes ? e : e?.fullpath();\n  }\n  async walk(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = [];\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath());\n    }\n    const dirs = new Set();\n    const walk = (dir, cb) => {\n      dirs.add(dir);\n      dir.readdirCB((er, entries) => {\n        /* c8 ignore start */\n        if (er) {\n          return cb(er);\n        }\n        /* c8 ignore stop */\n        let len = entries.length;\n        if (!len) return cb();\n        const next = () => {\n          if (--len === 0) {\n            cb();\n          }\n        };\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            results.push(withFileTypes ? e : e.fullpath());\n          }\n          if (follow && e.isSymbolicLink()) {\n            e.realpath().then(r => r?.isUnknown() ? r.lstat() : r).then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());\n          } else {\n            if (e.shouldWalk(dirs, walkFilter)) {\n              walk(e, next);\n            } else {\n              next();\n            }\n          }\n        }\n      }, true); // zalgooooooo\n    };\n    const start = entry;\n    return new Promise((res, rej) => {\n      walk(start, er => {\n        /* c8 ignore start */\n        if (er) return rej(er);\n        /* c8 ignore stop */\n        res(results);\n      });\n    });\n  }\n  walkSync(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = [];\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath());\n    }\n    const dirs = new Set([entry]);\n    for (const dir of dirs) {\n      const entries = dir.readdirSync();\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          results.push(withFileTypes ? e : e.fullpath());\n        }\n        let r = e;\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue;\n          if (r.isUnknown()) r.lstatSync();\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r);\n        }\n      }\n    }\n    return results;\n  }\n  /**\n   * Support for `for await`\n   *\n   * Alias for {@link PathScurryBase.iterate}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  [Symbol.asyncIterator]() {\n    return this.iterate();\n  }\n  iterate(entry = this.cwd, options = {}) {\n    // iterating async over the stream is significantly more performant,\n    // especially in the warm-cache scenario, because it buffers up directory\n    // entries in the background instead of waiting for a yield for each one.\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      options = entry;\n      entry = this.cwd;\n    }\n    return this.stream(entry, options)[Symbol.asyncIterator]();\n  }\n  /**\n   * Iterating over a PathScurry performs a synchronous walk.\n   *\n   * Alias for {@link PathScurryBase.iterateSync}\n   */\n  [Symbol.iterator]() {\n    return this.iterateSync();\n  }\n  *iterateSync(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    if (!filter || filter(entry)) {\n      yield withFileTypes ? entry : entry.fullpath();\n    }\n    const dirs = new Set([entry]);\n    for (const dir of dirs) {\n      const entries = dir.readdirSync();\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          yield withFileTypes ? e : e.fullpath();\n        }\n        let r = e;\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue;\n          if (r.isUnknown()) r.lstatSync();\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r);\n        }\n      }\n    }\n  }\n  stream(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = new minipass_1.Minipass({\n      objectMode: true\n    });\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath());\n    }\n    const dirs = new Set();\n    const queue = [entry];\n    let processing = 0;\n    const process = () => {\n      let paused = false;\n      while (!paused) {\n        const dir = queue.shift();\n        if (!dir) {\n          if (processing === 0) results.end();\n          return;\n        }\n        processing++;\n        dirs.add(dir);\n        const onReaddir = (er, entries, didRealpaths = false) => {\n          /* c8 ignore start */\n          if (er) return results.emit('error', er);\n          /* c8 ignore stop */\n          if (follow && !didRealpaths) {\n            const promises = [];\n            for (const e of entries) {\n              if (e.isSymbolicLink()) {\n                promises.push(e.realpath().then(r => r?.isUnknown() ? r.lstat() : r));\n              }\n            }\n            if (promises.length) {\n              Promise.all(promises).then(() => onReaddir(null, entries, true));\n              return;\n            }\n          }\n          for (const e of entries) {\n            if (e && (!filter || filter(e))) {\n              if (!results.write(withFileTypes ? e : e.fullpath())) {\n                paused = true;\n              }\n            }\n          }\n          processing--;\n          for (const e of entries) {\n            const r = e.realpathCached() || e;\n            if (r.shouldWalk(dirs, walkFilter)) {\n              queue.push(r);\n            }\n          }\n          if (paused && !results.flowing) {\n            results.once('drain', process);\n          } else if (!sync) {\n            process();\n          }\n        };\n        // zalgo containment\n        let sync = true;\n        dir.readdirCB(onReaddir, true);\n        sync = false;\n      }\n    };\n    process();\n    return results;\n  }\n  streamSync(entry = this.cwd, opts = {}) {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry);\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry;\n      entry = this.cwd;\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter\n    } = opts;\n    const results = new minipass_1.Minipass({\n      objectMode: true\n    });\n    const dirs = new Set();\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath());\n    }\n    const queue = [entry];\n    let processing = 0;\n    const process = () => {\n      let paused = false;\n      while (!paused) {\n        const dir = queue.shift();\n        if (!dir) {\n          if (processing === 0) results.end();\n          return;\n        }\n        processing++;\n        dirs.add(dir);\n        const entries = dir.readdirSync();\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            if (!results.write(withFileTypes ? e : e.fullpath())) {\n              paused = true;\n            }\n          }\n        }\n        processing--;\n        for (const e of entries) {\n          let r = e;\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue;\n            if (r.isUnknown()) r.lstatSync();\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            queue.push(r);\n          }\n        }\n      }\n      if (paused && !results.flowing) results.once('drain', process);\n    };\n    process();\n    return results;\n  }\n  chdir(path = this.cwd) {\n    const oldCwd = this.cwd;\n    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;\n    this.cwd[setAsCwd](oldCwd);\n  }\n}\nexports.PathScurryBase = PathScurryBase;\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nclass PathScurryWin32 extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep = '\\\\';\n  constructor(cwd = process.cwd(), opts = {}) {\n    const {\n      nocase = true\n    } = opts;\n    super(cwd, node_path_1.win32, '\\\\', {\n      ...opts,\n      nocase\n    });\n    this.nocase = nocase;\n    for (let p = this.cwd; p; p = p.parent) {\n      p.nocase = this.nocase;\n    }\n  }\n  /**\n   * @internal\n   */\n  parseRootPath(dir) {\n    // if the path starts with a single separator, it's not a UNC, and we'll\n    // just get separator as the root, and driveFromUNC will return \\\n    // In that case, mount \\ on the root from the cwd.\n    return node_path_1.win32.parse(dir).root.toUpperCase();\n  }\n  /**\n   * @internal\n   */\n  newRoot(fs) {\n    return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {\n      fs\n    });\n  }\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p) {\n    return p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p);\n  }\n}\nexports.PathScurryWin32 = PathScurryWin32;\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryPosix extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep = '/';\n  constructor(cwd = process.cwd(), opts = {}) {\n    const {\n      nocase = false\n    } = opts;\n    super(cwd, node_path_1.posix, '/', {\n      ...opts,\n      nocase\n    });\n    this.nocase = nocase;\n  }\n  /**\n   * @internal\n   */\n  parseRootPath(_dir) {\n    return '/';\n  }\n  /**\n   * @internal\n   */\n  newRoot(fs) {\n    return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), {\n      fs\n    });\n  }\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p) {\n    return p.startsWith('/');\n  }\n}\nexports.PathScurryPosix = PathScurryPosix;\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryDarwin extends PathScurryPosix {\n  constructor(cwd = process.cwd(), opts = {}) {\n    const {\n      nocase = true\n    } = opts;\n    super(cwd, {\n      ...opts,\n      nocase\n    });\n  }\n}\nexports.PathScurryDarwin = PathScurryDarwin;\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexports.Path = process.platform === 'win32' ? PathWin32 : PathPosix;\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexports.PathScurry = process.platform === 'win32' ? PathScurryWin32 : process.platform === 'darwin' ? PathScurryDarwin : PathScurryPosix;","map":{"version":3,"names":["lru_cache_1","require","node_path_1","node_url_1","fs_1","actualFS","__importStar","realpathSync","native","promises_1","minipass_1","defaultFS","lstatSync","readdir","readdirSync","readlinkSync","promises","lstat","readlink","realpath","fsFromOption","fsOption","uncDriveRegexp","uncToDrive","rootPath","replace","eitherSep","UNKNOWN","IFIFO","IFCHR","IFDIR","IFBLK","IFREG","IFLNK","IFSOCK","IFMT","IFMT_UNKNOWN","READDIR_CALLED","LSTAT_CALLED","ENOTDIR","ENOENT","ENOREADLINK","ENOREALPATH","ENOCHILD","TYPEMASK","entToType","s","isFile","isDirectory","isSymbolicLink","isCharacterDevice","isBlockDevice","isSocket","isFIFO","normalizeCache","Map","normalize","c","get","n","set","normalizeNocaseCache","normalizeNocase","toLowerCase","ResolveCache","LRUCache","constructor","max","exports","ChildrenCache","maxSize","sizeCalculation","a","length","setAsCwd","Symbol","PathBase","name","root","roots","parent","nocase","isCWD","fs","dev","mode","nlink","uid","gid","rdev","blksize","ino","size","blocks","atimeMs","mtimeMs","ctimeMs","birthtimeMs","atime","mtime","ctime","birthtime","matchName","depth","fullpath","fullpathPosix","relative","relativePosix","type","children","linkTarget","parentPath","path","opts","undefined","childrenCache","resolve","getRootString","dir","substring","dirParts","split","splitSep","result","getRoot","resolveParts","#resolveParts","p","part","child","cached","Object","assign","provisional","pathPart","sep","pchild","newChild","canReaddir","push","pv","fp","test","pfpp","fpp","isUnknown","isType","getType","lstatCached","readlinkCached","realpathCached","readdirCached","slice","canReadlink","ifmt","calledReaddir","isENOENT","isNamed","target","read","er","readlinkFail","code","readdirSuccess","#readdirSuccess","markENOENT","#markENOENT","markChildrenENOENT","#markChildrenENOENT","markENOREALPATH","#markENOREALPATH","markENOTDIR","#markENOTDIR","t","readdirFail","#readdirFail","lstatFail","#lstatFail","#readlinkFail","ter","readdirAddChild","#readdirAddChild","e","readdirMaybePromoteChild","readdirAddNewChild","#readdirAddNewChild","unshift","#readdirMaybePromoteChild","readdirPromoteChild","#readdirPromoteChild","index","v","pop","splice","applyStat","#applyStat","st","onReaddirCB","readdirCBInFlight","callOnReaddirCB","#callOnReaddirCB","cbs","forEach","cb","readdirCB","allowZalgo","queueMicrotask","withFileTypes","entries","asyncReaddirInFlight","Promise","res","shouldWalk","dirs","walkFilter","has","rp","_","oldCwd","changed","Set","add","join","PathWin32","win32","parse","toUpperCase","compare","sameRoot","PathScurryWin32","PathPosix","startsWith","_rootPath","PathScurryBase","cwd","resolveCache","resolvePosixCache","process","pathImpl","childrenCacheSize","URL","fileURLToPath","cwdPath","create","parseRootPath","TypeError","newRoot","prev","len","joinSep","abs","sawFirst","l","Array","fill","paths","r","i","isAbsolute","resolvePosix","entry","basename","dirname","map","walk","follow","filter","results","next","then","start","rej","walkSync","asyncIterator","iterate","options","stream","iterator","iterateSync","Minipass","objectMode","write","queue","processing","paused","shift","end","onReaddir","didRealpaths","emit","all","flowing","once","sync","streamSync","chdir","PathScurryPosix","posix","_dir","PathScurryDarwin","Path","platform","PathScurry"],"sources":["E:\\programs\\AI programs\\AIMessageApp\\frontend\\node_modules\\path-scurry\\src\\index.ts"],"sourcesContent":["import { LRUCache } from 'lru-cache'\nimport { posix, win32 } from 'node:path'\n\nimport { fileURLToPath } from 'node:url'\n\nimport {\n  lstatSync,\n  readdir as readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync as rps,\n} from 'fs'\nimport * as actualFS from 'node:fs'\n\nconst realpathSync = rps.native\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\n\nimport { lstat, readdir, readlink, realpath } from 'node:fs/promises'\n\nimport { Minipass } from 'minipass'\nimport type { Dirent, Stats } from 'node:fs'\n\n/**\n * An object that will be used to override the default `fs`\n * methods.  Any methods that are not overridden will use Node's\n * built-in implementations.\n *\n * - lstatSync\n * - readdir (callback `withFileTypes` Dirent variant, used for\n *   readdirCB and most walks)\n * - readdirSync\n * - readlinkSync\n * - realpathSync\n * - promises: Object containing the following async methods:\n *   - lstat\n *   - readdir (Dirent variant only)\n *   - readlink\n *   - realpath\n */\nexport interface FSOption {\n  lstatSync?: (path: string) => Stats\n  readdir?: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any,\n  ) => void\n  readdirSync?: (\n    path: string,\n    options: { withFileTypes: true },\n  ) => Dirent[]\n  readlinkSync?: (path: string) => string\n  realpathSync?: (path: string) => string\n  promises?: {\n    lstat?: (path: string) => Promise<Stats>\n    readdir?: (\n      path: string,\n      options: { withFileTypes: true },\n    ) => Promise<Dirent[]>\n    readlink?: (path: string) => Promise<string>\n    realpath?: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\ninterface FSValue {\n  lstatSync: (path: string) => Stats\n  readdir: (\n    path: string,\n    options: { withFileTypes: true },\n    cb: (er: NodeJS.ErrnoException | null, entries?: Dirent[]) => any,\n  ) => void\n  readdirSync: (path: string, options: { withFileTypes: true }) => Dirent[]\n  readlinkSync: (path: string) => string\n  realpathSync: (path: string) => string\n  promises: {\n    lstat: (path: string) => Promise<Stats>\n    readdir: (\n      path: string,\n      options: { withFileTypes: true },\n    ) => Promise<Dirent[]>\n    readlink: (path: string) => Promise<string>\n    realpath: (path: string) => Promise<string>\n    [k: string]: any\n  }\n  [k: string]: any\n}\n\nconst defaultFS: FSValue = {\n  lstatSync,\n  readdir: readdirCB,\n  readdirSync,\n  readlinkSync,\n  realpathSync,\n  promises: {\n    lstat,\n    readdir,\n    readlink,\n    realpath,\n  },\n}\n\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption?: FSOption): FSValue =>\n  !fsOption || fsOption === defaultFS || fsOption === actualFS ?\n    defaultFS\n  : {\n      ...defaultFS,\n      ...fsOption,\n      promises: {\n        ...defaultFS.promises,\n        ...(fsOption.promises || {}),\n      },\n    }\n\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i\nconst uncToDrive = (rootPath: string): string =>\n  rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\')\n\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/\n\nconst UNKNOWN = 0 // may not even exist, for all we know\nconst IFIFO = 0b0001\nconst IFCHR = 0b0010\nconst IFDIR = 0b0100\nconst IFBLK = 0b0110\nconst IFREG = 0b1000\nconst IFLNK = 0b1010\nconst IFSOCK = 0b1100\nconst IFMT = 0b1111\n\nexport type Type =\n  | 'Unknown'\n  | 'FIFO'\n  | 'CharacterDevice'\n  | 'Directory'\n  | 'BlockDevice'\n  | 'File'\n  | 'SymbolicLink'\n  | 'Socket'\n\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT\n\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 0b0000_0001_0000\n// set after a successful lstat()\nconst LSTAT_CALLED = 0b0000_0010_0000\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 0b0000_0100_0000\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 0b0000_1000_0000\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 0b0001_0000_0000\n// set if we know realpath() will fail\nconst ENOREALPATH = 0b0010_0000_0000\n\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH\nconst TYPEMASK = 0b0011_1111_1111\n\nconst entToType = (s: Dirent | Stats) =>\n  s.isFile() ? IFREG\n  : s.isDirectory() ? IFDIR\n  : s.isSymbolicLink() ? IFLNK\n  : s.isCharacterDevice() ? IFCHR\n  : s.isBlockDevice() ? IFBLK\n  : s.isSocket() ? IFSOCK\n  : s.isFIFO() ? IFIFO\n  : UNKNOWN\n\n// normalize unicode path names\nconst normalizeCache = new Map<string, string>()\nconst normalize = (s: string) => {\n  const c = normalizeCache.get(s)\n  if (c) return c\n  const n = s.normalize('NFKD')\n  normalizeCache.set(s, n)\n  return n\n}\n\nconst normalizeNocaseCache = new Map<string, string>()\nconst normalizeNocase = (s: string) => {\n  const c = normalizeNocaseCache.get(s)\n  if (c) return c\n  const n = normalize(s.toLowerCase())\n  normalizeNocaseCache.set(s, n)\n  return n\n}\n\n/**\n * Options that may be provided to the Path constructor\n */\nexport interface PathOpts {\n  fullpath?: string\n  relative?: string\n  relativePosix?: string\n  parent?: PathBase\n  /**\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nexport class ResolveCache extends LRUCache<string, string> {\n  constructor() {\n    super({ max: 256 })\n  }\n}\n\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nexport class ChildrenCache extends LRUCache<PathBase, Children> {\n  constructor(maxSize: number = 16 * 1024) {\n    super({\n      maxSize,\n      // parent + children\n      sizeCalculation: a => a.length + 1,\n    })\n  }\n}\n\n/**\n * Array of Path objects, plus a marker indicating the first provisional entry\n *\n * @internal\n */\nexport type Children = PathBase[] & { provisional: number }\n\nconst setAsCwd = Symbol('PathScurry setAsCwd')\n\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nexport abstract class PathBase implements Dirent {\n  /**\n   * the basename of this path\n   *\n   * **Important**: *always* test the path name against any test string\n   * usingthe {@link isNamed} method, and not by directly comparing this\n   * string. Otherwise, unicode path strings that the system sees as identical\n   * will not be properly treated as the same path, leading to incorrect\n   * behavior and possible security issues.\n   */\n  name: string\n  /**\n   * the Path entry corresponding to the path root.\n   *\n   * @internal\n   */\n  root: PathBase\n  /**\n   * All roots found within the current PathScurry family\n   *\n   * @internal\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * a reference to the parent path, or undefined in the case of root entries\n   *\n   * @internal\n   */\n  parent?: PathBase\n  /**\n   * boolean indicating whether paths are compared case-insensitively\n   * @internal\n   */\n  nocase: boolean\n\n  /**\n   * boolean indicating that this path is the current working directory\n   * of the PathScurry collection that contains it.\n   */\n  isCWD: boolean = false\n\n  /**\n   * the string or regexp used to split paths. On posix, it is `'/'`, and on\n   * windows it is a RegExp matching either `'/'` or `'\\\\'`\n   */\n  abstract splitSep: string | RegExp\n  /**\n   * The path separator string to use when joining paths\n   */\n  abstract sep: string\n\n  // potential default fs override\n  #fs: FSValue\n\n  // Stats fields\n  #dev?: number\n  get dev() {\n    return this.#dev\n  }\n  #mode?: number\n  get mode() {\n    return this.#mode\n  }\n  #nlink?: number\n  get nlink() {\n    return this.#nlink\n  }\n  #uid?: number\n  get uid() {\n    return this.#uid\n  }\n  #gid?: number\n  get gid() {\n    return this.#gid\n  }\n  #rdev?: number\n  get rdev() {\n    return this.#rdev\n  }\n  #blksize?: number\n  get blksize() {\n    return this.#blksize\n  }\n  #ino?: number\n  get ino() {\n    return this.#ino\n  }\n  #size?: number\n  get size() {\n    return this.#size\n  }\n  #blocks?: number\n  get blocks() {\n    return this.#blocks\n  }\n  #atimeMs?: number\n  get atimeMs() {\n    return this.#atimeMs\n  }\n  #mtimeMs?: number\n  get mtimeMs() {\n    return this.#mtimeMs\n  }\n  #ctimeMs?: number\n  get ctimeMs() {\n    return this.#ctimeMs\n  }\n  #birthtimeMs?: number\n  get birthtimeMs() {\n    return this.#birthtimeMs\n  }\n  #atime?: Date\n  get atime() {\n    return this.#atime\n  }\n  #mtime?: Date\n  get mtime() {\n    return this.#mtime\n  }\n  #ctime?: Date\n  get ctime() {\n    return this.#ctime\n  }\n  #birthtime?: Date\n  get birthtime() {\n    return this.#birthtime\n  }\n\n  #matchName: string\n  #depth?: number\n  #fullpath?: string\n  #fullpathPosix?: string\n  #relative?: string\n  #relativePosix?: string\n  #type: number\n  #children: ChildrenCache\n  #linkTarget?: PathBase\n  #realpath?: PathBase\n\n  /**\n   * This property is for compatibility with the Dirent class as of\n   * Node v20, where Dirent['parentPath'] refers to the path of the\n   * directory that was passed to readdir. For root entries, it's the path\n   * to the entry itself.\n   */\n  get parentPath(): string {\n    return (this.parent || this).fullpath()\n  }\n\n  /**\n   * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,\n   * this property refers to the *parent* path, not the path object itself.\n   *\n   * @deprecated\n   */\n  get path(): string {\n    return this.parentPath\n  }\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts,\n  ) {\n    this.name = name\n    this.#matchName = nocase ? normalizeNocase(name) : normalize(name)\n    this.#type = type & TYPEMASK\n    this.nocase = nocase\n    this.roots = roots\n    this.root = root || this\n    this.#children = children\n    this.#fullpath = opts.fullpath\n    this.#relative = opts.relative\n    this.#relativePosix = opts.relativePosix\n    this.parent = opts.parent\n    if (this.parent) {\n      this.#fs = this.parent.#fs\n    } else {\n      this.#fs = fsFromOption(opts.fs)\n    }\n  }\n\n  /**\n   * Returns the depth of the Path object from its root.\n   *\n   * For example, a path at `/foo/bar` would have a depth of 2.\n   */\n  depth(): number {\n    if (this.#depth !== undefined) return this.#depth\n    if (!this.parent) return (this.#depth = 0)\n    return (this.#depth = this.parent.depth() + 1)\n  }\n\n  /**\n   * @internal\n   */\n  abstract getRootString(path: string): string\n  /**\n   * @internal\n   */\n  abstract getRoot(rootPath: string): PathBase\n  /**\n   * @internal\n   */\n  abstract newChild(name: string, type?: number, opts?: PathOpts): PathBase\n\n  /**\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Get the Path object referenced by the string path, resolved from this Path\n   */\n  resolve(path?: string): PathBase {\n    if (!path) {\n      return this\n    }\n    const rootPath = this.getRootString(path)\n    const dir = path.substring(rootPath.length)\n    const dirParts = dir.split(this.splitSep)\n    const result: PathBase =\n      rootPath ?\n        this.getRoot(rootPath).#resolveParts(dirParts)\n      : this.#resolveParts(dirParts)\n    return result\n  }\n\n  #resolveParts(dirParts: string[]) {\n    let p: PathBase = this\n    for (const part of dirParts) {\n      p = p.child(part)\n    }\n    return p\n  }\n\n  /**\n   * Returns the cached children Path objects, if still available.  If they\n   * have fallen out of the cache, then returns an empty array, and resets the\n   * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n   * lookup.\n   *\n   * @internal\n   */\n  children(): Children {\n    const cached = this.#children.get(this)\n    if (cached) {\n      return cached\n    }\n    const children: Children = Object.assign([], { provisional: 0 })\n    this.#children.set(this, children)\n    this.#type &= ~READDIR_CALLED\n    return children\n  }\n\n  /**\n   * Resolves a path portion and returns or creates the child Path.\n   *\n   * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n   * `'..'`.\n   *\n   * This should not be called directly.  If `pathPart` contains any path\n   * separators, it will lead to unsafe undefined behavior.\n   *\n   * Use `Path.resolve()` instead.\n   *\n   * @internal\n   */\n  child(pathPart: string, opts?: PathOpts): PathBase {\n    if (pathPart === '' || pathPart === '.') {\n      return this\n    }\n    if (pathPart === '..') {\n      return this.parent || this\n    }\n\n    // find the child\n    const children = this.children()\n    const name =\n      this.nocase ? normalizeNocase(pathPart) : normalize(pathPart)\n    for (const p of children) {\n      if (p.#matchName === name) {\n        return p\n      }\n    }\n\n    // didn't find it, create provisional child, since it might not\n    // actually exist.  If we know the parent isn't a dir, then\n    // in fact it CAN'T exist.\n    const s = this.parent ? this.sep : ''\n    const fullpath =\n      this.#fullpath ? this.#fullpath + s + pathPart : undefined\n    const pchild = this.newChild(pathPart, UNKNOWN, {\n      ...opts,\n      parent: this,\n      fullpath,\n    })\n\n    if (!this.canReaddir()) {\n      pchild.#type |= ENOENT\n    }\n\n    // don't have to update provisional, because if we have real children,\n    // then provisional is set to children.length, otherwise a lower number\n    children.push(pchild)\n    return pchild\n  }\n\n  /**\n   * The relative path from the cwd. If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpath()\n   */\n  relative(): string {\n    if (this.isCWD) return ''\n    if (this.#relative !== undefined) {\n      return this.#relative\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relative = this.name)\n    }\n    const pv = p.relative()\n    return pv + (!pv || !p.parent ? '' : this.sep) + name\n  }\n\n  /**\n   * The relative path from the cwd, using / as the path separator.\n   * If it does not share an ancestor with\n   * the cwd, then this ends up being equivalent to the fullpathPosix()\n   * On posix systems, this is identical to relative().\n   */\n  relativePosix(): string {\n    if (this.sep === '/') return this.relative()\n    if (this.isCWD) return ''\n    if (this.#relativePosix !== undefined) return this.#relativePosix\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#relativePosix = this.fullpathPosix())\n    }\n    const pv = p.relativePosix()\n    return pv + (!pv || !p.parent ? '' : '/') + name\n  }\n\n  /**\n   * The fully resolved path string for this Path entry\n   */\n  fullpath(): string {\n    if (this.#fullpath !== undefined) {\n      return this.#fullpath\n    }\n    const name = this.name\n    const p = this.parent\n    if (!p) {\n      return (this.#fullpath = this.name)\n    }\n    const pv = p.fullpath()\n    const fp = pv + (!p.parent ? '' : this.sep) + name\n    return (this.#fullpath = fp)\n  }\n\n  /**\n   * On platforms other than windows, this is identical to fullpath.\n   *\n   * On windows, this is overridden to return the forward-slash form of the\n   * full UNC path.\n   */\n  fullpathPosix(): string {\n    if (this.#fullpathPosix !== undefined) return this.#fullpathPosix\n    if (this.sep === '/') return (this.#fullpathPosix = this.fullpath())\n    if (!this.parent) {\n      const p = this.fullpath().replace(/\\\\/g, '/')\n      if (/^[a-z]:\\//i.test(p)) {\n        return (this.#fullpathPosix = `//?/${p}`)\n      } else {\n        return (this.#fullpathPosix = p)\n      }\n    }\n    const p = this.parent\n    const pfpp = p.fullpathPosix()\n    const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name\n    return (this.#fullpathPosix = fpp)\n  }\n\n  /**\n   * Is the Path of an unknown type?\n   *\n   * Note that we might know *something* about it if there has been a previous\n   * filesystem operation, for example that it does not exist, or is not a\n   * link, or whether it has child entries.\n   */\n  isUnknown(): boolean {\n    return (this.#type & IFMT) === UNKNOWN\n  }\n\n  isType(type: Type): boolean {\n    return this[`is${type}`]()\n  }\n\n  getType(): Type {\n    return (\n      this.isUnknown() ? 'Unknown'\n      : this.isDirectory() ? 'Directory'\n      : this.isFile() ? 'File'\n      : this.isSymbolicLink() ? 'SymbolicLink'\n      : this.isFIFO() ? 'FIFO'\n      : this.isCharacterDevice() ? 'CharacterDevice'\n      : this.isBlockDevice() ? 'BlockDevice'\n      : /* c8 ignore start */ this.isSocket() ? 'Socket'\n      : 'Unknown'\n    )\n    /* c8 ignore stop */\n  }\n\n  /**\n   * Is the Path a regular file?\n   */\n  isFile(): boolean {\n    return (this.#type & IFMT) === IFREG\n  }\n\n  /**\n   * Is the Path a directory?\n   */\n  isDirectory(): boolean {\n    return (this.#type & IFMT) === IFDIR\n  }\n\n  /**\n   * Is the path a character device?\n   */\n  isCharacterDevice(): boolean {\n    return (this.#type & IFMT) === IFCHR\n  }\n\n  /**\n   * Is the path a block device?\n   */\n  isBlockDevice(): boolean {\n    return (this.#type & IFMT) === IFBLK\n  }\n\n  /**\n   * Is the path a FIFO pipe?\n   */\n  isFIFO(): boolean {\n    return (this.#type & IFMT) === IFIFO\n  }\n\n  /**\n   * Is the path a socket?\n   */\n  isSocket(): boolean {\n    return (this.#type & IFMT) === IFSOCK\n  }\n\n  /**\n   * Is the path a symbolic link?\n   */\n  isSymbolicLink(): boolean {\n    return (this.#type & IFLNK) === IFLNK\n  }\n\n  /**\n   * Return the entry if it has been subject of a successful lstat, or\n   * undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* simply\n   * mean that we haven't called lstat on it.\n   */\n  lstatCached(): PathBase | undefined {\n    return this.#type & LSTAT_CALLED ? this : undefined\n  }\n\n  /**\n   * Return the cached link target if the entry has been the subject of a\n   * successful readlink, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readlink() has been called at some point.\n   */\n  readlinkCached(): PathBase | undefined {\n    return this.#linkTarget\n  }\n\n  /**\n   * Returns the cached realpath target if the entry has been the subject\n   * of a successful realpath, or undefined otherwise.\n   *\n   * Does not read the filesystem, so an undefined result *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * realpath() has been called at some point.\n   */\n  realpathCached(): PathBase | undefined {\n    return this.#realpath\n  }\n\n  /**\n   * Returns the cached child Path entries array if the entry has been the\n   * subject of a successful readdir(), or [] otherwise.\n   *\n   * Does not read the filesystem, so an empty array *could* just mean we\n   * don't have any cached data. Only use it if you are very sure that a\n   * readdir() has been called recently enough to still be valid.\n   */\n  readdirCached(): PathBase[] {\n    const children = this.children()\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n   * any indication that readlink will definitely fail.\n   *\n   * Returns false if the path is known to not be a symlink, if a previous\n   * readlink failed, or if the entry does not exist.\n   */\n  canReadlink(): boolean {\n    if (this.#linkTarget) return true\n    if (!this.parent) return false\n    // cases where it cannot possibly succeed\n    const ifmt = this.#type & IFMT\n    return !(\n      (ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n      this.#type & ENOREADLINK ||\n      this.#type & ENOENT\n    )\n  }\n\n  /**\n   * Return true if readdir has previously been successfully called on this\n   * path, indicating that cachedReaddir() is likely valid.\n   */\n  calledReaddir(): boolean {\n    return !!(this.#type & READDIR_CALLED)\n  }\n\n  /**\n   * Returns true if the path is known to not exist. That is, a previous lstat\n   * or readdir failed to verify its existence when that would have been\n   * expected, or a parent entry was marked either enoent or enotdir.\n   */\n  isENOENT(): boolean {\n    return !!(this.#type & ENOENT)\n  }\n\n  /**\n   * Return true if the path is a match for the given path name.  This handles\n   * case sensitivity and unicode normalization.\n   *\n   * Note: even on case-sensitive systems, it is **not** safe to test the\n   * equality of the `.name` property to determine whether a given pathname\n   * matches, due to unicode normalization mismatches.\n   *\n   * Always use this method instead of testing the `path.name` property\n   * directly.\n   */\n  isNamed(n: string): boolean {\n    return !this.nocase ?\n        this.#matchName === normalize(n)\n      : this.#matchName === normalizeNocase(n)\n  }\n\n  /**\n   * Return the Path object corresponding to the target of a symbolic link.\n   *\n   * If the Path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   */\n  async readlink(): Promise<PathBase | undefined> {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = await this.#fs.promises.readlink(this.fullpath())\n      const linkTarget = (await this.parent.realpath())?.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  /**\n   * Synchronous {@link PathBase.readlink}\n   */\n  readlinkSync(): PathBase | undefined {\n    const target = this.#linkTarget\n    if (target) {\n      return target\n    }\n    if (!this.canReadlink()) {\n      return undefined\n    }\n    /* c8 ignore start */\n    // already covered by the canReadlink test, here for ts grumples\n    if (!this.parent) {\n      return undefined\n    }\n    /* c8 ignore stop */\n    try {\n      const read = this.#fs.readlinkSync(this.fullpath())\n      const linkTarget = this.parent.realpathSync()?.resolve(read)\n      if (linkTarget) {\n        return (this.#linkTarget = linkTarget)\n      }\n    } catch (er) {\n      this.#readlinkFail((er as NodeJS.ErrnoException).code)\n      return undefined\n    }\n  }\n\n  #readdirSuccess(children: Children) {\n    // succeeded, mark readdir called bit\n    this.#type |= READDIR_CALLED\n    // mark all remaining provisional children as ENOENT\n    for (let p = children.provisional; p < children.length; p++) {\n      const c = children[p]\n      if (c) c.#markENOENT()\n    }\n  }\n\n  #markENOENT() {\n    // mark as UNKNOWN and ENOENT\n    if (this.#type & ENOENT) return\n    this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN\n    this.#markChildrenENOENT()\n  }\n\n  #markChildrenENOENT() {\n    // all children are provisional and do not exist\n    const children = this.children()\n    children.provisional = 0\n    for (const p of children) {\n      p.#markENOENT()\n    }\n  }\n\n  #markENOREALPATH() {\n    this.#type |= ENOREALPATH\n    this.#markENOTDIR()\n  }\n\n  // save the information when we know the entry is not a dir\n  #markENOTDIR() {\n    // entry is not a directory, so any children can't exist.\n    // this *should* be impossible, since any children created\n    // after it's been marked ENOTDIR should be marked ENOENT,\n    // so it won't even get to this point.\n    /* c8 ignore start */\n    if (this.#type & ENOTDIR) return\n    /* c8 ignore stop */\n    let t = this.#type\n    // this could happen if we stat a dir, then delete it,\n    // then try to read it or one of its children.\n    if ((t & IFMT) === IFDIR) t &= IFMT_UNKNOWN\n    this.#type = t | ENOTDIR\n    this.#markChildrenENOENT()\n  }\n\n  #readdirFail(code: string = '') {\n    // markENOTDIR and markENOENT also set provisional=0\n    if (code === 'ENOTDIR' || code === 'EPERM') {\n      this.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      this.#markENOENT()\n    } else {\n      this.children().provisional = 0\n    }\n  }\n\n  #lstatFail(code: string = '') {\n    // Windows just raises ENOENT in this case, disable for win CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR') {\n      // already know it has a parent by this point\n      const p = this.parent as PathBase\n      p.#markENOTDIR()\n    } else if (code === 'ENOENT') {\n      /* c8 ignore stop */\n      this.#markENOENT()\n    }\n  }\n\n  #readlinkFail(code: string = '') {\n    let ter = this.#type\n    ter |= ENOREADLINK\n    if (code === 'ENOENT') ter |= ENOENT\n    // windows gets a weird error when you try to readlink a file\n    if (code === 'EINVAL' || code === 'UNKNOWN') {\n      // exists, but not a symlink, we don't know WHAT it is, so remove\n      // all IFMT bits.\n      ter &= IFMT_UNKNOWN\n    }\n    this.#type = ter\n    // windows just gets ENOENT in this case.  We do cover the case,\n    // just disabled because it's impossible on Windows CI\n    /* c8 ignore start */\n    if (code === 'ENOTDIR' && this.parent) {\n      this.parent.#markENOTDIR()\n    }\n    /* c8 ignore stop */\n  }\n\n  #readdirAddChild(e: Dirent, c: Children) {\n    return (\n      this.#readdirMaybePromoteChild(e, c) ||\n      this.#readdirAddNewChild(e, c)\n    )\n  }\n\n  #readdirAddNewChild(e: Dirent, c: Children): PathBase {\n    // alloc new entry at head, so it's never provisional\n    const type = entToType(e)\n    const child = this.newChild(e.name, type, { parent: this })\n    const ifmt = child.#type & IFMT\n    if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n      child.#type |= ENOTDIR\n    }\n    c.unshift(child)\n    c.provisional++\n    return child\n  }\n\n  #readdirMaybePromoteChild(e: Dirent, c: Children): PathBase | undefined {\n    for (let p = c.provisional; p < c.length; p++) {\n      const pchild = c[p]\n      const name =\n        this.nocase ? normalizeNocase(e.name) : normalize(e.name)\n      if (name !== pchild!.#matchName) {\n        continue\n      }\n\n      return this.#readdirPromoteChild(e, pchild!, p, c)\n    }\n  }\n\n  #readdirPromoteChild(\n    e: Dirent,\n    p: PathBase,\n    index: number,\n    c: Children,\n  ): PathBase {\n    const v = p.name\n    // retain any other flags, but set ifmt from dirent\n    p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e)\n    // case sensitivity fixing when we learn the true name.\n    if (v !== e.name) p.name = e.name\n\n    // just advance provisional index (potentially off the list),\n    // otherwise we have to splice/pop it out and re-insert at head\n    if (index !== c.provisional) {\n      if (index === c.length - 1) c.pop()\n      else c.splice(index, 1)\n      c.unshift(p)\n    }\n    c.provisional++\n    return p\n  }\n\n  /**\n   * Call lstat() on this Path, and update all known information that can be\n   * determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(): Promise<PathBase | undefined> {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(await this.#fs.promises.lstat(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  /**\n   * synchronous {@link PathBase.lstat}\n   */\n  lstatSync(): PathBase | undefined {\n    if ((this.#type & ENOENT) === 0) {\n      try {\n        this.#applyStat(this.#fs.lstatSync(this.fullpath()))\n        return this\n      } catch (er) {\n        this.#lstatFail((er as NodeJS.ErrnoException).code)\n      }\n    }\n  }\n\n  #applyStat(st: Stats) {\n    const {\n      atime,\n      atimeMs,\n      birthtime,\n      birthtimeMs,\n      blksize,\n      blocks,\n      ctime,\n      ctimeMs,\n      dev,\n      gid,\n      ino,\n      mode,\n      mtime,\n      mtimeMs,\n      nlink,\n      rdev,\n      size,\n      uid,\n    } = st\n    this.#atime = atime\n    this.#atimeMs = atimeMs\n    this.#birthtime = birthtime\n    this.#birthtimeMs = birthtimeMs\n    this.#blksize = blksize\n    this.#blocks = blocks\n    this.#ctime = ctime\n    this.#ctimeMs = ctimeMs\n    this.#dev = dev\n    this.#gid = gid\n    this.#ino = ino\n    this.#mode = mode\n    this.#mtime = mtime\n    this.#mtimeMs = mtimeMs\n    this.#nlink = nlink\n    this.#rdev = rdev\n    this.#size = size\n    this.#uid = uid\n    const ifmt = entToType(st)\n    // retain any other flags, but set the ifmt\n    this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED\n    if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n      this.#type |= ENOTDIR\n    }\n  }\n\n  #onReaddirCB: ((\n    er: NodeJS.ErrnoException | null,\n    entries: Path[],\n  ) => any)[] = []\n  #readdirCBInFlight: boolean = false\n  #callOnReaddirCB(children: Path[]) {\n    this.#readdirCBInFlight = false\n    const cbs = this.#onReaddirCB.slice()\n    this.#onReaddirCB.length = 0\n    cbs.forEach(cb => cb(null, children))\n  }\n\n  /**\n   * Standard node-style callback interface to get list of directory entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * @param cb The callback called with (er, entries).  Note that the `er`\n   * param is somewhat extraneous, as all readdir() errors are handled and\n   * simply result in an empty set of entries being returned.\n   * @param allowZalgo Boolean indicating that immediately known results should\n   * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n   * zalgo at your peril, the dark pony lord is devious and unforgiving.\n   */\n  readdirCB(\n    cb: (er: NodeJS.ErrnoException | null, entries: PathBase[]) => any,\n    allowZalgo: boolean = false,\n  ): void {\n    if (!this.canReaddir()) {\n      if (allowZalgo) cb(null, [])\n      else queueMicrotask(() => cb(null, []))\n      return\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      const c = children.slice(0, children.provisional)\n      if (allowZalgo) cb(null, c)\n      else queueMicrotask(() => cb(null, c))\n      return\n    }\n\n    // don't have to worry about zalgo at this point.\n    this.#onReaddirCB.push(cb)\n    if (this.#readdirCBInFlight) {\n      return\n    }\n    this.#readdirCBInFlight = true\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n      if (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      } else {\n        // if we didn't get an error, we always get entries.\n        //@ts-ignore\n        for (const e of entries) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      }\n      this.#callOnReaddirCB(children.slice(0, children.provisional))\n      return\n    })\n  }\n\n  #asyncReaddirInFlight?: Promise<void>\n\n  /**\n   * Return an array of known child entries.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async readdir(): Promise<PathBase[]> {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    if (this.#asyncReaddirInFlight) {\n      await this.#asyncReaddirInFlight\n    } else {\n      /* c8 ignore start */\n      let resolve: () => void = () => {}\n      /* c8 ignore stop */\n      this.#asyncReaddirInFlight = new Promise<void>(\n        res => (resolve = res),\n      )\n      try {\n        for (const e of await this.#fs.promises.readdir(fullpath, {\n          withFileTypes: true,\n        })) {\n          this.#readdirAddChild(e, children)\n        }\n        this.#readdirSuccess(children)\n      } catch (er) {\n        this.#readdirFail((er as NodeJS.ErrnoException).code)\n        children.provisional = 0\n      }\n      this.#asyncReaddirInFlight = undefined\n      resolve()\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  /**\n   * synchronous {@link PathBase.readdir}\n   */\n  readdirSync(): PathBase[] {\n    if (!this.canReaddir()) {\n      return []\n    }\n\n    const children = this.children()\n    if (this.calledReaddir()) {\n      return children.slice(0, children.provisional)\n    }\n\n    // else read the directory, fill up children\n    // de-provisionalize any provisional children.\n    const fullpath = this.fullpath()\n    try {\n      for (const e of this.#fs.readdirSync(fullpath, {\n        withFileTypes: true,\n      })) {\n        this.#readdirAddChild(e, children)\n      }\n      this.#readdirSuccess(children)\n    } catch (er) {\n      this.#readdirFail((er as NodeJS.ErrnoException).code)\n      children.provisional = 0\n    }\n    return children.slice(0, children.provisional)\n  }\n\n  canReaddir() {\n    if (this.#type & ENOCHILD) return false\n    const ifmt = IFMT & this.#type\n    // we always set ENOTDIR when setting IFMT, so should be impossible\n    /* c8 ignore start */\n    if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n      return false\n    }\n    /* c8 ignore stop */\n    return true\n  }\n\n  shouldWalk(\n    dirs: Set<PathBase | undefined>,\n    walkFilter?: (e: PathBase) => boolean,\n  ): boolean {\n    return (\n      (this.#type & IFDIR) === IFDIR &&\n      !(this.#type & ENOCHILD) &&\n      !dirs.has(this) &&\n      (!walkFilter || walkFilter(this))\n    )\n  }\n\n  /**\n   * Return the Path object corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   * On success, returns a Path object.\n   */\n  async realpath(): Promise<PathBase | undefined> {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = await this.#fs.promises.realpath(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Synchronous {@link realpath}\n   */\n  realpathSync(): PathBase | undefined {\n    if (this.#realpath) return this.#realpath\n    if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type) return undefined\n    try {\n      const rp = this.#fs.realpathSync(this.fullpath())\n      return (this.#realpath = this.resolve(rp))\n    } catch (_) {\n      this.#markENOREALPATH()\n    }\n  }\n\n  /**\n   * Internal method to mark this Path object as the scurry cwd,\n   * called by {@link PathScurry#chdir}\n   *\n   * @internal\n   */\n  [setAsCwd](oldCwd: PathBase): void {\n    if (oldCwd === this) return\n    oldCwd.isCWD = false\n    this.isCWD = true\n\n    const changed = new Set<PathBase>([])\n    let rp = []\n    let p: PathBase = this\n    while (p && p.parent) {\n      changed.add(p)\n      p.#relative = rp.join(this.sep)\n      p.#relativePosix = rp.join('/')\n      p = p.parent\n      rp.push('..')\n    }\n    // now un-memoize parents of old cwd\n    p = oldCwd\n    while (p && p.parent && !changed.has(p)) {\n      p.#relative = undefined\n      p.#relativePosix = undefined\n      p = p.parent\n    }\n  }\n}\n\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nexport class PathWin32 extends PathBase {\n  /**\n   * Separator for generating path strings.\n   */\n  sep: '\\\\' = '\\\\'\n  /**\n   * Separator for parsing path strings.\n   */\n  splitSep: RegExp = eitherSep\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts,\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathWin32(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts,\n    )\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return win32.parse(path).root\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(rootPath: string): PathBase {\n    rootPath = uncToDrive(rootPath.toUpperCase())\n    if (rootPath === this.root.name) {\n      return this.root\n    }\n    // ok, not that one, check if it matches another we know about\n    for (const [compare, root] of Object.entries(this.roots)) {\n      if (this.sameRoot(rootPath, compare)) {\n        return (this.roots[rootPath] = root)\n      }\n    }\n    // otherwise, have to create a new one.\n    return (this.roots[rootPath] = new PathScurryWin32(\n      rootPath,\n      this,\n    ).root)\n  }\n\n  /**\n   * @internal\n   */\n  sameRoot(rootPath: string, compare: string = this.root.name): boolean {\n    // windows can (rarely) have case-sensitive filesystem, but\n    // UNC and drive letters are always case-insensitive, and canonically\n    // represented uppercase.\n    rootPath = rootPath\n      .toUpperCase()\n      .replace(/\\//g, '\\\\')\n      .replace(uncDriveRegexp, '$1\\\\')\n    return rootPath === compare\n  }\n}\n\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nexport class PathPosix extends PathBase {\n  /**\n   * separator for parsing path strings\n   */\n  splitSep: '/' = '/'\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n\n  /**\n   * Do not create new Path objects directly.  They should always be accessed\n   * via the PathScurry class or other methods on the Path class.\n   *\n   * @internal\n   */\n  constructor(\n    name: string,\n    type: number = UNKNOWN,\n    root: PathBase | undefined,\n    roots: { [k: string]: PathBase },\n    nocase: boolean,\n    children: ChildrenCache,\n    opts: PathOpts,\n  ) {\n    super(name, type, root, roots, nocase, children, opts)\n  }\n\n  /**\n   * @internal\n   */\n  getRootString(path: string): string {\n    return path.startsWith('/') ? '/' : ''\n  }\n\n  /**\n   * @internal\n   */\n  getRoot(_rootPath: string): PathBase {\n    return this.root\n  }\n\n  /**\n   * @internal\n   */\n  newChild(name: string, type: number = UNKNOWN, opts: PathOpts = {}) {\n    return new PathPosix(\n      name,\n      type,\n      this.root,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      opts,\n    )\n  }\n}\n\n/**\n * Options that may be provided to the PathScurry constructor\n */\nexport interface PathScurryOpts {\n  /**\n   * perform case-insensitive path matching. Default based on platform\n   * subclass.\n   */\n  nocase?: boolean\n  /**\n   * Number of Path entries to keep in the cache of Path child references.\n   *\n   * Setting this higher than 65536 will dramatically increase the data\n   * consumption and construction time overhead of each PathScurry.\n   *\n   * Setting this value to 256 or lower will significantly reduce the data\n   * consumption and construction time overhead, but may also reduce resolve()\n   * and readdir() performance on large filesystems.\n   *\n   * Default `16384`.\n   */\n  childrenCacheSize?: number\n  /**\n   * An object that overrides the built-in functions from the fs and\n   * fs/promises modules.\n   *\n   * See {@link FSOption}\n   */\n  fs?: FSOption\n}\n\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nexport abstract class PathScurryBase {\n  /**\n   * The root Path entry for the current working directory of this Scurry\n   */\n  root: PathBase\n  /**\n   * The string path for the root of this Scurry's current working directory\n   */\n  rootPath: string\n  /**\n   * A collection of all roots encountered, referenced by rootPath\n   */\n  roots: { [k: string]: PathBase }\n  /**\n   * The Path entry corresponding to this PathScurry's current working directory.\n   */\n  cwd: PathBase\n  #resolveCache: ResolveCache\n  #resolvePosixCache: ResolveCache\n  #children: ChildrenCache\n  /**\n   * Perform path comparisons case-insensitively.\n   *\n   * Defaults true on Darwin and Windows systems, false elsewhere.\n   */\n  nocase: boolean\n\n  /**\n   * The path separator used for parsing paths\n   *\n   * `'/'` on Posix systems, either `'/'` or `'\\\\'` on Windows\n   */\n  abstract sep: string | RegExp\n\n  #fs: FSValue\n\n  /**\n   * This class should not be instantiated directly.\n   *\n   * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n   *\n   * @internal\n   */\n  constructor(\n    cwd: URL | string = process.cwd(),\n    pathImpl: typeof win32 | typeof posix,\n    sep: string | RegExp,\n    {\n      nocase,\n      childrenCacheSize = 16 * 1024,\n      fs = defaultFS,\n    }: PathScurryOpts = {},\n  ) {\n    this.#fs = fsFromOption(fs)\n    if (cwd instanceof URL || cwd.startsWith('file://')) {\n      cwd = fileURLToPath(cwd)\n    }\n    // resolve and split root, and then add to the store.\n    // this is the only time we call path.resolve()\n    const cwdPath = pathImpl.resolve(cwd)\n    this.roots = Object.create(null)\n    this.rootPath = this.parseRootPath(cwdPath)\n    this.#resolveCache = new ResolveCache()\n    this.#resolvePosixCache = new ResolveCache()\n    this.#children = new ChildrenCache(childrenCacheSize)\n\n    const split = cwdPath.substring(this.rootPath.length).split(sep)\n    // resolve('/') leaves '', splits to [''], we don't want that.\n    if (split.length === 1 && !split[0]) {\n      split.pop()\n    }\n    /* c8 ignore start */\n    if (nocase === undefined) {\n      throw new TypeError(\n        'must provide nocase setting to PathScurryBase ctor',\n      )\n    }\n    /* c8 ignore stop */\n    this.nocase = nocase\n    this.root = this.newRoot(this.#fs)\n    this.roots[this.rootPath] = this.root\n    let prev: PathBase = this.root\n    let len = split.length - 1\n    const joinSep = pathImpl.sep\n    let abs = this.rootPath\n    let sawFirst = false\n    for (const part of split) {\n      const l = len--\n      prev = prev.child(part, {\n        relative: new Array(l).fill('..').join(joinSep),\n        relativePosix: new Array(l).fill('..').join('/'),\n        fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n      })\n      sawFirst = true\n    }\n    this.cwd = prev\n  }\n\n  /**\n   * Get the depth of a provided path, string, or the cwd\n   */\n  depth(path: Path | string = this.cwd): number {\n    if (typeof path === 'string') {\n      path = this.cwd.resolve(path)\n    }\n    return path.depth()\n  }\n\n  /**\n   * Parse the root portion of a path string\n   *\n   * @internal\n   */\n  abstract parseRootPath(dir: string): string\n  /**\n   * create a new Path to use as root during construction.\n   *\n   * @internal\n   */\n  abstract newRoot(fs: FSValue): PathBase\n  /**\n   * Determine whether a given path string is absolute\n   */\n  abstract isAbsolute(p: string): boolean\n\n  /**\n   * Return the cache of child entries.  Exposed so subclasses can create\n   * child Path objects in a platform-specific way.\n   *\n   * @internal\n   */\n  childrenCache() {\n    return this.#children\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolve(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolveCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpath()\n    this.#resolveCache.set(r, result)\n    return result\n  }\n\n  /**\n   * Resolve one or more path strings to a resolved string, returning\n   * the posix path.  Identical to .resolve() on posix systems, but on\n   * windows will return a forward-slash separated UNC path.\n   *\n   * Same interface as require('path').resolve.\n   *\n   * Much faster than path.resolve() when called multiple times for the same\n   * path, because the resolved Path objects are cached.  Much slower\n   * otherwise.\n   */\n  resolvePosix(...paths: string[]): string {\n    // first figure out the minimum number of paths we have to test\n    // we always start at cwd, but any absolutes will bump the start\n    let r = ''\n    for (let i = paths.length - 1; i >= 0; i--) {\n      const p = paths[i]\n      if (!p || p === '.') continue\n      r = r ? `${p}/${r}` : p\n      if (this.isAbsolute(p)) {\n        break\n      }\n    }\n    const cached = this.#resolvePosixCache.get(r)\n    if (cached !== undefined) {\n      return cached\n    }\n    const result = this.cwd.resolve(r).fullpathPosix()\n    this.#resolvePosixCache.set(r, result)\n    return result\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or entry\n   */\n  relative(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relative()\n  }\n\n  /**\n   * find the relative path from the cwd to the supplied path string or\n   * entry, using / as the path delimiter, even on Windows.\n   */\n  relativePosix(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.relativePosix()\n  }\n\n  /**\n   * Return the basename for the provided string or Path object\n   */\n  basename(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.name\n  }\n\n  /**\n   * Return the dirname for the provided string or Path object\n   */\n  dirname(entry: PathBase | string = this.cwd): string {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return (entry.parent || entry).fullpath()\n  }\n\n  /**\n   * Return an array of known child entries.\n   *\n   * First argument may be either a string, or a Path object.\n   *\n   * If the Path cannot or does not contain any children, then an empty array\n   * is returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   *\n   * Unlike `fs.readdir()`, the `withFileTypes` option defaults to `true`. Set\n   * `{ withFileTypes: false }` to return strings.\n   */\n\n  readdir(): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: true }): Promise<PathBase[]>\n  readdir(opts: { withFileTypes: false }): Promise<string[]>\n  readdir(opts: { withFileTypes: boolean }): Promise<PathBase[] | string[]>\n  readdir(entry: PathBase | string): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: true },\n  ): Promise<PathBase[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: false },\n  ): Promise<string[]>\n  readdir(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean },\n  ): Promise<PathBase[] | string[]>\n  async readdir(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    },\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else {\n      const p = await entry.readdir()\n      return withFileTypes ? p : p.map(e => e.name)\n    }\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readdir}\n   */\n  readdirSync(): PathBase[]\n  readdirSync(opts: { withFileTypes: true }): PathBase[]\n  readdirSync(opts: { withFileTypes: false }): string[]\n  readdirSync(opts: { withFileTypes: boolean }): PathBase[] | string[]\n  readdirSync(entry: PathBase | string): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: true },\n  ): PathBase[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: false },\n  ): string[]\n  readdirSync(\n    entry: PathBase | string,\n    opts: { withFileTypes: boolean },\n  ): PathBase[] | string[]\n  readdirSync(\n    entry: PathBase | string | { withFileTypes: boolean } = this.cwd,\n    opts: { withFileTypes: boolean } = {\n      withFileTypes: true,\n    },\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const { withFileTypes = true } = opts\n    if (!entry.canReaddir()) {\n      return []\n    } else if (withFileTypes) {\n      return entry.readdirSync()\n    } else {\n      return entry.readdirSync().map(e => e.name)\n    }\n  }\n\n  /**\n   * Call lstat() on the string or Path object, and update all known\n   * information that can be determined.\n   *\n   * Note that unlike `fs.lstat()`, the returned value does not contain some\n   * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n   * information is required, you will need to call `fs.lstat` yourself.\n   *\n   * If the Path refers to a nonexistent file, or if the lstat call fails for\n   * any reason, `undefined` is returned.  Otherwise the updated Path object is\n   * returned.\n   *\n   * Results are cached, and thus may be out of date if the filesystem is\n   * mutated.\n   */\n  async lstat(\n    entry: string | PathBase = this.cwd,\n  ): Promise<PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstat()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.lstat}\n   */\n  lstatSync(entry: string | PathBase = this.cwd): PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    }\n    return entry.lstatSync()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to the target of a\n   * symbolic link.\n   *\n   * If the path is not a symbolic link, or if the readlink call fails for any\n   * reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  readlink(): Promise<string | undefined>\n  readlink(opt: { withFileTypes: false }): Promise<string | undefined>\n  readlink(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  readlink(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false },\n  ): Promise<string | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: true },\n  ): Promise<PathBase | undefined>\n  readlink(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean },\n  ): Promise<string | PathBase | undefined>\n  async readlink(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    },\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.readlink()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * synchronous {@link PathScurryBase.readlink}\n   */\n  readlinkSync(): string | undefined\n  readlinkSync(opt: { withFileTypes: false }): string | undefined\n  readlinkSync(opt: { withFileTypes: true }): PathBase | undefined\n  readlinkSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false },\n  ): string | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true },\n  ): PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean },\n  ): string | PathBase | undefined\n  readlinkSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    },\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.readlinkSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Return the Path object or string path corresponding to path as resolved\n   * by realpath(3).\n   *\n   * If the realpath call fails for any reason, `undefined` is returned.\n   *\n   * Result is cached, and thus may be outdated if the filesystem is mutated.\n   *\n   * `{withFileTypes}` option defaults to `false`.\n   *\n   * On success, returns a Path object if `withFileTypes` option is true,\n   * otherwise a string.\n   */\n  realpath(): Promise<string | undefined>\n  realpath(opt: { withFileTypes: false }): Promise<string | undefined>\n  realpath(opt: { withFileTypes: true }): Promise<PathBase | undefined>\n  realpath(opt: {\n    withFileTypes: boolean\n  }): Promise<PathBase | string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false },\n  ): Promise<string | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: true },\n  ): Promise<PathBase | undefined>\n  realpath(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean },\n  ): Promise<string | PathBase | undefined>\n  async realpath(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    },\n  ): Promise<string | PathBase | undefined> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = await entry.realpath()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  realpathSync(): string | undefined\n  realpathSync(opt: { withFileTypes: false }): string | undefined\n  realpathSync(opt: { withFileTypes: true }): PathBase | undefined\n  realpathSync(opt: {\n    withFileTypes: boolean\n  }): PathBase | string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt?: { withFileTypes: false },\n  ): string | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: true },\n  ): PathBase | undefined\n  realpathSync(\n    entry: string | PathBase,\n    opt: { withFileTypes: boolean },\n  ): string | PathBase | undefined\n  realpathSync(\n    entry: string | PathBase | { withFileTypes: boolean } = this.cwd,\n    { withFileTypes }: { withFileTypes: boolean } = {\n      withFileTypes: false,\n    },\n  ): string | PathBase | undefined {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      withFileTypes = entry.withFileTypes\n      entry = this.cwd\n    }\n    const e = entry.realpathSync()\n    return withFileTypes ? e : e?.fullpath()\n  }\n\n  /**\n   * Asynchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walk(): Promise<PathBase[]>\n  walk(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Promise<PathBase[]>\n  walk(opts: WalkOptionsWithFileTypesFalse): Promise<string[]>\n  walk(opts: WalkOptions): Promise<string[] | PathBase[]>\n  walk(entry: string | PathBase): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Promise<PathBase[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Promise<string[]>\n  walk(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): Promise<PathBase[] | string[]>\n  async walk(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): Promise<PathBase[] | string[]> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const walk = (\n      dir: PathBase,\n      cb: (er?: NodeJS.ErrnoException) => void,\n    ) => {\n      dirs.add(dir)\n      dir.readdirCB((er, entries) => {\n        /* c8 ignore start */\n        if (er) {\n          return cb(er)\n        }\n        /* c8 ignore stop */\n        let len = entries.length\n        if (!len) return cb()\n        const next = () => {\n          if (--len === 0) {\n            cb()\n          }\n        }\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            results.push(withFileTypes ? e : e.fullpath())\n          }\n          if (follow && e.isSymbolicLink()) {\n            e.realpath()\n              .then(r => (r?.isUnknown() ? r.lstat() : r))\n              .then(r =>\n                r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next(),\n              )\n          } else {\n            if (e.shouldWalk(dirs, walkFilter)) {\n              walk(e, next)\n            } else {\n              next()\n            }\n          }\n        }\n      }, true) // zalgooooooo\n    }\n\n    const start = entry\n    return new Promise<PathBase[] | string[]>((res, rej) => {\n      walk(start, er => {\n        /* c8 ignore start */\n        if (er) return rej(er)\n        /* c8 ignore stop */\n        res(results as PathBase[] | string[])\n      })\n    })\n  }\n\n  /**\n   * Synchronously walk the directory tree, returning an array of\n   * all path strings or Path objects found.\n   *\n   * Note that this will be extremely memory-hungry on large filesystems.\n   * In such cases, it may be better to use the stream or async iterator\n   * walk implementation.\n   */\n  walkSync(): PathBase[]\n  walkSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): PathBase[]\n  walkSync(opts: WalkOptionsWithFileTypesFalse): string[]\n  walkSync(opts: WalkOptions): string[] | PathBase[]\n  walkSync(entry: string | PathBase): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue,\n  ): PathBase[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): string[]\n  walkSync(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): PathBase[] | string[]\n  walkSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): PathBase[] | string[] {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results: (string | PathBase)[] = []\n    if (!filter || filter(entry)) {\n      results.push(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          results.push(withFileTypes ? e : e.fullpath())\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n    return results as string[] | PathBase[]\n  }\n\n  /**\n   * Support for `for await`\n   *\n   * Alias for {@link PathScurryBase.iterate}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  [Symbol.asyncIterator]() {\n    return this.iterate()\n  }\n\n  /**\n   * Async generator form of {@link PathScurryBase.walk}\n   *\n   * Note: As of Node 19, this is very slow, compared to other methods of\n   * walking, especially if most/all of the directory tree has been previously\n   * walked.  Consider using {@link PathScurryBase.stream} if memory overhead\n   * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n   */\n  iterate(): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    opts: WalkOptionsWithFileTypesFalse,\n  ): AsyncGenerator<string, void, void>\n  iterate(opts: WalkOptions): AsyncGenerator<string | PathBase, void, void>\n  iterate(entry: string | PathBase): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): AsyncGenerator<PathBase, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): AsyncGenerator<string, void, void>\n  iterate(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): AsyncGenerator<PathBase | string, void, void>\n  iterate(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    options: WalkOptions = {},\n  ): AsyncGenerator<PathBase | string, void, void> {\n    // iterating async over the stream is significantly more performant,\n    // especially in the warm-cache scenario, because it buffers up directory\n    // entries in the background instead of waiting for a yield for each one.\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      options = entry\n      entry = this.cwd\n    }\n    return this.stream(entry, options)[Symbol.asyncIterator]()\n  }\n\n  /**\n   * Iterating over a PathScurry performs a synchronous walk.\n   *\n   * Alias for {@link PathScurryBase.iterateSync}\n   */\n  [Symbol.iterator]() {\n    return this.iterateSync()\n  }\n\n  iterateSync(): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Generator<string, void, void>\n  iterateSync(opts: WalkOptions): Generator<string | PathBase, void, void>\n  iterateSync(entry: string | PathBase): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Generator<PathBase, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Generator<string, void, void>\n  iterateSync(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): Generator<PathBase | string, void, void>\n  *iterateSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): Generator<PathBase | string, void, void> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    if (!filter || filter(entry)) {\n      yield withFileTypes ? entry : entry.fullpath()\n    }\n    const dirs = new Set<PathBase>([entry])\n    for (const dir of dirs) {\n      const entries = dir.readdirSync()\n      for (const e of entries) {\n        if (!filter || filter(e)) {\n          yield withFileTypes ? e : e.fullpath()\n        }\n        let r: PathBase | undefined = e\n        if (e.isSymbolicLink()) {\n          if (!(follow && (r = e.realpathSync()))) continue\n          if (r.isUnknown()) r.lstatSync()\n        }\n        if (r.shouldWalk(dirs, walkFilter)) {\n          dirs.add(r)\n        }\n      }\n    }\n  }\n\n  /**\n   * Stream form of {@link PathScurryBase.walk}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   */\n  stream(): Minipass<PathBase>\n  stream(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Minipass<PathBase>\n  stream(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  stream(opts: WalkOptions): Minipass<string | PathBase>\n  stream(entry: string | PathBase): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue,\n  ): Minipass<PathBase>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Minipass<string>\n  stream(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): Minipass<string> | Minipass<PathBase>\n  stream(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const dirs = new Set<PathBase>()\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n\n        processing++\n        dirs.add(dir)\n\n        const onReaddir = (\n          er: null | NodeJS.ErrnoException,\n          entries: PathBase[],\n          didRealpaths: boolean = false,\n        ) => {\n          /* c8 ignore start */\n          if (er) return results.emit('error', er)\n          /* c8 ignore stop */\n          if (follow && !didRealpaths) {\n            const promises: Promise<PathBase | undefined>[] = []\n            for (const e of entries) {\n              if (e.isSymbolicLink()) {\n                promises.push(\n                  e\n                    .realpath()\n                    .then((r: PathBase | undefined) =>\n                      r?.isUnknown() ? r.lstat() : r,\n                    ),\n                )\n              }\n            }\n            if (promises.length) {\n              Promise.all(promises).then(() =>\n                onReaddir(null, entries, true),\n              )\n              return\n            }\n          }\n\n          for (const e of entries) {\n            if (e && (!filter || filter(e))) {\n              if (!results.write(withFileTypes ? e : e.fullpath())) {\n                paused = true\n              }\n            }\n          }\n\n          processing--\n          for (const e of entries) {\n            const r = e.realpathCached() || e\n            if (r.shouldWalk(dirs, walkFilter)) {\n              queue.push(r)\n            }\n          }\n          if (paused && !results.flowing) {\n            results.once('drain', process)\n          } else if (!sync) {\n            process()\n          }\n        }\n\n        // zalgo containment\n        let sync = true\n        dir.readdirCB(onReaddir, true)\n        sync = false\n      }\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  /**\n   * Synchronous form of {@link PathScurryBase.stream}\n   *\n   * Returns a Minipass stream that emits {@link PathBase} objects by default,\n   * or strings if `{ withFileTypes: false }` is set in the options.\n   *\n   * Will complete the walk in a single tick if the stream is consumed fully.\n   * Otherwise, will pause as needed for stream backpressure.\n   */\n  streamSync(): Minipass<PathBase>\n  streamSync(\n    opts: WalkOptionsWithFileTypesTrue | WalkOptionsWithFileTypesUnset,\n  ): Minipass<PathBase>\n  streamSync(opts: WalkOptionsWithFileTypesFalse): Minipass<string>\n  streamSync(opts: WalkOptions): Minipass<string | PathBase>\n  streamSync(entry: string | PathBase): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesUnset | WalkOptionsWithFileTypesTrue,\n  ): Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptionsWithFileTypesFalse,\n  ): Minipass<string>\n  streamSync(\n    entry: string | PathBase,\n    opts: WalkOptions,\n  ): Minipass<string> | Minipass<PathBase>\n  streamSync(\n    entry: string | PathBase | WalkOptions = this.cwd,\n    opts: WalkOptions = {},\n  ): Minipass<string> | Minipass<PathBase> {\n    if (typeof entry === 'string') {\n      entry = this.cwd.resolve(entry)\n    } else if (!(entry instanceof PathBase)) {\n      opts = entry\n      entry = this.cwd\n    }\n    const {\n      withFileTypes = true,\n      follow = false,\n      filter,\n      walkFilter,\n    } = opts\n    const results = new Minipass<string | PathBase>({ objectMode: true })\n    const dirs = new Set<PathBase>()\n    if (!filter || filter(entry)) {\n      results.write(withFileTypes ? entry : entry.fullpath())\n    }\n    const queue: PathBase[] = [entry]\n    let processing = 0\n    const process = () => {\n      let paused = false\n      while (!paused) {\n        const dir = queue.shift()\n        if (!dir) {\n          if (processing === 0) results.end()\n          return\n        }\n        processing++\n        dirs.add(dir)\n\n        const entries = dir.readdirSync()\n        for (const e of entries) {\n          if (!filter || filter(e)) {\n            if (!results.write(withFileTypes ? e : e.fullpath())) {\n              paused = true\n            }\n          }\n        }\n        processing--\n        for (const e of entries) {\n          let r: PathBase | undefined = e\n          if (e.isSymbolicLink()) {\n            if (!(follow && (r = e.realpathSync()))) continue\n            if (r.isUnknown()) r.lstatSync()\n          }\n          if (r.shouldWalk(dirs, walkFilter)) {\n            queue.push(r)\n          }\n        }\n      }\n      if (paused && !results.flowing) results.once('drain', process)\n    }\n    process()\n    return results as Minipass<string> | Minipass<PathBase>\n  }\n\n  chdir(path: string | Path = this.cwd) {\n    const oldCwd = this.cwd\n    this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path\n    this.cwd[setAsCwd](oldCwd)\n  }\n}\n\n/**\n * Options provided to all walk methods.\n */\nexport interface WalkOptions {\n  /**\n   * Return results as {@link PathBase} objects rather than strings.\n   * When set to false, results are fully resolved paths, as returned by\n   * {@link PathBase.fullpath}.\n   * @default true\n   */\n  withFileTypes?: boolean\n\n  /**\n   *  Attempt to read directory entries from symbolic links. Otherwise, only\n   *  actual directories are traversed. Regardless of this setting, a given\n   *  target path will only ever be walked once, meaning that a symbolic link\n   *  to a previously traversed directory will never be followed.\n   *\n   *  Setting this imposes a slight performance penalty, because `readlink`\n   *  must be called on all symbolic links encountered, in order to avoid\n   *  infinite cycles.\n   * @default false\n   */\n  follow?: boolean\n\n  /**\n   * Only return entries where the provided function returns true.\n   *\n   * This will not prevent directories from being traversed, even if they do\n   * not pass the filter, though it will prevent directories themselves from\n   * being included in the result set.  See {@link walkFilter}\n   *\n   * Asynchronous functions are not supported here.\n   *\n   * By default, if no filter is provided, all entries and traversed\n   * directories are included.\n   */\n  filter?: (entry: PathBase) => boolean\n\n  /**\n   * Only traverse directories (and in the case of {@link follow} being set to\n   * true, symbolic links to directories) if the provided function returns\n   * true.\n   *\n   * This will not prevent directories from being included in the result set,\n   * even if they do not pass the supplied filter function.  See {@link filter}\n   * to do that.\n   *\n   * Asynchronous functions are not supported here.\n   */\n  walkFilter?: (entry: PathBase) => boolean\n}\n\nexport type WalkOptionsWithFileTypesUnset = WalkOptions & {\n  withFileTypes?: undefined\n}\nexport type WalkOptionsWithFileTypesTrue = WalkOptions & {\n  withFileTypes: true\n}\nexport type WalkOptionsWithFileTypesFalse = WalkOptions & {\n  withFileTypes: false\n}\n\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nexport class PathScurryWin32 extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '\\\\' = '\\\\'\n\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {},\n  ) {\n    const { nocase = true } = opts\n    super(cwd, win32, '\\\\', { ...opts, nocase })\n    this.nocase = nocase\n    for (let p: PathBase | undefined = this.cwd; p; p = p.parent) {\n      p.nocase = this.nocase\n    }\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(dir: string): string {\n    // if the path starts with a single separator, it's not a UNC, and we'll\n    // just get separator as the root, and driveFromUNC will return \\\n    // In that case, mount \\ on the root from the cwd.\n    return win32.parse(dir).root.toUpperCase()\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathWin32(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs },\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return (\n      p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p)\n    )\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryPosix extends PathScurryBase {\n  /**\n   * separator for generating path strings\n   */\n  sep: '/' = '/'\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {},\n  ) {\n    const { nocase = false } = opts\n    super(cwd, posix, '/', { ...opts, nocase })\n    this.nocase = nocase\n  }\n\n  /**\n   * @internal\n   */\n  parseRootPath(_dir: string): string {\n    return '/'\n  }\n\n  /**\n   * @internal\n   */\n  newRoot(fs: FSValue) {\n    return new PathPosix(\n      this.rootPath,\n      IFDIR,\n      undefined,\n      this.roots,\n      this.nocase,\n      this.childrenCache(),\n      { fs },\n    )\n  }\n\n  /**\n   * Return true if the provided path string is an absolute path\n   */\n  isAbsolute(p: string): boolean {\n    return p.startsWith('/')\n  }\n}\n\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nexport class PathScurryDarwin extends PathScurryPosix {\n  constructor(\n    cwd: URL | string = process.cwd(),\n    opts: PathScurryOpts = {},\n  ) {\n    const { nocase = true } = opts\n    super(cwd, { ...opts, nocase })\n  }\n}\n\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexport const Path = process.platform === 'win32' ? PathWin32 : PathPosix\nexport type Path = PathBase | InstanceType<typeof Path>\n\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexport const PathScurry:\n  | typeof PathScurryWin32\n  | typeof PathScurryDarwin\n  | typeof PathScurryPosix =\n  process.platform === 'win32' ? PathScurryWin32\n  : process.platform === 'darwin' ? PathScurryDarwin\n  : PathScurryPosix\nexport type PathScurry = PathScurryBase | InstanceType<typeof PathScurry>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}