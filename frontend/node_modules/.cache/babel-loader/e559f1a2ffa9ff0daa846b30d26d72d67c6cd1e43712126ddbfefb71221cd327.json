{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GlobStream = exports.GlobWalker = exports.GlobUtil = void 0;\n/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nconst minipass_1 = require(\"minipass\");\nconst ignore_js_1 = require(\"./ignore.js\");\nconst processor_js_1 = require(\"./processor.js\");\nconst makeIgnore = (ignore, opts) => typeof ignore === 'string' ? new ignore_js_1.Ignore([ignore], opts) : Array.isArray(ignore) ? new ignore_js_1.Ignore(ignore, opts) : ignore;\n/**\n * basic walking utilities that all the glob walker types use\n */\nclass GlobUtil {\n  path;\n  patterns;\n  opts;\n  seen = new Set();\n  paused = false;\n  aborted = false;\n  #onResume = [];\n  #ignore;\n  #sep;\n  signal;\n  maxDepth;\n  includeChildMatches;\n  constructor(patterns, path, opts) {\n    this.patterns = patterns;\n    this.path = path;\n    this.opts = opts;\n    this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/';\n    this.includeChildMatches = opts.includeChildMatches !== false;\n    if (opts.ignore || !this.includeChildMatches) {\n      this.#ignore = makeIgnore(opts.ignore ?? [], opts);\n      if (!this.includeChildMatches && typeof this.#ignore.add !== 'function') {\n        const m = 'cannot ignore child matches, ignore lacks add() method.';\n        throw new Error(m);\n      }\n    }\n    // ignore, always set with maxDepth, but it's optional on the\n    // GlobOptions type\n    /* c8 ignore start */\n    this.maxDepth = opts.maxDepth || Infinity;\n    /* c8 ignore stop */\n    if (opts.signal) {\n      this.signal = opts.signal;\n      this.signal.addEventListener('abort', () => {\n        this.#onResume.length = 0;\n      });\n    }\n  }\n  #ignored(path) {\n    return this.seen.has(path) || !!this.#ignore?.ignored?.(path);\n  }\n  #childrenIgnored(path) {\n    return !!this.#ignore?.childrenIgnored?.(path);\n  }\n  // backpressure mechanism\n  pause() {\n    this.paused = true;\n  }\n  resume() {\n    /* c8 ignore start */\n    if (this.signal?.aborted) return;\n    /* c8 ignore stop */\n    this.paused = false;\n    let fn = undefined;\n    while (!this.paused && (fn = this.#onResume.shift())) {\n      fn();\n    }\n  }\n  onResume(fn) {\n    if (this.signal?.aborted) return;\n    /* c8 ignore start */\n    if (!this.paused) {\n      fn();\n    } else {\n      /* c8 ignore stop */\n      this.#onResume.push(fn);\n    }\n  }\n  // do the requisite realpath/stat checking, and return the path\n  // to add or undefined to filter it out.\n  async matchCheck(e, ifDir) {\n    if (ifDir && this.opts.nodir) return undefined;\n    let rpc;\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || (await e.realpath());\n      if (!rpc) return undefined;\n      e = rpc;\n    }\n    const needStat = e.isUnknown() || this.opts.stat;\n    const s = needStat ? await e.lstat() : e;\n    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n      const target = await s.realpath();\n      /* c8 ignore start */\n      if (target && (target.isUnknown() || this.opts.stat)) {\n        await target.lstat();\n      }\n      /* c8 ignore stop */\n    }\n    return this.matchCheckTest(s, ifDir);\n  }\n  matchCheckTest(e, ifDir) {\n    return e && (this.maxDepth === Infinity || e.depth() <= this.maxDepth) && (!ifDir || e.canReaddir()) && (!this.opts.nodir || !e.isDirectory()) && (!this.opts.nodir || !this.opts.follow || !e.isSymbolicLink() || !e.realpathCached()?.isDirectory()) && !this.#ignored(e) ? e : undefined;\n  }\n  matchCheckSync(e, ifDir) {\n    if (ifDir && this.opts.nodir) return undefined;\n    let rpc;\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || e.realpathSync();\n      if (!rpc) return undefined;\n      e = rpc;\n    }\n    const needStat = e.isUnknown() || this.opts.stat;\n    const s = needStat ? e.lstatSync() : e;\n    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n      const target = s.realpathSync();\n      if (target && (target?.isUnknown() || this.opts.stat)) {\n        target.lstatSync();\n      }\n    }\n    return this.matchCheckTest(s, ifDir);\n  }\n  matchFinish(e, absolute) {\n    if (this.#ignored(e)) return;\n    // we know we have an ignore if this is false, but TS doesn't\n    if (!this.includeChildMatches && this.#ignore?.add) {\n      const ign = `${e.relativePosix()}/**`;\n      this.#ignore.add(ign);\n    }\n    const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;\n    this.seen.add(e);\n    const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';\n    // ok, we have what we need!\n    if (this.opts.withFileTypes) {\n      this.matchEmit(e);\n    } else if (abs) {\n      const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();\n      this.matchEmit(abs + mark);\n    } else {\n      const rel = this.opts.posix ? e.relativePosix() : e.relative();\n      const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ? '.' + this.#sep : '';\n      this.matchEmit(!rel ? '.' + mark : pre + rel + mark);\n    }\n  }\n  async match(e, absolute, ifDir) {\n    const p = await this.matchCheck(e, ifDir);\n    if (p) this.matchFinish(p, absolute);\n  }\n  matchSync(e, absolute, ifDir) {\n    const p = this.matchCheckSync(e, ifDir);\n    if (p) this.matchFinish(p, absolute);\n  }\n  walkCB(target, patterns, cb) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb();\n    /* c8 ignore stop */\n    this.walkCB2(target, patterns, new processor_js_1.Processor(this.opts), cb);\n  }\n  walkCB2(target, patterns, processor, cb) {\n    if (this.#childrenIgnored(target)) return cb();\n    if (this.signal?.aborted) cb();\n    if (this.paused) {\n      this.onResume(() => this.walkCB2(target, patterns, processor, cb));\n      return;\n    }\n    processor.processPatterns(target, patterns);\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1;\n    const next = () => {\n      if (--tasks === 0) cb();\n    };\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue;\n      tasks++;\n      this.match(m, absolute, ifDir).then(() => next());\n    }\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue;\n      }\n      tasks++;\n      const childrenCached = t.readdirCached();\n      if (t.calledReaddir()) this.walkCB3(t, childrenCached, processor, next);else {\n        t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);\n      }\n    }\n    next();\n  }\n  walkCB3(target, entries, processor, cb) {\n    processor = processor.filterEntries(target, entries);\n    let tasks = 1;\n    const next = () => {\n      if (--tasks === 0) cb();\n    };\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue;\n      tasks++;\n      this.match(m, absolute, ifDir).then(() => next());\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++;\n      this.walkCB2(target, patterns, processor.child(), next);\n    }\n    next();\n  }\n  walkCBSync(target, patterns, cb) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb();\n    /* c8 ignore stop */\n    this.walkCB2Sync(target, patterns, new processor_js_1.Processor(this.opts), cb);\n  }\n  walkCB2Sync(target, patterns, processor, cb) {\n    if (this.#childrenIgnored(target)) return cb();\n    if (this.signal?.aborted) cb();\n    if (this.paused) {\n      this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));\n      return;\n    }\n    processor.processPatterns(target, patterns);\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1;\n    const next = () => {\n      if (--tasks === 0) cb();\n    };\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue;\n      this.matchSync(m, absolute, ifDir);\n    }\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue;\n      }\n      tasks++;\n      const children = t.readdirSync();\n      this.walkCB3Sync(t, children, processor, next);\n    }\n    next();\n  }\n  walkCB3Sync(target, entries, processor, cb) {\n    processor = processor.filterEntries(target, entries);\n    let tasks = 1;\n    const next = () => {\n      if (--tasks === 0) cb();\n    };\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue;\n      this.matchSync(m, absolute, ifDir);\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++;\n      this.walkCB2Sync(target, patterns, processor.child(), next);\n    }\n    next();\n  }\n}\nexports.GlobUtil = GlobUtil;\nclass GlobWalker extends GlobUtil {\n  matches = new Set();\n  constructor(patterns, path, opts) {\n    super(patterns, path, opts);\n  }\n  matchEmit(e) {\n    this.matches.add(e);\n  }\n  async walk() {\n    if (this.signal?.aborted) throw this.signal.reason;\n    if (this.path.isUnknown()) {\n      await this.path.lstat();\n    }\n    await new Promise((res, rej) => {\n      this.walkCB(this.path, this.patterns, () => {\n        if (this.signal?.aborted) {\n          rej(this.signal.reason);\n        } else {\n          res(this.matches);\n        }\n      });\n    });\n    return this.matches;\n  }\n  walkSync() {\n    if (this.signal?.aborted) throw this.signal.reason;\n    if (this.path.isUnknown()) {\n      this.path.lstatSync();\n    }\n    // nothing for the callback to do, because this never pauses\n    this.walkCBSync(this.path, this.patterns, () => {\n      if (this.signal?.aborted) throw this.signal.reason;\n    });\n    return this.matches;\n  }\n}\nexports.GlobWalker = GlobWalker;\nclass GlobStream extends GlobUtil {\n  results;\n  constructor(patterns, path, opts) {\n    super(patterns, path, opts);\n    this.results = new minipass_1.Minipass({\n      signal: this.signal,\n      objectMode: true\n    });\n    this.results.on('drain', () => this.resume());\n    this.results.on('resume', () => this.resume());\n  }\n  matchEmit(e) {\n    this.results.write(e);\n    if (!this.results.flowing) this.pause();\n  }\n  stream() {\n    const target = this.path;\n    if (target.isUnknown()) {\n      target.lstat().then(() => {\n        this.walkCB(target, this.patterns, () => this.results.end());\n      });\n    } else {\n      this.walkCB(target, this.patterns, () => this.results.end());\n    }\n    return this.results;\n  }\n  streamSync() {\n    if (this.path.isUnknown()) {\n      this.path.lstatSync();\n    }\n    this.walkCBSync(this.path, this.patterns, () => this.results.end());\n    return this.results;\n  }\n}\nexports.GlobStream = GlobStream;","map":{"version":3,"names":["minipass_1","require","ignore_js_1","processor_js_1","makeIgnore","ignore","opts","Ignore","Array","isArray","GlobUtil","path","patterns","seen","Set","paused","aborted","onResume","sep","signal","maxDepth","includeChildMatches","constructor","posix","platform","add","m","Error","Infinity","addEventListener","length","ignored","#ignored","has","childrenIgnored","#childrenIgnored","pause","resume","fn","undefined","shift","push","matchCheck","e","ifDir","nodir","rpc","realpath","realpathCached","needStat","isUnknown","stat","s","lstat","follow","isSymbolicLink","target","matchCheckTest","depth","canReaddir","isDirectory","matchCheckSync","realpathSync","lstatSync","matchFinish","absolute","ign","relativePosix","abs","mark","withFileTypes","matchEmit","fullpathPosix","fullpath","rel","relative","pre","dotRelative","startsWith","match","p","matchSync","walkCB","cb","walkCB2","Processor","processor","processPatterns","tasks","next","matches","entries","then","t","subwalkTargets","childrenCached","readdirCached","calledReaddir","walkCB3","readdirCB","_","filterEntries","subwalks","child","walkCBSync","walkCB2Sync","children","readdirSync","walkCB3Sync","exports","GlobWalker","walk","reason","Promise","res","rej","walkSync","GlobStream","results","Minipass","objectMode","on","write","flowing","stream","end","streamSync"],"sources":["E:\\programs\\AI programs\\AIMessageApp\\frontend\\node_modules\\pkghub\\node_modules\\glob\\src\\walker.ts"],"sourcesContent":["/**\n * Single-use utility classes to provide functionality to the {@link Glob}\n * methods.\n *\n * @module\n */\nimport { Minipass } from 'minipass'\nimport { Path } from 'path-scurry'\nimport { Ignore, IgnoreLike } from './ignore.js'\n\n// XXX can we somehow make it so that it NEVER processes a given path more than\n// once, enough that the match set tracking is no longer needed?  that'd speed\n// things up a lot.  Or maybe bring back nounique, and skip it in that case?\n\n// a single minimatch set entry with 1 or more parts\nimport { Pattern } from './pattern.js'\nimport { Processor } from './processor.js'\n\nexport interface GlobWalkerOpts {\n  absolute?: boolean\n  allowWindowsEscape?: boolean\n  cwd?: string | URL\n  dot?: boolean\n  dotRelative?: boolean\n  follow?: boolean\n  ignore?: string | string[] | IgnoreLike\n  mark?: boolean\n  matchBase?: boolean\n  // Note: maxDepth here means \"maximum actual Path.depth()\",\n  // not \"maximum depth beyond cwd\"\n  maxDepth?: number\n  nobrace?: boolean\n  nocase?: boolean\n  nodir?: boolean\n  noext?: boolean\n  noglobstar?: boolean\n  platform?: NodeJS.Platform\n  posix?: boolean\n  realpath?: boolean\n  root?: string\n  stat?: boolean\n  signal?: AbortSignal\n  windowsPathsNoEscape?: boolean\n  withFileTypes?: boolean\n  includeChildMatches?: boolean\n}\n\nexport type GWOFileTypesTrue = GlobWalkerOpts & {\n  withFileTypes: true\n}\nexport type GWOFileTypesFalse = GlobWalkerOpts & {\n  withFileTypes: false\n}\nexport type GWOFileTypesUnset = GlobWalkerOpts & {\n  withFileTypes?: undefined\n}\n\nexport type Result<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue ? Path\n  : O extends GWOFileTypesFalse ? string\n  : O extends GWOFileTypesUnset ? string\n  : Path | string\n\nexport type Matches<O extends GlobWalkerOpts> =\n  O extends GWOFileTypesTrue ? Set<Path>\n  : O extends GWOFileTypesFalse ? Set<string>\n  : O extends GWOFileTypesUnset ? Set<string>\n  : Set<Path | string>\n\nexport type MatchStream<O extends GlobWalkerOpts> = Minipass<\n  Result<O>,\n  Result<O>\n>\n\nconst makeIgnore = (\n  ignore: string | string[] | IgnoreLike,\n  opts: GlobWalkerOpts,\n): IgnoreLike =>\n  typeof ignore === 'string' ? new Ignore([ignore], opts)\n  : Array.isArray(ignore) ? new Ignore(ignore, opts)\n  : ignore\n\n/**\n * basic walking utilities that all the glob walker types use\n */\nexport abstract class GlobUtil<O extends GlobWalkerOpts = GlobWalkerOpts> {\n  path: Path\n  patterns: Pattern[]\n  opts: O\n  seen: Set<Path> = new Set<Path>()\n  paused: boolean = false\n  aborted: boolean = false\n  #onResume: (() => any)[] = []\n  #ignore?: IgnoreLike\n  #sep: '\\\\' | '/'\n  signal?: AbortSignal\n  maxDepth: number\n  includeChildMatches: boolean\n\n  constructor(patterns: Pattern[], path: Path, opts: O)\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    this.patterns = patterns\n    this.path = path\n    this.opts = opts\n    this.#sep = !opts.posix && opts.platform === 'win32' ? '\\\\' : '/'\n    this.includeChildMatches = opts.includeChildMatches !== false\n    if (opts.ignore || !this.includeChildMatches) {\n      this.#ignore = makeIgnore(opts.ignore ?? [], opts)\n      if (\n        !this.includeChildMatches &&\n        typeof this.#ignore.add !== 'function'\n      ) {\n        const m = 'cannot ignore child matches, ignore lacks add() method.'\n        throw new Error(m)\n      }\n    }\n    // ignore, always set with maxDepth, but it's optional on the\n    // GlobOptions type\n    /* c8 ignore start */\n    this.maxDepth = opts.maxDepth || Infinity\n    /* c8 ignore stop */\n    if (opts.signal) {\n      this.signal = opts.signal\n      this.signal.addEventListener('abort', () => {\n        this.#onResume.length = 0\n      })\n    }\n  }\n\n  #ignored(path: Path): boolean {\n    return this.seen.has(path) || !!this.#ignore?.ignored?.(path)\n  }\n  #childrenIgnored(path: Path): boolean {\n    return !!this.#ignore?.childrenIgnored?.(path)\n  }\n\n  // backpressure mechanism\n  pause() {\n    this.paused = true\n  }\n  resume() {\n    /* c8 ignore start */\n    if (this.signal?.aborted) return\n    /* c8 ignore stop */\n    this.paused = false\n    let fn: (() => any) | undefined = undefined\n    while (!this.paused && (fn = this.#onResume.shift())) {\n      fn()\n    }\n  }\n  onResume(fn: () => any) {\n    if (this.signal?.aborted) return\n    /* c8 ignore start */\n    if (!this.paused) {\n      fn()\n    } else {\n      /* c8 ignore stop */\n      this.#onResume.push(fn)\n    }\n  }\n\n  // do the requisite realpath/stat checking, and return the path\n  // to add or undefined to filter it out.\n  async matchCheck(e: Path, ifDir: boolean): Promise<Path | undefined> {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || (await e.realpath())\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    const s = needStat ? await e.lstat() : e\n    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n      const target = await s.realpath()\n      /* c8 ignore start */\n      if (target && (target.isUnknown() || this.opts.stat)) {\n        await target.lstat()\n      }\n      /* c8 ignore stop */\n    }\n    return this.matchCheckTest(s, ifDir)\n  }\n\n  matchCheckTest(e: Path | undefined, ifDir: boolean): Path | undefined {\n    return (\n        e &&\n          (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&\n          (!ifDir || e.canReaddir()) &&\n          (!this.opts.nodir || !e.isDirectory()) &&\n          (!this.opts.nodir ||\n            !this.opts.follow ||\n            !e.isSymbolicLink() ||\n            !e.realpathCached()?.isDirectory()) &&\n          !this.#ignored(e)\n      ) ?\n        e\n      : undefined\n  }\n\n  matchCheckSync(e: Path, ifDir: boolean): Path | undefined {\n    if (ifDir && this.opts.nodir) return undefined\n    let rpc: Path | undefined\n    if (this.opts.realpath) {\n      rpc = e.realpathCached() || e.realpathSync()\n      if (!rpc) return undefined\n      e = rpc\n    }\n    const needStat = e.isUnknown() || this.opts.stat\n    const s = needStat ? e.lstatSync() : e\n    if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {\n      const target = s.realpathSync()\n      if (target && (target?.isUnknown() || this.opts.stat)) {\n        target.lstatSync()\n      }\n    }\n    return this.matchCheckTest(s, ifDir)\n  }\n\n  abstract matchEmit(p: Result<O>): void\n  abstract matchEmit(p: string | Path): void\n\n  matchFinish(e: Path, absolute: boolean) {\n    if (this.#ignored(e)) return\n    // we know we have an ignore if this is false, but TS doesn't\n    if (!this.includeChildMatches && this.#ignore?.add) {\n      const ign = `${e.relativePosix()}/**`\n      this.#ignore.add(ign)\n    }\n    const abs =\n      this.opts.absolute === undefined ? absolute : this.opts.absolute\n    this.seen.add(e)\n    const mark = this.opts.mark && e.isDirectory() ? this.#sep : ''\n    // ok, we have what we need!\n    if (this.opts.withFileTypes) {\n      this.matchEmit(e)\n    } else if (abs) {\n      const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath()\n      this.matchEmit(abs + mark)\n    } else {\n      const rel = this.opts.posix ? e.relativePosix() : e.relative()\n      const pre =\n        this.opts.dotRelative && !rel.startsWith('..' + this.#sep) ?\n          '.' + this.#sep\n        : ''\n      this.matchEmit(!rel ? '.' + mark : pre + rel + mark)\n    }\n  }\n\n  async match(e: Path, absolute: boolean, ifDir: boolean): Promise<void> {\n    const p = await this.matchCheck(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  matchSync(e: Path, absolute: boolean, ifDir: boolean): void {\n    const p = this.matchCheckSync(e, ifDir)\n    if (p) this.matchFinish(p, absolute)\n  }\n\n  walkCB(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() => this.walkCB2(target, patterns, processor, cb))\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const childrenCached = t.readdirCached()\n      if (t.calledReaddir())\n        this.walkCB3(t, childrenCached, processor, next)\n      else {\n        t.readdirCB(\n          (_, entries) => this.walkCB3(t, entries, processor, next),\n          true,\n        )\n      }\n    }\n\n    next()\n  }\n\n  walkCB3(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      tasks++\n      this.match(m, absolute, ifDir).then(() => next())\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n\n  walkCBSync(target: Path, patterns: Pattern[], cb: () => any) {\n    /* c8 ignore start */\n    if (this.signal?.aborted) cb()\n    /* c8 ignore stop */\n    this.walkCB2Sync(target, patterns, new Processor(this.opts), cb)\n  }\n\n  walkCB2Sync(\n    target: Path,\n    patterns: Pattern[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    if (this.#childrenIgnored(target)) return cb()\n    if (this.signal?.aborted) cb()\n    if (this.paused) {\n      this.onResume(() =>\n        this.walkCB2Sync(target, patterns, processor, cb),\n      )\n      return\n    }\n    processor.processPatterns(target, patterns)\n\n    // done processing.  all of the above is sync, can be abstracted out.\n    // subwalks is a map of paths to the entry filters they need\n    // matches is a map of paths to [absolute, ifDir] tuples.\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n\n    for (const t of processor.subwalkTargets()) {\n      if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {\n        continue\n      }\n      tasks++\n      const children = t.readdirSync()\n      this.walkCB3Sync(t, children, processor, next)\n    }\n\n    next()\n  }\n\n  walkCB3Sync(\n    target: Path,\n    entries: Path[],\n    processor: Processor,\n    cb: () => any,\n  ) {\n    processor = processor.filterEntries(target, entries)\n\n    let tasks = 1\n    const next = () => {\n      if (--tasks === 0) cb()\n    }\n\n    for (const [m, absolute, ifDir] of processor.matches.entries()) {\n      if (this.#ignored(m)) continue\n      this.matchSync(m, absolute, ifDir)\n    }\n    for (const [target, patterns] of processor.subwalks.entries()) {\n      tasks++\n      this.walkCB2Sync(target, patterns, processor.child(), next)\n    }\n\n    next()\n  }\n}\n\nexport class GlobWalker<\n  O extends GlobWalkerOpts = GlobWalkerOpts,\n> extends GlobUtil<O> {\n  matches = new Set<Result<O>>()\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n  }\n\n  matchEmit(e: Result<O>): void {\n    this.matches.add(e)\n  }\n\n  async walk(): Promise<Set<Result<O>>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      await this.path.lstat()\n    }\n    await new Promise((res, rej) => {\n      this.walkCB(this.path, this.patterns, () => {\n        if (this.signal?.aborted) {\n          rej(this.signal.reason)\n        } else {\n          res(this.matches)\n        }\n      })\n    })\n    return this.matches\n  }\n\n  walkSync(): Set<Result<O>> {\n    if (this.signal?.aborted) throw this.signal.reason\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    // nothing for the callback to do, because this never pauses\n    this.walkCBSync(this.path, this.patterns, () => {\n      if (this.signal?.aborted) throw this.signal.reason\n    })\n    return this.matches\n  }\n}\n\nexport class GlobStream<\n  O extends GlobWalkerOpts = GlobWalkerOpts,\n> extends GlobUtil<O> {\n  results: Minipass<Result<O>, Result<O>>\n\n  constructor(patterns: Pattern[], path: Path, opts: O) {\n    super(patterns, path, opts)\n    this.results = new Minipass<Result<O>, Result<O>>({\n      signal: this.signal,\n      objectMode: true,\n    })\n    this.results.on('drain', () => this.resume())\n    this.results.on('resume', () => this.resume())\n  }\n\n  matchEmit(e: Result<O>): void {\n    this.results.write(e)\n    if (!this.results.flowing) this.pause()\n  }\n\n  stream(): MatchStream<O> {\n    const target = this.path\n    if (target.isUnknown()) {\n      target.lstat().then(() => {\n        this.walkCB(target, this.patterns, () => this.results.end())\n      })\n    } else {\n      this.walkCB(target, this.patterns, () => this.results.end())\n    }\n    return this.results\n  }\n\n  streamSync(): MatchStream<O> {\n    if (this.path.isUnknown()) {\n      this.path.lstatSync()\n    }\n    this.walkCBSync(this.path, this.patterns, () => this.results.end())\n    return this.results\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}