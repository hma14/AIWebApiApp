{"ast":null,"code":"\"use strict\";\n\n// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Ignore = void 0;\nconst minimatch_1 = require(\"minimatch\");\nconst pattern_js_1 = require(\"./pattern.js\");\nconst defaultPlatform = typeof process === 'object' && process && typeof process.platform === 'string' ? process.platform : 'linux';\n/**\n * Class used to process ignored patterns\n */\nclass Ignore {\n  relative;\n  relativeChildren;\n  absolute;\n  absoluteChildren;\n  platform;\n  mmopts;\n  constructor(ignored, {\n    nobrace,\n    nocase,\n    noext,\n    noglobstar,\n    platform = defaultPlatform\n  }) {\n    this.relative = [];\n    this.absolute = [];\n    this.relativeChildren = [];\n    this.absoluteChildren = [];\n    this.platform = platform;\n    this.mmopts = {\n      dot: true,\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      optimizationLevel: 2,\n      platform,\n      nocomment: true,\n      nonegate: true\n    };\n    for (const ign of ignored) this.add(ign);\n  }\n  add(ign) {\n    // this is a little weird, but it gives us a clean set of optimized\n    // minimatch matchers, without getting tripped up if one of them\n    // ends in /** inside a brace section, and it's only inefficient at\n    // the start of the walk, not along it.\n    // It'd be nice if the Pattern class just had a .test() method, but\n    // handling globstars is a bit of a pita, and that code already lives\n    // in minimatch anyway.\n    // Another way would be if maybe Minimatch could take its set/globParts\n    // as an option, and then we could at least just use Pattern to test\n    // for absolute-ness.\n    // Yet another way, Minimatch could take an array of glob strings, and\n    // a cwd option, and do the right thing.\n    const mm = new minimatch_1.Minimatch(ign, this.mmopts);\n    for (let i = 0; i < mm.set.length; i++) {\n      const parsed = mm.set[i];\n      const globParts = mm.globParts[i];\n      /* c8 ignore start */\n      if (!parsed || !globParts) {\n        throw new Error('invalid pattern object');\n      }\n      // strip off leading ./ portions\n      // https://github.com/isaacs/node-glob/issues/570\n      while (parsed[0] === '.' && globParts[0] === '.') {\n        parsed.shift();\n        globParts.shift();\n      }\n      /* c8 ignore stop */\n      const p = new pattern_js_1.Pattern(parsed, globParts, 0, this.platform);\n      const m = new minimatch_1.Minimatch(p.globString(), this.mmopts);\n      const children = globParts[globParts.length - 1] === '**';\n      const absolute = p.isAbsolute();\n      if (absolute) this.absolute.push(m);else this.relative.push(m);\n      if (children) {\n        if (absolute) this.absoluteChildren.push(m);else this.relativeChildren.push(m);\n      }\n    }\n  }\n  ignored(p) {\n    const fullpath = p.fullpath();\n    const fullpaths = `${fullpath}/`;\n    const relative = p.relative() || '.';\n    const relatives = `${relative}/`;\n    for (const m of this.relative) {\n      if (m.match(relative) || m.match(relatives)) return true;\n    }\n    for (const m of this.absolute) {\n      if (m.match(fullpath) || m.match(fullpaths)) return true;\n    }\n    return false;\n  }\n  childrenIgnored(p) {\n    const fullpath = p.fullpath() + '/';\n    const relative = (p.relative() || '.') + '/';\n    for (const m of this.relativeChildren) {\n      if (m.match(relative)) return true;\n    }\n    for (const m of this.absoluteChildren) {\n      if (m.match(fullpath)) return true;\n    }\n    return false;\n  }\n}\nexports.Ignore = Ignore;","map":{"version":3,"names":["minimatch_1","require","pattern_js_1","defaultPlatform","process","platform","Ignore","relative","relativeChildren","absolute","absoluteChildren","mmopts","constructor","ignored","nobrace","nocase","noext","noglobstar","dot","optimizationLevel","nocomment","nonegate","ign","add","mm","Minimatch","i","set","length","parsed","globParts","Error","shift","p","Pattern","m","globString","children","isAbsolute","push","fullpath","fullpaths","relatives","match","childrenIgnored","exports"],"sources":["E:\\programs\\AI programs\\AIMessageApp\\frontend\\node_modules\\pkghub\\node_modules\\glob\\src\\ignore.ts"],"sourcesContent":["// give it a pattern, and it'll be able to tell you if\n// a given path should be ignored.\n// Ignoring a path ignores its children if the pattern ends in /**\n// Ignores are always parsed in dot:true mode\n\nimport { Minimatch, MinimatchOptions } from 'minimatch'\nimport { Path } from 'path-scurry'\nimport { Pattern } from './pattern.js'\nimport { GlobWalkerOpts } from './walker.js'\n\nexport interface IgnoreLike {\n  ignored?: (p: Path) => boolean\n  childrenIgnored?: (p: Path) => boolean\n  add?: (ignore: string) => void\n}\n\nconst defaultPlatform: NodeJS.Platform =\n  (\n    typeof process === 'object' &&\n    process &&\n    typeof process.platform === 'string'\n  ) ?\n    process.platform\n  : 'linux'\n\n/**\n * Class used to process ignored patterns\n */\nexport class Ignore implements IgnoreLike {\n  relative: Minimatch[]\n  relativeChildren: Minimatch[]\n  absolute: Minimatch[]\n  absoluteChildren: Minimatch[]\n  platform: NodeJS.Platform\n  mmopts: MinimatchOptions\n\n  constructor(\n    ignored: string[],\n    {\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      platform = defaultPlatform,\n    }: GlobWalkerOpts,\n  ) {\n    this.relative = []\n    this.absolute = []\n    this.relativeChildren = []\n    this.absoluteChildren = []\n    this.platform = platform\n    this.mmopts = {\n      dot: true,\n      nobrace,\n      nocase,\n      noext,\n      noglobstar,\n      optimizationLevel: 2,\n      platform,\n      nocomment: true,\n      nonegate: true,\n    }\n    for (const ign of ignored) this.add(ign)\n  }\n\n  add(ign: string) {\n    // this is a little weird, but it gives us a clean set of optimized\n    // minimatch matchers, without getting tripped up if one of them\n    // ends in /** inside a brace section, and it's only inefficient at\n    // the start of the walk, not along it.\n    // It'd be nice if the Pattern class just had a .test() method, but\n    // handling globstars is a bit of a pita, and that code already lives\n    // in minimatch anyway.\n    // Another way would be if maybe Minimatch could take its set/globParts\n    // as an option, and then we could at least just use Pattern to test\n    // for absolute-ness.\n    // Yet another way, Minimatch could take an array of glob strings, and\n    // a cwd option, and do the right thing.\n    const mm = new Minimatch(ign, this.mmopts)\n    for (let i = 0; i < mm.set.length; i++) {\n      const parsed = mm.set[i]\n      const globParts = mm.globParts[i]\n      /* c8 ignore start */\n      if (!parsed || !globParts) {\n        throw new Error('invalid pattern object')\n      }\n      // strip off leading ./ portions\n      // https://github.com/isaacs/node-glob/issues/570\n      while (parsed[0] === '.' && globParts[0] === '.') {\n        parsed.shift()\n        globParts.shift()\n      }\n      /* c8 ignore stop */\n      const p = new Pattern(parsed, globParts, 0, this.platform)\n      const m = new Minimatch(p.globString(), this.mmopts)\n      const children = globParts[globParts.length - 1] === '**'\n      const absolute = p.isAbsolute()\n      if (absolute) this.absolute.push(m)\n      else this.relative.push(m)\n      if (children) {\n        if (absolute) this.absoluteChildren.push(m)\n        else this.relativeChildren.push(m)\n      }\n    }\n  }\n\n  ignored(p: Path): boolean {\n    const fullpath = p.fullpath()\n    const fullpaths = `${fullpath}/`\n    const relative = p.relative() || '.'\n    const relatives = `${relative}/`\n    for (const m of this.relative) {\n      if (m.match(relative) || m.match(relatives)) return true\n    }\n    for (const m of this.absolute) {\n      if (m.match(fullpath) || m.match(fullpaths)) return true\n    }\n    return false\n  }\n\n  childrenIgnored(p: Path): boolean {\n    const fullpath = p.fullpath() + '/'\n    const relative = (p.relative() || '.') + '/'\n    for (const m of this.relativeChildren) {\n      if (m.match(relative)) return true\n    }\n    for (const m of this.absoluteChildren) {\n      if (m.match(fullpath)) return true\n    }\n    return false\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}