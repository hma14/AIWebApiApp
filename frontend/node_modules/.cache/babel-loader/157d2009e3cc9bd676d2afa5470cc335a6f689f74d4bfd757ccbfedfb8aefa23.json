{"ast":null,"code":"\"use strict\";\n\n// translate the various posix character classes into unicode properties\n// this works across all unicode locales\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseClass = void 0;\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false]\n};\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = s => s.replace(/[[\\]\\\\-]/g, '\\\\$&');\n// escape all regexp magic characters\nconst regexpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n// everything has already been escaped, we just have to join\nconst rangesToString = ranges => ranges.join('');\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nconst parseClass = (glob, position) => {\n  const pos = position;\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression');\n  }\n  /* c8 ignore stop */\n  const ranges = [];\n  const negs = [];\n  let i = pos + 1;\n  let sawStart = false;\n  let uflag = false;\n  let escaping = false;\n  let negate = false;\n  let endPos = pos;\n  let rangeStart = '';\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i);\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true;\n      i++;\n      continue;\n    }\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1;\n      break;\n    }\n    sawStart = true;\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true;\n        i++;\n        continue;\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true];\n          }\n          i += cls.length;\n          if (neg) negs.push(unip);else ranges.push(unip);\n          uflag = uflag || u;\n          continue WHILE;\n        }\n      }\n    }\n    // now it's just a normal character, effectively\n    escaping = false;\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c));\n      }\n      rangeStart = '';\n      i++;\n      continue;\n    }\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'));\n      i += 2;\n      continue;\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c;\n      i += 2;\n      continue;\n    }\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c));\n    i++;\n  }\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false];\n  }\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true];\n  }\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (negs.length === 0 && ranges.length === 1 && /^\\\\?.$/.test(ranges[0]) && !negate) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];\n    return [regexpEscape(r), false, endPos - pos, false];\n  }\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';\n  const comb = ranges.length && negs.length ? '(' + sranges + '|' + snegs + ')' : ranges.length ? sranges : snegs;\n  return [comb, uflag, endPos - pos, true];\n};\nexports.parseClass = parseClass;","map":{"version":3,"names":["posixClasses","braceEscape","s","replace","regexpEscape","rangesToString","ranges","join","parseClass","glob","position","pos","charAt","Error","negs","i","sawStart","uflag","escaping","negate","endPos","rangeStart","WHILE","length","c","cls","unip","u","neg","Object","entries","startsWith","push","test","r","slice","sranges","snegs","comb","exports"],"sources":["E:\\programs\\AI programs\\AIMessageApp\\frontend\\node_modules\\pkghub\\node_modules\\minimatch\\src\\brace-expressions.ts"],"sourcesContent":["// translate the various posix character classes into unicode properties\n// this works across all unicode locales\n\n// { <posix class>: [<translation>, /u flag required, negated]\nconst posixClasses: { [k: string]: [e: string, u: boolean, n?: boolean] } = {\n  '[:alnum:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}', true],\n  '[:alpha:]': ['\\\\p{L}\\\\p{Nl}', true],\n  '[:ascii:]': ['\\\\x' + '00-\\\\x' + '7f', false],\n  '[:blank:]': ['\\\\p{Zs}\\\\t', true],\n  '[:cntrl:]': ['\\\\p{Cc}', true],\n  '[:digit:]': ['\\\\p{Nd}', true],\n  '[:graph:]': ['\\\\p{Z}\\\\p{C}', true, true],\n  '[:lower:]': ['\\\\p{Ll}', true],\n  '[:print:]': ['\\\\p{C}', true],\n  '[:punct:]': ['\\\\p{P}', true],\n  '[:space:]': ['\\\\p{Z}\\\\t\\\\r\\\\n\\\\v\\\\f', true],\n  '[:upper:]': ['\\\\p{Lu}', true],\n  '[:word:]': ['\\\\p{L}\\\\p{Nl}\\\\p{Nd}\\\\p{Pc}', true],\n  '[:xdigit:]': ['A-Fa-f0-9', false],\n}\n\n// only need to escape a few things inside of brace expressions\n// escapes: [ \\ ] -\nconst braceEscape = (s: string) => s.replace(/[[\\]\\\\-]/g, '\\\\$&')\n// escape all regexp magic characters\nconst regexpEscape = (s: string) =>\n  s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\n\n// everything has already been escaped, we just have to join\nconst rangesToString = (ranges: string[]): string => ranges.join('')\n\nexport type ParseClassResult = [\n  src: string,\n  uFlag: boolean,\n  consumed: number,\n  hasMagic: boolean\n]\n\n// takes a glob string at a posix brace expression, and returns\n// an equivalent regular expression source, and boolean indicating\n// whether the /u flag needs to be applied, and the number of chars\n// consumed to parse the character class.\n// This also removes out of order ranges, and returns ($.) if the\n// entire class just no good.\nexport const parseClass = (\n  glob: string,\n  position: number\n): ParseClassResult => {\n  const pos = position\n  /* c8 ignore start */\n  if (glob.charAt(pos) !== '[') {\n    throw new Error('not in a brace expression')\n  }\n  /* c8 ignore stop */\n  const ranges: string[] = []\n  const negs: string[] = []\n\n  let i = pos + 1\n  let sawStart = false\n  let uflag = false\n  let escaping = false\n  let negate = false\n  let endPos = pos\n  let rangeStart = ''\n  WHILE: while (i < glob.length) {\n    const c = glob.charAt(i)\n    if ((c === '!' || c === '^') && i === pos + 1) {\n      negate = true\n      i++\n      continue\n    }\n\n    if (c === ']' && sawStart && !escaping) {\n      endPos = i + 1\n      break\n    }\n\n    sawStart = true\n    if (c === '\\\\') {\n      if (!escaping) {\n        escaping = true\n        i++\n        continue\n      }\n      // escaped \\ char, fall through and treat like normal char\n    }\n    if (c === '[' && !escaping) {\n      // either a posix class, a collation equivalent, or just a [\n      for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {\n        if (glob.startsWith(cls, i)) {\n          // invalid, [a-[] is fine, but not [a-[:alpha]]\n          if (rangeStart) {\n            return ['$.', false, glob.length - pos, true]\n          }\n          i += cls.length\n          if (neg) negs.push(unip)\n          else ranges.push(unip)\n          uflag = uflag || u\n          continue WHILE\n        }\n      }\n    }\n\n    // now it's just a normal character, effectively\n    escaping = false\n    if (rangeStart) {\n      // throw this range away if it's not valid, but others\n      // can still match.\n      if (c > rangeStart) {\n        ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c))\n      } else if (c === rangeStart) {\n        ranges.push(braceEscape(c))\n      }\n      rangeStart = ''\n      i++\n      continue\n    }\n\n    // now might be the start of a range.\n    // can be either c-d or c-] or c<more...>] or c] at this point\n    if (glob.startsWith('-]', i + 1)) {\n      ranges.push(braceEscape(c + '-'))\n      i += 2\n      continue\n    }\n    if (glob.startsWith('-', i + 1)) {\n      rangeStart = c\n      i += 2\n      continue\n    }\n\n    // not the start of a range, just a single character\n    ranges.push(braceEscape(c))\n    i++\n  }\n\n  if (endPos < i) {\n    // didn't see the end of the class, not a valid class,\n    // but might still be valid as a literal match.\n    return ['', false, 0, false]\n  }\n\n  // if we got no ranges and no negates, then we have a range that\n  // cannot possibly match anything, and that poisons the whole glob\n  if (!ranges.length && !negs.length) {\n    return ['$.', false, glob.length - pos, true]\n  }\n\n  // if we got one positive range, and it's a single character, then that's\n  // not actually a magic pattern, it's just that one literal character.\n  // we should not treat that as \"magic\", we should just return the literal\n  // character. [_] is a perfectly valid way to escape glob magic chars.\n  if (\n    negs.length === 0 &&\n    ranges.length === 1 &&\n    /^\\\\?.$/.test(ranges[0]) &&\n    !negate\n  ) {\n    const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0]\n    return [regexpEscape(r), false, endPos - pos, false]\n  }\n\n  const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']'\n  const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']'\n  const comb =\n    ranges.length && negs.length\n      ? '(' + sranges + '|' + snegs + ')'\n      : ranges.length\n      ? sranges\n      : snegs\n\n  return [comb, uflag, endPos - pos, true]\n}\n"],"mappings":";;AAAA;AACA;;;;;AAEA;AACA,MAAMA,YAAY,GAA0D;EAC1E,WAAW,EAAE,CAAC,sBAAsB,EAAE,IAAI,CAAC;EAC3C,WAAW,EAAE,CAAC,eAAe,EAAE,IAAI,CAAC;EACpC,WAAW,EAAE,CAAC,KAAK,GAAG,QAAQ,GAAG,IAAI,EAAE,KAAK,CAAC;EAC7C,WAAW,EAAE,CAAC,YAAY,EAAE,IAAI,CAAC;EACjC,WAAW,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC;EAC9B,WAAW,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC;EAC9B,WAAW,EAAE,CAAC,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC;EACzC,WAAW,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC;EAC9B,WAAW,EAAE,CAAC,QAAQ,EAAE,IAAI,CAAC;EAC7B,WAAW,EAAE,CAAC,QAAQ,EAAE,IAAI,CAAC;EAC7B,WAAW,EAAE,CAAC,uBAAuB,EAAE,IAAI,CAAC;EAC5C,WAAW,EAAE,CAAC,SAAS,EAAE,IAAI,CAAC;EAC9B,UAAU,EAAE,CAAC,6BAA6B,EAAE,IAAI,CAAC;EACjD,YAAY,EAAE,CAAC,WAAW,EAAE,KAAK;CAClC;AAED;AACA;AACA,MAAMC,WAAW,GAAIC,CAAS,IAAKA,CAAC,CAACC,OAAO,CAAC,WAAW,EAAE,MAAM,CAAC;AACjE;AACA,MAAMC,YAAY,GAAIF,CAAS,IAC7BA,CAAC,CAACC,OAAO,CAAC,0BAA0B,EAAE,MAAM,CAAC;AAE/C;AACA,MAAME,cAAc,GAAIC,MAAgB,IAAaA,MAAM,CAACC,IAAI,CAAC,EAAE,CAAC;AASpE;AACA;AACA;AACA;AACA;AACA;AACO,MAAMC,UAAU,GAAGA,CACxBC,IAAY,EACZC,QAAgB,KACI;EACpB,MAAMC,GAAG,GAAGD,QAAQ;EACpB;EACA,IAAID,IAAI,CAACG,MAAM,CAACD,GAAG,CAAC,KAAK,GAAG,EAAE;IAC5B,MAAM,IAAIE,KAAK,CAAC,2BAA2B,CAAC;EAC9C;EACA;EACA,MAAMP,MAAM,GAAa,EAAE;EAC3B,MAAMQ,IAAI,GAAa,EAAE;EAEzB,IAAIC,CAAC,GAAGJ,GAAG,GAAG,CAAC;EACf,IAAIK,QAAQ,GAAG,KAAK;EACpB,IAAIC,KAAK,GAAG,KAAK;EACjB,IAAIC,QAAQ,GAAG,KAAK;EACpB,IAAIC,MAAM,GAAG,KAAK;EAClB,IAAIC,MAAM,GAAGT,GAAG;EAChB,IAAIU,UAAU,GAAG,EAAE;EACnBC,KAAK,EAAE,OAAOP,CAAC,GAAGN,IAAI,CAACc,MAAM,EAAE;IAC7B,MAAMC,CAAC,GAAGf,IAAI,CAACG,MAAM,CAACG,CAAC,CAAC;IACxB,IAAI,CAACS,CAAC,KAAK,GAAG,IAAIA,CAAC,KAAK,GAAG,KAAKT,CAAC,KAAKJ,GAAG,GAAG,CAAC,EAAE;MAC7CQ,MAAM,GAAG,IAAI;MACbJ,CAAC,EAAE;MACH;IACF;IAEA,IAAIS,CAAC,KAAK,GAAG,IAAIR,QAAQ,IAAI,CAACE,QAAQ,EAAE;MACtCE,MAAM,GAAGL,CAAC,GAAG,CAAC;MACd;IACF;IAEAC,QAAQ,GAAG,IAAI;IACf,IAAIQ,CAAC,KAAK,IAAI,EAAE;MACd,IAAI,CAACN,QAAQ,EAAE;QACbA,QAAQ,GAAG,IAAI;QACfH,CAAC,EAAE;QACH;MACF;MACA;IACF;IACA,IAAIS,CAAC,KAAK,GAAG,IAAI,CAACN,QAAQ,EAAE;MAC1B;MACA,KAAK,MAAM,CAACO,GAAG,EAAE,CAACC,IAAI,EAAEC,CAAC,EAAEC,GAAG,CAAC,CAAC,IAAIC,MAAM,CAACC,OAAO,CAAC9B,YAAY,CAAC,EAAE;QAChE,IAAIS,IAAI,CAACsB,UAAU,CAACN,GAAG,EAAEV,CAAC,CAAC,EAAE;UAC3B;UACA,IAAIM,UAAU,EAAE;YACd,OAAO,CAAC,IAAI,EAAE,KAAK,EAAEZ,IAAI,CAACc,MAAM,GAAGZ,GAAG,EAAE,IAAI,CAAC;UAC/C;UACAI,CAAC,IAAIU,GAAG,CAACF,MAAM;UACf,IAAIK,GAAG,EAAEd,IAAI,CAACkB,IAAI,CAACN,IAAI,CAAC,MACnBpB,MAAM,CAAC0B,IAAI,CAACN,IAAI,CAAC;UACtBT,KAAK,GAAGA,KAAK,IAAIU,CAAC;UAClB,SAASL,KAAK;QAChB;MACF;IACF;IAEA;IACAJ,QAAQ,GAAG,KAAK;IAChB,IAAIG,UAAU,EAAE;MACd;MACA;MACA,IAAIG,CAAC,GAAGH,UAAU,EAAE;QAClBf,MAAM,CAAC0B,IAAI,CAAC/B,WAAW,CAACoB,UAAU,CAAC,GAAG,GAAG,GAAGpB,WAAW,CAACuB,CAAC,CAAC,CAAC;MAC7D,CAAC,MAAM,IAAIA,CAAC,KAAKH,UAAU,EAAE;QAC3Bf,MAAM,CAAC0B,IAAI,CAAC/B,WAAW,CAACuB,CAAC,CAAC,CAAC;MAC7B;MACAH,UAAU,GAAG,EAAE;MACfN,CAAC,EAAE;MACH;IACF;IAEA;IACA;IACA,IAAIN,IAAI,CAACsB,UAAU,CAAC,IAAI,EAAEhB,CAAC,GAAG,CAAC,CAAC,EAAE;MAChCT,MAAM,CAAC0B,IAAI,CAAC/B,WAAW,CAACuB,CAAC,GAAG,GAAG,CAAC,CAAC;MACjCT,CAAC,IAAI,CAAC;MACN;IACF;IACA,IAAIN,IAAI,CAACsB,UAAU,CAAC,GAAG,EAAEhB,CAAC,GAAG,CAAC,CAAC,EAAE;MAC/BM,UAAU,GAAGG,CAAC;MACdT,CAAC,IAAI,CAAC;MACN;IACF;IAEA;IACAT,MAAM,CAAC0B,IAAI,CAAC/B,WAAW,CAACuB,CAAC,CAAC,CAAC;IAC3BT,CAAC,EAAE;EACL;EAEA,IAAIK,MAAM,GAAGL,CAAC,EAAE;IACd;IACA;IACA,OAAO,CAAC,EAAE,EAAE,KAAK,EAAE,CAAC,EAAE,KAAK,CAAC;EAC9B;EAEA;EACA;EACA,IAAI,CAACT,MAAM,CAACiB,MAAM,IAAI,CAACT,IAAI,CAACS,MAAM,EAAE;IAClC,OAAO,CAAC,IAAI,EAAE,KAAK,EAAEd,IAAI,CAACc,MAAM,GAAGZ,GAAG,EAAE,IAAI,CAAC;EAC/C;EAEA;EACA;EACA;EACA;EACA,IACEG,IAAI,CAACS,MAAM,KAAK,CAAC,IACjBjB,MAAM,CAACiB,MAAM,KAAK,CAAC,IACnB,QAAQ,CAACU,IAAI,CAAC3B,MAAM,CAAC,CAAC,CAAC,CAAC,IACxB,CAACa,MAAM,EACP;IACA,MAAMe,CAAC,GAAG5B,MAAM,CAAC,CAAC,CAAC,CAACiB,MAAM,KAAK,CAAC,GAAGjB,MAAM,CAAC,CAAC,CAAC,CAAC6B,KAAK,CAAC,CAAC,CAAC,CAAC,GAAG7B,MAAM,CAAC,CAAC,CAAC;IAClE,OAAO,CAACF,YAAY,CAAC8B,CAAC,CAAC,EAAE,KAAK,EAAEd,MAAM,GAAGT,GAAG,EAAE,KAAK,CAAC;EACtD;EAEA,MAAMyB,OAAO,GAAG,GAAG,IAAIjB,MAAM,GAAG,GAAG,GAAG,EAAE,CAAC,GAAGd,cAAc,CAACC,MAAM,CAAC,GAAG,GAAG;EACxE,MAAM+B,KAAK,GAAG,GAAG,IAAIlB,MAAM,GAAG,EAAE,GAAG,GAAG,CAAC,GAAGd,cAAc,CAACS,IAAI,CAAC,GAAG,GAAG;EACpE,MAAMwB,IAAI,GACRhC,MAAM,CAACiB,MAAM,IAAIT,IAAI,CAACS,MAAM,GACxB,GAAG,GAAGa,OAAO,GAAG,GAAG,GAAGC,KAAK,GAAG,GAAG,GACjC/B,MAAM,CAACiB,MAAM,GACba,OAAO,GACPC,KAAK;EAEX,OAAO,CAACC,IAAI,EAAErB,KAAK,EAAEG,MAAM,GAAGT,GAAG,EAAE,IAAI,CAAC;AAC1C,CAAC;AAhIY4B,OAAA,CAAA/B,UAAU,GAAAA,UAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}